{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#robotics-programming-course","title":"Robotics Programming Course","text":"<p>Welcome to the Robotics Programming Course covering ICTPRG430 (Apply introductory object-oriented language skills) and ICTPRG439 (Use pre-existing components).</p> Welcome to Country North Metropolitan TAFE recognises Australian Aboriginal and Torres Strait Islander People's unique cultural and spiritual relationships to the land, waters, and seas and their rich contribution to our society. We acknowledge the Mooro Boodjar pand Whadjuk Noongar People, the traditional custodians of the lands on which our campuses are located, and pay our respects to ancestors and Elders, past and present"},{"location":"#course-overview","title":"Course Overview","text":"<p>Duration: 18 sessions (4 hours each, weekly delivery) Focus: Object-oriented programming mastery and component reuse in robotics context Language: Python throughout Platform: Webots simulation with ROS integration for component demonstration Assessment: Portfolio-based with pass/fail requirements</p>"},{"location":"#quick-navigation","title":"Quick Navigation","text":""},{"location":"#course-information","title":"Course Information","text":"<ul> <li>Learning &amp; Assessment Plan - Complete 18-week course schedule</li> <li>Downloads &amp; Resources - Essential files and materials</li> <li>Assessment Information - Portfolio requirements</li> <li>Course Glossary - Key terms and definitions</li> </ul>"},{"location":"#weekly-sessions","title":"Weekly Sessions","text":"Weeks 1-3: Programming FundamentalsWeeks 4-7: OOP TheoryWeeks 8-12: Applied OOP RoboticsWeeks 13-15: Component ResearchWeeks 16-18: Integration &amp; Assessment <p>Building strong testing and debugging foundations</p> <ul> <li>Week 1: Unit Testing Foundations &amp; Binary Search</li> <li>Week 2: Advanced Testing &amp; Algorithmic Challenges  </li> <li>Week 3: Professional Testing &amp; Development Environment</li> </ul> <p>Mastering object-oriented programming concepts</p> <ul> <li>Week 4: Object Model &amp; Class Fundamentals</li> <li>Week 5: Advanced Class Features &amp; Magic Methods</li> <li>Week 6: Inheritance &amp; Polymorphism Mastery</li> <li>Week 7: File I/O &amp; Documentation Standards</li> </ul> <p>Implementing OOP principles in robotics projects</p> <ul> <li>Week 8: Felipe Lab 1 OOP Refactoring</li> <li>Week 9: Felipe Lab 2 OOP Implementation</li> <li>Week 10: Felipe Lab 3 OOP Navigation</li> <li>Week 11: Felipe Lab 4 OOP Control Systems</li> <li>Week 12: Felipe Lab 5 OOP Mission Integration</li> </ul> <p>Analyzing and selecting pre-existing components</p> <ul> <li>Week 13: ROS Component Analysis &amp; Research</li> <li>Week 14: Component Evaluation &amp; Selection</li> <li>Week 15: Integration Planning &amp; Environment Setup</li> </ul> <p>Component integration and final assessment</p> <ul> <li>Week 16: ROS Component Integration - Line Follower</li> <li>Week 17: System Assembly &amp; Documentation</li> <li>Week 18: Portfolio Review &amp; Competency Validation</li> </ul>"},{"location":"#key-resources","title":"Key Resources","text":"<p>Essential Downloads</p> <p>Visit the Downloads page for:</p> <ul> <li>Development environment setup files</li> <li>Project templates and starter code</li> <li>Assessment rubrics and submission templates</li> <li>Lab exercise materials</li> </ul> <p>Getting Started</p> <ol> <li>Review the Learning &amp; Assessment Plan</li> <li>Set up your development environment using materials from Downloads</li> <li>Check the Glossary for key terminology</li> <li>Begin with Week 1</li> </ol>"},{"location":"#assessment-portfolio","title":"Assessment Portfolio","text":"<p>Your competency will be demonstrated through two main portfolio components:</p> <ul> <li>Portfolio 1: OOP Fundamentals and Applied Robotics (Weeks 1-12)</li> <li>Portfolio 2: Component Integration (Weeks 13-17)</li> </ul> <p>Each portfolio includes both theoretical understanding and practical implementation tasks.</p>"},{"location":"#current-week-navigation","title":"Current Week Navigation","text":"<p>Quick Week Access</p> <p>Jump directly to any week:</p> <p>Fundamentals: Week 1 | Week 2 | Week 3</p> <p>OOP Theory: Week 4 | Week 5 | Week 6 | Week 7</p> <p>Applied Robotics: Week 8 | Week 9 | Week 10 | Week 11 | Week 12</p> <p>Components: Week 13 | Week 14 | Week 15</p> <p>Integration: Week 16 | Week 17 | Week 18</p> <p>Ready to begin? Start with the Learning &amp; Assessment Plan or jump directly to Week 1.     - Session 9: Felipe Lab 2 OOP Implementation     - Session 10: Felipe Lab 3 OOP Navigation     - Session 11: Felipe Lab 4 OOP Control Systems     - Session 12: Felipe Lab 5 OOP Mission Integration</p> Phase 4: Component ResearchPhase 5: IntegrationPhase 6: Assessment <p>Sessions 13-15 - Analyzing and selecting pre-existing components</p> <ul> <li>Session 13: ROS Component Analysis &amp; Research</li> <li>Session 14: Component Evaluation &amp; Selection</li> <li>Session 15: Integration Planning &amp; Environment Setup</li> </ul> <p>Sessions 16-17 - Implementing component integration</p> <ul> <li>Session 16: ROS Component Integration - Line Follower</li> <li>Session 17: System Assembly &amp; Documentation</li> </ul> <p>Session 18 - Final competency validation</p> <ul> <li>Session 18: Portfolio Review &amp; Competency Validation</li> </ul>"},{"location":"#key-resources_1","title":"Key Resources","text":"<p>Essential Downloads</p> <p>Visit the (under development) page for:</p> <ul> <li>Development environment setup files</li> <li>Project templates and starter code</li> <li>Lab exercise materials</li> </ul> <p>Getting Started</p> <ol> <li>Review the Learning &amp; Assessment Plan</li> <li>Set up your development environment using materials from Downloads</li> <li>Check the Glossary for key terminology</li> <li>Begin with Session 1</li> </ol>"},{"location":"#assessment-portfolio_1","title":"Assessment Portfolio","text":"<p>Your competency will be demonstrated through two main portfolio components:</p> <ul> <li>Portfolio 1: OOP Fundamentals and Applied Robotics (Sessions 1-12)</li> <li>Portfolio 2: Component Integration (Sessions 13-17)</li> </ul> <p>Each portfolio includes both theoretical understanding and practical implementation tasks.</p>"},{"location":"#support-and-resources","title":"Support and Resources","text":"<ul> <li>Glossary - Definitions of key terms and concepts</li> <li>API Reference - Technical documentation (under development)</li> <li>Troubleshooting - Common issues and solutions (under development)</li> </ul> <p>Ready to begin? Start with the Learning &amp; Assessment Plan to understand the complete course structure.</p>"},{"location":"downloads/","title":"Downloads","text":""},{"location":"downloads/#downloads","title":"Downloads","text":"<p>This page provides access to all essential files, templates, and resources for the Robotics Programming Course.</p>"},{"location":"downloads/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"downloads/#python-development-tools","title":"Python Development Tools","text":"<p>Python Installation</p> <p>Required Python version: 3.9 or higher</p> File Description Size Download <code>python_requirements.txt</code> Python package dependencies 2KB  Download <code>vscode_settings.json</code> VS Code configuration for Python 1KB  Download <code>pytest_config.ini</code> pytest configuration file 1KB  Download"},{"location":"downloads/#webots-simulation-environment","title":"Webots Simulation Environment","text":"File Description Size Download <code>webots_worlds.zip</code> Collection of Webots world files 5MB  Download <code>epuck_controller_template.py</code> Base e-puck controller template 3KB  Download <code>webots_setup_guide.pdf</code> Installation and configuration guide 2MB  Download"},{"location":"downloads/#assessment-materials","title":"Assessment Materials","text":""},{"location":"downloads/#portfolio-templates","title":"Portfolio Templates","text":"File Description Size Download <code>portfolio_1_template.docx</code> ICTPRG430 Portfolio Template 50KB  Download <code>portfolio_2_template.docx</code> ICTPRG439 Portfolio Template 45KB  Download <code>assessment_rubric.pdf</code> Detailed assessment criteria 150KB  Download"},{"location":"downloads/#code-templates","title":"Code Templates","text":"File Description Size Download <code>robot_class_starter.py</code> Basic Robot class structure 2KB  Download <code>unittest_template.py</code> Unit testing template 1KB  Download <code>oop_project_structure.zip</code> Complete project folder structure 10KB  Download"},{"location":"downloads/#phase-specific-resources","title":"Phase-Specific Resources","text":""},{"location":"downloads/#phase-1-programming-fundamentals","title":"Phase 1: Programming Fundamentals","text":"File Description Size Download <code>exercism_track_guide.pdf</code> Exercism platform usage guide 1MB  Download <code>binary_search_starter.py</code> Binary search implementation starter 1KB  Download <code>debugging_exercises.zip</code> Collection of debugging exercises 15KB  Download"},{"location":"downloads/#phase-2-oop-theory","title":"Phase 2: OOP Theory","text":"File Description Size Download <code>class_design_examples.zip</code> Example class implementations 25KB  Download <code>magic_methods_reference.py</code> Python magic methods examples 8KB  Download <code>inheritance_hierarchy.py</code> Robot inheritance examples 5KB  Download"},{"location":"downloads/#week-4-object-model-class-fundamentals","title":"Week 4: Object Model &amp; Class Fundamentals","text":"<p>Lab Attribution</p> <p>Lab exercises are based on Felipe Martins' excellent Robotics-Simulation-Labs repository.</p> File Description Size Download <code>robot_class_starter.py</code> Basic Robot class template 2KB  Download <code>class_implementation_examples.py</code> Complete class implementations 15KB  Download <code>lidar_procedural_clean.py</code> LIDAR procedural implementation 1KB  Download <code>lidar_functional_clean.py</code> LIDAR functional implementation 1KB  Download <code>lidar_oop_clean.py</code> LIDAR object-oriented implementation 2KB  Download"},{"location":"downloads/#phase-3-applied-oop-robotics","title":"Phase 3: Applied OOP Robotics","text":"File Description Size Download <code>felipe_labs_oop.zip</code> OOP versions of Felipe Martins labs 100KB  Download <code>sensor_processing_classes.py</code> Sensor handling class examples 12KB  Download <code>pid_controller_oop.py</code> Object-oriented PID controller 6KB  Download"},{"location":"downloads/#phase-4-component-research","title":"Phase 4: Component Research","text":"File Description Size Download <code>ros_packages_list.xlsx</code> Curated list of ROS packages 25KB  Download <code>component_evaluation_matrix.xlsx</code> Evaluation criteria spreadsheet 18KB  Download <code>licensing_guide.pdf</code> Open source license analysis guide 800KB  Download"},{"location":"downloads/#phase-5-integration","title":"Phase 5: Integration","text":"File Description Size Download <code>ros_webots_bridge.zip</code> ROS-Webots integration package 2MB  Download <code>integration_test_template.py</code> Integration testing framework 4KB  Download <code>system_documentation_template.docx</code> Technical documentation template 35KB  Download"},{"location":"downloads/#reference-materials","title":"Reference Materials","text":""},{"location":"downloads/#api-documentation","title":"API Documentation","text":"File Description Size Download <code>webots_python_api.pdf</code> Webots Python API reference 5MB  Download <code>ros_python_cheatsheet.pdf</code> ROS Python programming guide 2MB  Download"},{"location":"downloads/#code-style-and-standards","title":"Code Style and Standards","text":"File Description Size Download <code>python_style_guide.pdf</code> Course Python coding standards 500KB  Download <code>docstring_examples.py</code> Documentation string examples 3KB  Download <code>.pylintrc</code> Python linting configuration 2KB  Download"},{"location":"downloads/#installation-instructions","title":"Installation Instructions","text":"<p>Prerequisites</p> <p>Before downloading and using these files, ensure you have:</p> <ul> <li>Python 3.9+ installed</li> <li>Git for version control</li> <li>A code editor (VS Code recommended)</li> <li>Sufficient disk space (minimum 2GB for all materials)</li> </ul>"},{"location":"downloads/#quick-setup","title":"Quick Setup","text":"<ol> <li>Download Core Files: Start with <code>python_requirements.txt</code> and <code>vscode_settings.json</code></li> <li>Install Dependencies: Run <code>pip install -r python_requirements.txt</code></li> <li>Configure IDE: Import VS Code settings for optimal Python development</li> <li>Verify Setup: Run the verification script (available in session materials)</li> </ol>"},{"location":"downloads/#file-organization","title":"File Organization","text":"<p>Recommended folder structure for downloaded materials:</p> <pre><code>robotics_course/\n\u251c\u2500\u2500 assessment/\n\u2502   \u251c\u2500\u2500 portfolios/\n\u2502   \u2514\u2500\u2500 templates/\n\u251c\u2500\u2500 code/\n\u2502   \u251c\u2500\u2500 examples/\n\u2502   \u251c\u2500\u2500 templates/\n\u2502   \u2514\u2500\u2500 exercises/\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 guides/\n\u2502   \u2514\u2500\u2500 references/\n\u2514\u2500\u2500 webots/\n    \u251c\u2500\u2500 worlds/\n    \u2514\u2500\u2500 controllers/\n</code></pre>"},{"location":"downloads/#version-information","title":"Version Information","text":"<p>File Versions</p> <p>All files are maintained with version control. Check the filename or document header for version information. Latest updates as of August 2025.</p>"},{"location":"downloads/#need-help","title":"Need Help?","text":"<p>If you encounter issues downloading or using any files:</p> <ol> <li>Check the Troubleshooting guide</li> <li>Verify your internet connection and browser settings</li> <li>Contact your instructor for alternative download methods</li> </ol> <p>Files are updated regularly. Bookmark this page and check for updates before each session.</p>"},{"location":"Robotics-Simulation-Labs-main/Lab3/ReadMe/","title":"Labs 1 -4","text":""},{"location":"Robotics-Simulation-Labs-main/Lab3/ReadMe/#lab-3-odometry-based-localization","title":"Lab 3 \u2013 Odometry-based Localization","text":""},{"location":"Robotics-Simulation-Labs-main/Lab3/ReadMe/#objective","title":"Objective","text":"<p>The goal of this lab is to implement a simple algorithm for odometry-based robot localization and evaluate its accuracy.</p>"},{"location":"Robotics-Simulation-Labs-main/Lab3/ReadMe/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>You must have Webots R2022a (or newer) properly configured to work with Python (see Lab 1).</li> <li>You must know how to create a robot controller in Python and how to run a simulation (see Lab 1). </li> <li>You should have a working solution of Lab 2.  </li> </ul>"},{"location":"Robotics-Simulation-Labs-main/Lab3/ReadMe/#robot-pose","title":"Robot Pose","text":"<p>To see the pose of the robot as calculated by Webots, click on \u201cDEF E_PUCK E-puck\u201d on the left menu and select \u201ctranslation\u201d. You will see the values of position and orientation of the robot (see Figure 1). You should print the position calculated by your functions at the end of each cycle, as shown in Figure 1, to facilitate comparison with the pose as calculated by Webots.</p> <p></p>"},{"location":"Robotics-Simulation-Labs-main/Lab3/ReadMe/#figure-1-webots-screenshot-showing-robot-pose-calculated-by-the-simulator-left-and-by-the-python-code-bottom","title":"Figure 1. Webots screenshot showing robot pose calculated by the simulator (left) and by the Python code (bottom).","text":""},{"location":"Robotics-Simulation-Labs-main/Lab3/ReadMe/#tasks","title":"Tasks","text":"<p>Your main task is to write code to implement the functions below to add localization capability to your line-following behavior. The functions below should be called in sequence in the main loop of your program: </p><pre><code>    # Compute speed of the wheels\n    [wl, wr] = get_wheels_speed(encoderValues, oldEncoderValues, delta_t)\n\n    # Compute robot linear and angular speeds\n    [u, w] = get_robot_speeds(wl, wr, R, D)\n\n    # Compute new robot pose\n    [x, y, phi] = get_robot_pose(u, w, x, y, phi, delta_t)\n</code></pre> <p>The tasks are listed below:</p> <ol> <li>Write the function <code>get_wheels_speed(encoderValues, oldEncoderValues, delta_t)</code> to calculate the speed of the robot wheels based on encoder readings. Test your code before moving to the next step.</li> <li>Write the function <code>get_robot_speeds(wl, wr, R, D)</code> to calculate the linear and angular speeds of the robot based on the speed of its wheels. Test your code before moving to the next step.</li> <li>Write the function <code>get_robot_pose(u, w, x, y, phi, delta_t)</code> to calculate the position and orientation of the robot based on its orientation and linear and angular speeds.</li> <li>Compare the pose calculated by your functions with the pose calculated by Webots in different moments of the simulation. </li> </ol>"},{"location":"Robotics-Simulation-Labs-main/Lab3/ReadMe/#some-information-for-implementing-the-code","title":"Some information for implementing the code","text":"<p>The definition of the variables used in the functions is given below.</p> <pre><code>Robot pose and speed in (x,y) coordinates:\nx = position in x [m]\ny = position in y [m]\nphi = orientation [rad]\ndx = speed in x [m/s]\ndy = speed in y [m/s]\ndphi = orientation speed [rad/s]\n\nRobot wheel speeds:\nwl = angular speed of the left wheel [rad/s]\nwr = angular speed of the right wheel [rad/s]\n\nRobot linear and angular speeds:\nu = linear speed [m/s]\nw = angular speed [rad/s]\n\nPeriod of the cycle:\ndelta_t = time step [s]\n</code></pre> <p>To calculate robot localization you will need to use some physical parameters of the robot:</p> <pre><code>R = radius of the wheels [m]: 20.5mm \nD = distance between the wheels [m]: 52mm \n</code></pre> <p>You can use the pieces of code below to initialize the encoder sensors and to read encoder values in the main loop of your program:</p> <p>To initialize encoders: </p><pre><code>encoder = []\nencoderNames = ['left wheel sensor', 'right wheel sensor']\nfor i in range(2):\n    encoder.append(robot.getDevice(encoderNames[i]))\n    encoder[i].enable(timestep)\n</code></pre> <p>To read the encoders in the main loop: </p><pre><code>    encoderValues = []\n    for i in range(2):\n        encoderValues.append(encoder[i].getValue())    # [rad]\n</code></pre> The encoder values are incremented when the corresponding wheel moves forwards and decremented when it moves backwards."},{"location":"Robotics-Simulation-Labs-main/Lab3/ReadMe/#think-about-the-following-questions","title":"Think about the following questions","text":"<ul> <li>How accurate is the odometry-based localization?</li> <li>In what conditions is odometry-based localication useful? And when is it problematic?</li> </ul>"},{"location":"Robotics-Simulation-Labs-main/Lab3/ReadMe/#solution","title":"Solution","text":"<p>A partial solution is provided for this lab. I recommend you first try to modify your line following code from Lab 2 to implement the localization as described above. If you need inspiration, you can use the provided template. </p> <p>If you need extra explanation, check the Jupyter Notebook for Odometry-based Localization.</p>"},{"location":"Robotics-Simulation-Labs-main/Lab3/ReadMe/#about-localization-error","title":"About localization error","text":"<p>The algorithm for odometry-based localization presented in the Jupyter Notebook above applies the Euler method, which is a first-order method for numerical integration of differential equations. This is probably the simplest way to implement numerical integration, but the resulting value contains an error proportional to the step size (delta_t). </p> <p>In my simulations, with a time step of 32 ms, the pose estimation would quickly diverge from the \"true\" robot pose indicated by Webots after only a few seconds of simulated time. I had to reduce the time step to 4 ms to get an acceptable level of error for about one minute of simulated time. You can adjust the time step by changing the value of the variable \"basicTimeStep\" of \"WorldInfo\", on the left menu. </p> <p>Note that the error also depends on the path followed by the robot, but the above comparison serves to illustrate how much the time step influences the pose estimation error.  </p> <p>Tip: Reducing the time step increases computation demand, which results in slower simulations. You can increase simulation speed by reducing the number of \"FPS\" to a minimum.</p>"},{"location":"Robotics-Simulation-Labs-main/Lab3/ReadMe/#challenge-1-d-kalman-filter","title":"Challenge: 1-D Kalman Filter","text":"<p>Use another sensor (like a compass or gyroscope) to estimate the orientation of the robot. Implement a 1-D Kalman Filter to combine the values given by this extra sensor with the orientation calculated via odometry to get a better estimate of the robot orientation. </p> <p>No solution is provided for the challenge. In this post you find explanation about the 1-D Kalman Filter and how to implement it in Python. </p>"},{"location":"Robotics-Simulation-Labs-main/Lab3/ReadMe/#conclusion","title":"Conclusion","text":"<p>After following this lab you should know more about the implementation and limitations of odometry-based localization for mobile robots.</p>"},{"location":"Robotics-Simulation-Labs-main/Lab3/ReadMe/#next-lab","title":"Next Lab","text":"<p>Go to Lab 4 - Go-to-goal behavior with PID</p> <p>Back to main page.</p>"},{"location":"Robotics-Simulation-Labs-main/Lab4/ReadMe/","title":"Lab 4 \u2013 Go-to-goal behavior with PID","text":""},{"location":"Robotics-Simulation-Labs-main/Lab4/ReadMe/#lab-4-go-to-goal-behavior-with-pid","title":"Lab 4 \u2013 Go-to-goal behavior with PID","text":""},{"location":"Robotics-Simulation-Labs-main/Lab4/ReadMe/#objective","title":"Objective","text":"<p>The goal of this lab is to implement a go-to-goal behavior based on a PID controller. Figure 1 illustrates the go-to-goal implementation for 2 positions in a sequence. </p> <p></p>"},{"location":"Robotics-Simulation-Labs-main/Lab4/ReadMe/#figure-1-illustration-of-the-go-to-goal-controller-reaching-two-goals-in-sequence-after-reaching-the-final-goal-the-robot-stops","title":"Figure 1. Illustration of the Go-to-Goal controller reaching two goals in sequence. After reaching the final goal, the robot stops.","text":""},{"location":"Robotics-Simulation-Labs-main/Lab4/ReadMe/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>You must have Webots R2022a (or newer) properly configured to work with Python (see Lab 1).</li> <li>You must know how to create a robot controller in Python and how to run a simulation (see Lab 1). </li> <li>You should have a working solution of Lab 3.  </li> <li>You should understand how PID controllers work. If you need a refresh on the theory, check out this great explanation from Michael Hart on Understanding PID Controllers.</li> </ul>"},{"location":"Robotics-Simulation-Labs-main/Lab4/ReadMe/#tasks","title":"Tasks","text":"<p>Your main task is to write code to implement the PID controller to control the robot orientation. Note that the PID controller needs information about the actual robot orientation, so the odometry-based localization algorithm implemented in Lab 3 needs to be working. You are going to modify the line-following behavior to add the go-to-goal behavior, which will be activated by a new state in your state machine.</p> <p>The tasks are detailed below:</p> <p>1- Create a function to calculate position and orientation errors based on the estimated and desired positions of the robot. An example is shown below:</p> <pre><code>import numpy as np\n\n# Position error:\nx_err = xd - x\ny_err = yd \u2013 y\ndist_err = np.sqrt(x_err**2 + y_err**2)\n\n# Orientation error\nphi_d = np.arctan2(y_err,x_err)\nphi_err = phi_d \u2013 phi\n\n# Limit the error to (-pi, pi):\nphi_err_correct = np.arctan2(np.sin(phi_err),np.cos(phi_err))\n</code></pre> <p>2- Create a new function that implements a \"go-to-goal\" behavior using a PID controller. Your PID controller must control the robot orientation by adjusting its angular speed. A simple implementation of a PID controller is illustrated below:</p> <pre><code># PID algortithm: must be executed every delta_t seconds\n# The error is calculated as: e = desired_value - actual_value\n\nP = kp * e                      # Proportional term; kp is the proportional gain\nI = e_acc + ki * e * delta_t    # Intergral term; ki is the integral gain\nD = kd * (e - e_prev)/delta_t   # Derivative term; kd is the derivative gain\n\noutput = P + I + D              # controller output\n\n# store values for the next iteration\ne_prev = e     # error value in the previous interation (to calculate the derivative term)\ne_acc = I      # accumulated error value (to calculate the integral term)\n</code></pre> <p>3- Using the code from Lab 3, create a new \"go-to-goal\" state that is activated when the robot reaches approximately half of the track. In other words, the robot starts by following the line using the state-machine with localization implemented in lab 3. When it gets half-way through the path, the new \"go-to-goal\" state is activated. </p> <p>A list of goal positions is given in the program. One should be able to add as many goal positions as desired. After reaching the final goal position, the robot must stop.</p> <p>Implement your code so that the robot goes from its current position to the next goal position, stops, and stays there for some short time (1 second, for example). Then, the robot should move to the subsequent goal position and repeat the cycle until it reaches the final goal position. Everytime the robot stops at a goal, it has to print its own position and distance error to the goal.</p> <p>4- Test your code by making the robot go to the 4 corners of the field (without touching the walls), and then to the center of the field. </p>"},{"location":"Robotics-Simulation-Labs-main/Lab4/ReadMe/#actuator-saturation","title":"Actuator Saturation","text":"<p>The desired speeds for the left and right wheels will be calculated from the desired values of linear and/or angular speeds. If the desired speed for one of the wheels is higher than the maximum speed that its motor can achieve, the wheel will not be able to follow the speed desired by the controller. We say that there is actuator saturation. In this case, the difference between the speeds of the left and right wheels will be smaller than expected, which will cause the robot to turn at a different angular speed than desired by the PID controller. As a result, the robot will not turn to the direction of the goal. And if both motors are saturated, the robot will not turn at all!</p> <p>Actuator saturation is a potential problem in all control systems, so we need to keep it in mind. In the case of the \"go-to-goal\" controller for the differential-drive robot, it is very important that the robot drives towards the correct direction, and no so important that it moves with the desired linear speed. Therefore, we can avoid the saturation problem by reducing the overall robot speed while maintaining its angular speed.</p> <p>The code below implements the solution discussed above by calculating a <code>speed_ratio</code>. When saturation occurs, one of the motors will have its speed reduced so that the desired speed ratio is maintained. </p> <pre><code>def wheel_speed_commands(u_d, w_d, d, r):\n    \"\"\"Convert desired robot speeds to desired wheel speeds\"\"\"\n    wr_d = float((2 * u_d + d * w_d) / (2 * r))\n    wl_d = float((2 * u_d - d * w_d) / (2 * r))\n\n    # If saturated, correct speeds to keep the original turning ratio\n    if np.abs(wl_d) &gt; MAX_SPEED or np.abs(wr_d) &gt; MAX_SPEED:\n        speed_ratio = np.abs(wr_d)/np.abs(wl_d)\n        if speed_ratio &gt; 1:\n            wr_d = np.sign(wr_d)*MAX_SPEED\n            wl_d = np.sign(wl_d)*MAX_SPEED/speed_ratio\n        else:\n            wl_d = np.sign(wl_d)*MAX_SPEED\n            wr_d = np.sign(wr_d)*MAX_SPEED*speed_ratio\n\n    return wl_d, wr_d\n</code></pre> <p>Compare the controller performance with and without the saturation correction. </p>"},{"location":"Robotics-Simulation-Labs-main/Lab4/ReadMe/#task","title":"Task","text":"<p>Modify your line following code with localization from Lab 3 to implement the go-to-goal behavior as described above. </p>"},{"location":"Robotics-Simulation-Labs-main/Lab4/ReadMe/#solution","title":"Solution","text":"<p>No solution is provided for this lab. If you need extra explanation, study the Jupyter Notebook for Mobile Robot Control with PID.</p>"},{"location":"Robotics-Simulation-Labs-main/Lab4/ReadMe/#challenge-pose-control","title":"Challenge: Pose Control","text":"<p>Change your code to implement pose control (position and orientation). </p> <p>Tips: Two simple ways of implementing pose control are: * Adjust the robot orientation after it reaches the goal position. Or, * Adjust the robot orientation at a point before it reaches the goal, then move straight to the goal.</p>"},{"location":"Robotics-Simulation-Labs-main/Lab4/ReadMe/#conclusion","title":"Conclusion","text":"<p>After following this lab you should know how to implement a moving controller using a PID to take a mobile robot to specific positions defined by their coordinates.</p>"},{"location":"Robotics-Simulation-Labs-main/Lab4/ReadMe/#next-lab","title":"Next Lab","text":"<p>Go to Lab 5 - Combine Behaviors to Complete a Mission</p> <p>Back to main page.</p>"},{"location":"course-overview/revised_lap/","title":"Course Overview","text":""},{"location":"course-overview/revised_lap/#learning-and-assessment-plan-robotics-programming-course","title":"Learning and Assessment Plan - Robotics Programming Course","text":""},{"location":"course-overview/revised_lap/#ictprg430-apply-introductory-object-oriented-language-skills-ictprg439-use-pre-existing-components","title":"ICTPRG430 (Apply introductory object-oriented language skills) + ICTPRG439 (Use pre-existing components)","text":""},{"location":"course-overview/revised_lap/#course-overview","title":"Course Overview","text":"<p>Duration: 18 sessions (4 hours each, weekly delivery) Focus: Object-oriented programming mastery and component reuse in robotics context Language: Python throughout Platform: Webots simulation with ROS integration for component demonstration Assessment: Portfolio-based with pass/fail requirements</p>"},{"location":"course-overview/revised_lap/#learning-and-assessment-schedule","title":"Learning and Assessment Schedule","text":""},{"location":"course-overview/revised_lap/#phase-1-programming-fundamentals-sessions-1-3","title":"Phase 1: Programming Fundamentals (Sessions 1-3)","text":"Session Element Topic &amp; Focus Learning Resources* Structured out of class activities* Hours Week 1 (4hrs) ICTPRG430 Element 3.1 Unit Testing Foundations &amp; Binary SearchFocus: Test-driven development mindset, algorithmic thinking Exercism Platform, pytest documentation Complete Binary Search exercise with comprehensive test suite 2 Week 2 (4hrs) ICTPRG430 Element 3.1 Advanced Testing &amp; Algorithmic ChallengesFocus: Complex testing scenarios, debugging techniques Exercism Platform, Python debugging tools Complete additional algorithmic challenges with full test coverage 3 Week 3 (4hrs) ICTPRG430 Element 3.1 Professional Testing &amp; Development EnvironmentFocus: Industry testing practices, debugging tools mastery Python debugger documentation, IDE setup guides, testing frameworks Practice advanced debugging exercises, finalize development environment 2"},{"location":"course-overview/revised_lap/#phase-2-object-oriented-programming-theory-sessions-4-7","title":"Phase 2: Object-Oriented Programming Theory (Sessions 4-7)","text":"Session Element Topic &amp; Focus Learning Resources* Structured out of class activities* Hours Week 4 (4hrs) ICTPRG430 Element 2.1 Object Model &amp; Class FundamentalsFocus: Classes, objects, instantiation, instance variables/methods OOP programming fundamentals, class design principles Implement basic Robot class hierarchy with proper encapsulation 3 Week 5 (4hrs) ICTPRG430 Element 2.1 Advanced Class Features &amp; Magic MethodsFocus: Properties, class methods, magic methods, operators Python magic methods documentation, operator overloading guides Implement Robot class with full magic method suite and operators 3 Week 6 (4hrs) ICTPRG430 Element 2.1 Inheritance &amp; Polymorphism MasteryFocus: Class inheritance, super(), method resolution, polymorphic behaviors Inheritance design patterns, polymorphism examples Design complete robot inheritance hierarchy with polymorphic interfaces 4 Week 7 (4hrs) ICTPRG430 Element 2.2 File I/O &amp; Documentation StandardsFocus: File operations, JSON/XML parsing, professional documentation Python file handling documentation, docstring conventions Implement configuration system with comprehensive documentation 3 <p>Portfolio 1 Assessment Point</p> <p>AT Task 1 - OOP Fundamentals Portfolio (Due end of Week 7)</p>"},{"location":"course-overview/revised_lap/#phase-3-applied-oop-robotics-sessions-8-12","title":"Phase 3: Applied OOP Robotics (Sessions 8-12)","text":"Session Element Topic &amp; Focus Learning Resources* Structured out of class activities* Hours Week 8 (4hrs) ICTPRG430 Element 1.1 Felipe Lab 1 OOP RefactoringFocus: Convert procedural robot movement to class-based architecture Felipe Martins Lab 1, Webots Python API Refactor Lab 1 using OOP principles with unit test integration 3 Week 9 (4hrs) ICTPRG430 Element 2.1 Felipe Lab 2 OOP ImplementationFocus: Inheritance and sensor processing with line-following behavior Felipe Martins Lab 2, sensor processing algorithms Implement line-following robot with proper inheritance hierarchy 4 Week 10 (4hrs) ICTPRG430 Element 2.1 Felipe Lab 3 OOP NavigationFocus: Polymorphism and localization systems using OOP design Felipe Martins Lab 3, localization algorithms Create odometry-based navigation system with polymorphic interfaces 4 Week 11 (4hrs) ICTPRG430 Element 3.1 Felipe Lab 4 OOP Control SystemsFocus: Advanced algorithms and testing in object-oriented framework Felipe Martins Lab 4, PID control theory Implement PID controller system with comprehensive testing 3 Week 12 (4hrs) ICTPRG430 Element 4.1-4.2 Felipe Lab 5 OOP Mission IntegrationFocus: Complete system integration and user acceptance Felipe Martins Lab 5, behavior coordination Complete mission-based robot system with full documentation 4 <p>Portfolio 1 Assessment Point</p> <p>AT Task 2-5 - Applied OOP Robotics Portfolio (Due progressively through Weeks 8-12)</p>"},{"location":"course-overview/revised_lap/#phase-4-component-research-analysis-sessions-13-15","title":"Phase 4: Component Research &amp; Analysis (Sessions 13-15)","text":"Session Element Topic &amp; Focus Learning Resources* Structured out of class activities* Hours Week 13 (4hrs) ICTPRG439 Element 1.1-1.2 ROS Component Analysis &amp; ResearchFocus: Component identification, functionality analysis, source evaluation ROS package documentation, Mastering ROS Chapter 5 Research ROS packages for line-following robot enhancement 4 Week 14 (4hrs) ICTPRG439 Element 2.1-2.4 Component Evaluation &amp; SelectionFocus: Suitability assessment, licensing analysis, cost evaluation Open source licensing guides, cost analysis methodologies Complete formal component evaluation matrix for selected ROS packages 3 Week 15 (4hrs) ICTPRG439 Element 2.5-3.1 Integration Planning &amp; Environment SetupFocus: Technical impact analysis, ROS-Webots development environment Mastering ROS Chapter 5, ROS-Webots integration documentation Set up ROS-Webots integrated development environment 3"},{"location":"course-overview/revised_lap/#phase-5-component-integration-implementation-sessions-16-17","title":"Phase 5: Component Integration Implementation (Sessions 16-17)","text":"Session Element Topic &amp; Focus Learning Resources* Structured out of class activities* Hours Week 16 (4hrs) ICTPRG439 Element 3.2-3.4 ROS Component Integration - Line FollowerFocus: Test program development, incremental integration, dependency resolution Selected ROS component documentation, integration examples In-class development only - ROS integration with line-following robot 0 Week 17 (4hrs) ICTPRG439 Element 3.5-3.6 System Assembly &amp; DocumentationFocus: Final system testing, issue resolution, professional documentation Professional documentation templates, ROS best practices In-class development only - Complete system documentation and validation 0 <p>Portfolio 2 Assessment Point</p> <p>ICTPRG439 Component Integration Portfolio (Due end of Week 17)</p>"},{"location":"course-overview/revised_lap/#phase-6-assessment-completion-session-18","title":"Phase 6: Assessment &amp; Completion (Session 18)","text":"Session Element Topic &amp; Focus Learning Resources* Structured out of class activities* Hours Week 18 (4hrs) Both Units Portfolio Review &amp; Competency ValidationFocus: Final competency demonstration, portfolio completion, resit opportunities Course materials review, industry standards reference Review and complete any outstanding portfolio items 2"},{"location":"course-overview/revised_lap/#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Resources: Downloads &amp; Materials</li> <li>Assessment: Portfolio Requirements </li> <li>Reference: Course Glossary</li> </ul> <p>* Learning Resources and Structured Activities detailed in individual session pages</p>"},{"location":"files/downloads_page/","title":"Downloads","text":""},{"location":"files/downloads_page/#downloads","title":"Downloads","text":"<p>This page provides access to all essential files, templates, and resources for the Robotics Programming Course.</p>"},{"location":"files/downloads_page/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"files/downloads_page/#python-development-tools","title":"Python Development Tools","text":"<p>Python Installation</p> <p>Required Python version: 3.9 or higher</p> File Description Size Download <code>python_requirements.txt</code> Python package dependencies 2KB  Download <code>vscode_settings.json</code> VS Code configuration for Python 1KB  Download <code>pytest_config.ini</code> pytest configuration file 1KB  Download"},{"location":"files/downloads_page/#webots-simulation-environment","title":"Webots Simulation Environment","text":"File Description Size Download <code>webots_worlds.zip</code> Collection of Webots world files 5MB  Download <code>epuck_controller_template.py</code> Base e-puck controller template 3KB  Download <code>webots_setup_guide.pdf</code> Installation and configuration guide 2MB  Download"},{"location":"files/downloads_page/#assessment-materials","title":"Assessment Materials","text":""},{"location":"files/downloads_page/#portfolio-templates","title":"Portfolio Templates","text":"File Description Size Download <code>portfolio_1_template.docx</code> ICTPRG430 Portfolio Template 50KB  Download <code>portfolio_2_template.docx</code> ICTPRG439 Portfolio Template 45KB  Download <code>assessment_rubric.pdf</code> Detailed assessment criteria 150KB  Download"},{"location":"files/downloads_page/#code-templates","title":"Code Templates","text":"File Description Size Download <code>robot_class_starter.py</code> Basic Robot class structure 2KB  Download <code>unittest_template.py</code> Unit testing template 1KB  Download <code>oop_project_structure.zip</code> Complete project folder structure 10KB  Download"},{"location":"files/downloads_page/#phase-specific-resources","title":"Phase-Specific Resources","text":""},{"location":"files/downloads_page/#phase-1-programming-fundamentals","title":"Phase 1: Programming Fundamentals","text":"File Description Size Download <code>exercism_track_guide.pdf</code> Exercism platform usage guide 1MB  Download <code>binary_search_starter.py</code> Binary search implementation starter 1KB  Download <code>debugging_exercises.zip</code> Collection of debugging exercises 15KB  Download"},{"location":"files/downloads_page/#phase-2-oop-theory","title":"Phase 2: OOP Theory","text":"File Description Size Download <code>class_design_examples.zip</code> Example class implementations 25KB  Download <code>magic_methods_reference.py</code> Python magic methods examples 8KB  Download <code>inheritance_hierarchy.py</code> Robot inheritance examples 5KB  Download"},{"location":"files/downloads_page/#phase-3-applied-oop-robotics","title":"Phase 3: Applied OOP Robotics","text":"File Description Size Download <code>felipe_labs_oop.zip</code> OOP versions of Felipe Martins labs 100KB  Download <code>sensor_processing_classes.py</code> Sensor handling class examples 12KB  Download <code>pid_controller_oop.py</code> Object-oriented PID controller 6KB  Download"},{"location":"files/downloads_page/#phase-4-component-research","title":"Phase 4: Component Research","text":"File Description Size Download <code>ros_packages_list.xlsx</code> Curated list of ROS packages 25KB  Download <code>component_evaluation_matrix.xlsx</code> Evaluation criteria spreadsheet 18KB  Download <code>licensing_guide.pdf</code> Open source license analysis guide 800KB  Download"},{"location":"files/downloads_page/#phase-5-integration","title":"Phase 5: Integration","text":"File Description Size Download <code>ros_webots_bridge.zip</code> ROS-Webots integration package 2MB  Download <code>integration_test_template.py</code> Integration testing framework 4KB  Download <code>system_documentation_template.docx</code> Technical documentation template 35KB  Download"},{"location":"files/downloads_page/#reference-materials","title":"Reference Materials","text":""},{"location":"files/downloads_page/#api-documentation","title":"API Documentation","text":"File Description Size Download <code>webots_python_api.pdf</code> Webots Python API reference 5MB  Download <code>ros_python_cheatsheet.pdf</code> ROS Python programming guide 2MB  Download"},{"location":"files/downloads_page/#code-style-and-standards","title":"Code Style and Standards","text":"File Description Size Download <code>python_style_guide.pdf</code> Course Python coding standards 500KB  Download <code>docstring_examples.py</code> Documentation string examples 3KB  Download <code>.pylintrc</code> Python linting configuration 2KB  Download"},{"location":"files/downloads_page/#installation-instructions","title":"Installation Instructions","text":"<p>Prerequisites</p> <p>Before downloading and using these files, ensure you have:</p> <ul> <li>Python 3.9+ installed</li> <li>Git for version control</li> <li>A code editor (VS Code recommended)</li> <li>Sufficient disk space (minimum 2GB for all materials)</li> </ul>"},{"location":"files/downloads_page/#quick-setup","title":"Quick Setup","text":"<ol> <li>Download Core Files: Start with <code>python_requirements.txt</code> and <code>vscode_settings.json</code></li> <li>Install Dependencies: Run <code>pip install -r python_requirements.txt</code></li> <li>Configure IDE: Import VS Code settings for optimal Python development</li> <li>Verify Setup: Run the verification script (available in session materials)</li> </ol>"},{"location":"files/downloads_page/#file-organization","title":"File Organization","text":"<p>Recommended folder structure for downloaded materials:</p> <pre><code>robotics_course/\n\u251c\u2500\u2500 assessment/\n\u2502   \u251c\u2500\u2500 portfolios/\n\u2502   \u2514\u2500\u2500 templates/\n\u251c\u2500\u2500 code/\n\u2502   \u251c\u2500\u2500 examples/\n\u2502   \u251c\u2500\u2500 templates/\n\u2502   \u2514\u2500\u2500 exercises/\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 guides/\n\u2502   \u2514\u2500\u2500 references/\n\u2514\u2500\u2500 webots/\n    \u251c\u2500\u2500 worlds/\n    \u2514\u2500\u2500 controllers/\n</code></pre>"},{"location":"files/downloads_page/#version-information","title":"Version Information","text":"<p>File Versions</p> <p>All files are maintained with version control. Check the filename or document header for version information. Latest updates as of August 2025.</p>"},{"location":"files/downloads_page/#need-help","title":"Need Help?","text":"<p>If you encounter issues downloading or using any files:</p> <ol> <li>Check the Troubleshooting guide</li> <li>Verify your internet connection and browser settings</li> <li>Contact your instructor for alternative download methods</li> </ol> <p>Files are updated regularly. Bookmark this page and check for updates before each session.</p>"},{"location":"images/session-05/","title":"Session 5: Advanced Class Features &amp; Magic Methods","text":""},{"location":"images/session-05/#session-5-advanced-class-features-magic-methods","title":"Session 5: Advanced Class Features &amp; Magic Methods","text":"<p>Week: 5 Element: ICTPRG430 Element 2.2 Duration: 4 hours Phase: Object-Oriented Programming </p>"},{"location":"images/session-05/#session-introduction","title":"Session Introduction","text":"<p>In this session, you'll explore advanced Python class features that make your robotics code more professional and maintainable. You'll learn how to make your robot objects display themselves clearly using magic methods (<code>__str__</code> and <code>__repr__</code>), understand the fundamentals of data encapsulation through getters and setters (both traditional and decorator approaches), and see how function wrapping works. The session culminates with Lab 2, where you'll implement a line-following robot using object-oriented principles in Webots simulator.</p>"},{"location":"images/session-05/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this session, you will be able to:</p> <ul> <li>Implement and distinguish between <code>__str__</code> and <code>__repr__</code> magic methods</li> <li>Understand when and why to use each string representation method</li> <li>Create getter and setter methods for controlled data access</li> <li>Apply the <code>@property</code> decorator for Pythonic attribute access</li> <li>Understand function wrapping concepts as preparation for decorators</li> <li>Design object-oriented solutions for line-following robot behaviors</li> <li>Implement sensor fusion and control logic in a robotics context</li> </ul>"},{"location":"images/session-05/#session-structure","title":"Session Structure","text":"<ol> <li>Theory Session - Magic methods and string representations</li> <li>Hands-on Exercise - Implementing <code>__str__</code> and <code>__repr__</code> for robot classes</li> <li>Data Encapsulation - Traditional getters/setters and property decorators</li> <li>Function Wrapping - Understanding decorator foundations</li> <li>Lab 2 - Line-following robot implementation in Webots</li> </ol>"},{"location":"images/session-05/#session-overview","title":"Session Overview","text":"<p>This session builds on the foundational OOP concepts from Session 4, introducing advanced class features that make your robotics code more robust and professional. We'll focus on how objects represent themselves and how to control access to object data.</p>"},{"location":"images/session-05/#pre-session-preparation","title":"Pre-Session Preparation","text":"<p>Setup Check</p> <p>Ensure your development environment is ready:</p> <pre><code>- Python 3.9+ with Webots integration working\n- VS Code with Python\n- Completed Session 4 robot class exercises\n</code></pre>"},{"location":"images/session-05/#1-magic-methods-making-objects-talk","title":"1. Magic Methods: Making Objects Talk","text":"<p>Magic methods (also called \"dunder methods\" because they have **d**ouble **under**scores) are special Python methods that define how objects behave in specific situations. Today we'll focus on the two most important ones for displaying object information: <code>__str__</code> and <code>__repr__</code>.</p>"},{"location":"images/session-05/#why-magic-methods-matter-in-robotics","title":"Why Magic Methods Matter in Robotics","text":"<p>When debugging robot behavior, you need clear, informative output about your objects. Without magic methods, Python gives you useless information:</p> <pre><code># Without magic methods - unhelpful output\nrobot = EPuckRobot(\"Alpha_7\", 98.5)\nprint(robot)\n# Output: &lt;__main__.EPuckRobot object at 0x7f8b8c0a1d30&gt;\n</code></pre> <p>With proper magic methods, you get meaningful information:</p> <pre><code># With magic methods - useful output\nrobot = EPuckRobot(\"Alpha_7\", 98.5)\nprint(robot)\n# Output: EPuckRobot(robot_id='Alpha_7', battery=98.5%, speed=0.0, moving=False)\n</code></pre>"},{"location":"images/session-05/#understanding-__str__-vs-__repr__","title":"Understanding <code>__str__</code> vs <code>__repr__</code>","text":"<p>Abstract</p> <p>\"Key Differences\"</p> <p><code>__str__</code> : For end users - human-readable, friendly format</p> <ul> <li>Called by <code>print()</code> and <code>str()</code></li> <li>Should be clear and informative for users</li> <li>Think: \"What would a robot operator want to see?\"</li> </ul> <p><code>__repr__</code>: For developers - precise, unambiguous format</p> <ul> <li>Called by <code>repr()</code> and when displaying in lists/debugger</li> <li>Should ideally be valid Python code to recreate the object</li> <li>Think: \"What would help a programmer debug this?\"</li> </ul>"},{"location":"images/session-05/#2-implementing-string-representations","title":"2. Implementing String Representations","text":"<p>Let's enhance our EPuckRobot class from Session 4 with proper string representations.</p>"},{"location":"images/session-05/#epuckrobot-enhanced-class-uml-structure","title":"EPuckRobot Enhanced Class UML Structure","text":"<pre><code>classDiagram\n    class EPuckRobot {\n        -str robot_id\n        -float battery_percentage\n        -float current_speed\n        -bool is_moving\n        +__init__(robot_id: str, initial_battery_percentage: float) EPuckRobot\n        +__str__() str\n        +__repr__() str\n        +move_forward(speed: float) void\n        +stop() void\n        +report_status() str\n    }\n\n    note for EPuckRobot \"Enhanced with string representation methods\\nfor better debugging and user interaction\"</code></pre> <p>Interactive Code Example</p> <p>Try this interactive example to experiment with the concepts:</p> <p></p>"},{"location":"images/session-05/#hands-on-exercise-enhanced-ir-sensor-with-string-representations","title":"Hands-on Exercise: Enhanced IR Sensor with String Representations","text":"<p>Building on Session 4's IR Sensor class, you'll now add professional string representations.</p>"},{"location":"images/session-05/#task-enhance-irsensor-with-magic-methods","title":"Task: Enhance IRSensor with Magic Methods","text":""},{"location":"images/session-05/#enhanced-irsensor-class-uml-structure","title":"Enhanced IRSensor Class UML Structure","text":"<pre><code>classDiagram\n    class IRSensor {\n        -str name\n        -int last_reading\n        +__init__(name: str) IRSensor\n        +__str__() str\n        +__repr__() str\n        +get_reading() int\n        +get_status() str\n    }\n\n    note for IRSensor \"Enhanced sensor with string representations\\nand reading history for better debugging\"</code></pre>"},{"location":"images/session-05/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<ol> <li> <p>Enhance your IRSensor class from Session 4 with these additions:</p> <ul> <li>Add a <code>last_reading</code> instance variable to store the most recent reading</li> <li>Implement <code>__str__()</code> for user-friendly display</li> <li>Implement <code>__repr__()</code> for debugging</li> <li>Add a <code>get_status()</code> method that returns detailed sensor information</li> <li> <p>Requirements for string methods:</p> </li> <li> <p><code>__str__()</code>: Should show sensor name and last reading in a friendly format</p> </li> <li><code>__repr__()</code>: Should show exact constructor call needed to recreate the sensor</li> <li>Handle the case when no reading has been taken yet</li> </ul> </li> </ol>"},{"location":"images/session-05/#complete-implementation-template","title":"Complete Implementation Template","text":"<pre><code>import random\n\nclass IRSensor:\n    \"\"\"Enhanced infrared distance sensor with string representations.\"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"\n        Initialize the IR sensor with a position name.\n\n        Args:\n            name (str): Position identifier for the sensor\n        \"\"\"\n        pass\n\n    def __str__(self):\n        \"\"\"\n        Return user-friendly string representation.\n\n        Returns:\n            str: Human-readable sensor status\n        \"\"\"\n        pass\n\n\n    def __repr__(self):\n        \"\"\"\n        Return developer-friendly string representation.\n\n        Returns:\n            str: Precise representation for debugging\n        \"\"\"\n        pass\n\n    def get_reading(self):\n        \"\"\"\n        Simulate getting a distance measurement from the IR sensor.\n\n        Returns:\n            int: Distance measurement in centimeters (1-100)\n        \"\"\"\n        pass\n\n    def get_status(self):\n        \"\"\"\n        Get detailed status information about the sensor.\n\n        Returns:\n            str: Detailed sensor status\n        \"\"\"\n        pass\n\"\n\nif __name__ == \"__main__\":\n    # Create sensor instances\n    sensors = [\n        IRSensor(\"Front Left\"),\n        IRSensor(\"Front Center\"),\n        IRSensor(\"Front Right\"),\n        IRSensor(\"Back Left\"),\n        IRSensor(\"Back Right\")\n    ]\n\n    print(\"\\n=== Initial Sensor Status ===\")\n    for sensor in sensors:\n        print(sensor)  # Uses __str__\n\n    print(\"\\n=== After Taking Readings ===\")\n    for sensor in sensors:\n        sensor.get_reading()\n\n    print(\"\\n=== Updated Sensor Display ===\")\n    for sensor in sensors:\n        print(sensor)  # Shows readings now\n\n    print(\"\\n=== Debugging View ===\")\n    print(\"Sensor list:\", sensors)  # Uses __repr__ for each sensor\n\n    print(\"\\n=== Detailed Status ===\")\n    for sensor in sensors:\n        print(sensor.get_status())\n</code></pre> <p>Expected Output (values will change for yours):</p> <pre><code>IR Sensor 'Front Left' initialized\nIR Sensor 'Front Center' initialized\nIR Sensor 'Front Right' initialized\nIR Sensor 'Back Left' initialized\nIR Sensor 'Back Right' initialized\n\n=== Initial Sensor Status ===\nFront Left Sensor: No readings taken\nFront Center Sensor: No readings taken\nFront Right Sensor: No readings taken\nBack Left Sensor: No readings taken\nBack Right Sensor: No readings taken\n\n=== After Taking Readings ===\nFront Left sensor reading: 42 cm\nFront Center sensor reading: 78 cm\nFront Right sensor reading: 15 cm\nBack Left sensor reading: 91 cm\nBack Right sensor reading: 33 cm\n\n=== Updated Sensor Display ===\nFront Left Sensor: 42 cm\nFront Center Sensor: 78 cm\nFront Right Sensor: 15 cm\nBack Left Sensor: 91 cm\nBack Right Sensor: 33 cm\n\n=== Debugging View ===\nSensor list: [IRSensor(name='Front Left'), IRSensor(name='Front Center'), IRSensor(name='Front Right'), IRSensor(name='Back Left'), IRSensor(name='Back Right')]\n\n=== Detailed Status ===\nSensor 'Front Left': Active (last reading: 42 cm)\nSensor 'Front Center': Active (last reading: 78 cm)\nSensor 'Front Right': Active (last reading: 15 cm)\nSensor 'Back Left': Active (last reading: 91 cm)\nSensor 'Back Right': Active (last reading: 33 cm)\n</code></pre> <p>!!! tip \"Best Practice Tip\" Notice how <code>__str__</code> provides information useful to robot operators, while <code>__repr__</code> shows exactly how to recreate the object. This distinction helps both users and developers.</p>"},{"location":"images/session-05/#3-data-encapsulation-controlling-access-to-object-data","title":"3. Data Encapsulation: Controlling Access to Object Data","text":"<p>Data encapsulation is about controlling how external code accesses and modifies object data. In robotics, this prevents dangerous operations like setting invalid motor speeds or battery levels.</p>"},{"location":"images/session-05/#the-problem-with-direct-attribute-access","title":"The Problem with Direct Attribute Access","text":"<pre><code># Direct access can lead to problems\nrobot = EPuckRobot(\"Alpha_7\", 98.5)\nrobot.battery_percentage = 150.0  # Invalid! Batteries can't exceed 100%\nrobot.current_speed = -0.5        # Invalid! Negative speed doesn't make sense\n</code></pre>"},{"location":"images/session-05/#traditional-getter-and-setter-methods","title":"Traditional Getter and Setter Methods","text":"<p>Before we learn the elegant decorator approach, let's understand the traditional method:</p>"},{"location":"images/session-05/#battery-management-class-uml-structure","title":"Battery Management Class UML Structure","text":"<pre><code>classDiagram\n    class BatteryManager {\n        -float _battery_level\n        +__init__(initial_level: float) BatteryManager\n        +get_battery_level() float\n        +set_battery_level(level: float) void\n        +is_battery_low() bool\n        +__str__() str\n        +__repr__() str\n    }\n\n    note for BatteryManager \"Encapsulates battery data with\\nvalidation and controlled access\"</code></pre> <pre><code>class BatteryManager:\n    \"\"\"Manages robot battery with controlled access.\"\"\"\n\n    def __init__(self, initial_level: float):\n        \"\"\"Initialize battery manager with validation.\"\"\"\n        self._battery_level = 0.0  # Private attribute (by convention)\n        self.set_battery_level(initial_level)  # Use setter for validation\n\n    def get_battery_level(self):\n        \"\"\"\n        Get current battery level.\n\n        Returns:\n            float: Battery level as percentage (0.0-100.0)\n        \"\"\"\n        return self._battery_level\n\n    def set_battery_level(self, level: float):\n        \"\"\"\n        Set battery level with validation.\n\n        Args:\n            level (float): Battery level percentage\n\n        Raises:\n            ValueError: If level is outside valid range\n        \"\"\"\n        if not isinstance(level, (int, float)):\n            raise TypeError(\"Battery level must be a number\")\n\n        if level &lt; 0.0:\n            raise ValueError(\"Battery level cannot be negative\")\n\n        if level &gt; 100.0:\n            raise ValueError(\"Battery level cannot exceed 100%\")\n\n        self._battery_level = float(level)\n        print(f\"Battery level set to {self._battery_level}%\")\n\n    def is_battery_low(self):\n        \"\"\"\n        Check if battery is low.\n\n        Returns:\n            bool: True if battery is below 20%\n        \"\"\"\n        return self._battery_level &lt; 20.0\n\n    def __str__(self):\n        \"\"\"User-friendly battery status.\"\"\"\n        status = \"LOW\" if self.is_battery_low() else \"OK\"\n        return f\"Battery: {self._battery_level}% ({status})\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return f\"BatteryManager(initial_level={self._battery_level})\"\n\n# Usage example\nif __name__ == \"__main__\":\n    # Create battery manager\n    battery = BatteryManager(85.0)\n    print(battery)\n\n    # Safe access through getters/setters\n    print(f\"Current level: {battery.get_battery_level()}%\")\n\n    # Validation prevents invalid values\n    try:\n        battery.set_battery_level(150.0)  # Will raise ValueError\n    except ValueError as e:\n        print(f\"Error: {e}\")\n\n    # Check battery status\n    battery.set_battery_level(15.0)\n    print(battery)\n    print(f\"Battery low: {battery.is_battery_low()}\")\n</code></pre>"},{"location":"images/session-05/#4-function-wrapping-understanding-decorator-foundations","title":"4. Function Wrapping: Understanding Decorator Foundations","text":"<p>Before learning the <code>@property</code> decorator, let's understand how function wrapping works. This concept is fundamental to understanding decorators.</p>"},{"location":"images/session-05/#basic-function-wrapping-example","title":"Basic Function Wrapping Example","text":"<pre><code>def validate_positive(func):\n    \"\"\"Wrapper that validates function arguments are positive.\"\"\"\n    def wrapper(value):\n        print(f\"Validating that {value} is positive...\")\n        if value &lt; 0:\n            raise ValueError(\"Value must be positive\")\n        result = func(value)\n        print(f\"Validation passed, result: {result}\")\n        return result\n    return wrapper\n\ndef calculate_square_root(number):\n    \"\"\"Calculate square root of a number.\"\"\"\n    return number ** 0.5\n\n# Wrap the function manually\nsafe_square_root = validate_positive(calculate_square_root)\n\n# Test the wrapped function\ntry:\n    result = safe_square_root(16.0)  # Works fine\n    print(f\"\u221a16 = {result}\")\n\n    result = safe_square_root(-4.0)  # Raises error\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"images/session-05/#how-this-relates-to-properties","title":"How This Relates to Properties","text":"<p>The <code>@property</code> decorator works similarly - it wraps your method to make it behave like an attribute. Understanding this concept helps you grasp how decorators work \"under the hood.\"</p>"},{"location":"images/session-05/#5-property-decorators-the-pythonic-way","title":"5. Property Decorators: The Pythonic Way","text":"<p>Now that you understand function wrapping, let's see how the <code>@property</code> decorator provides a cleaner approach to getters and setters.</p>"},{"location":"images/session-05/#enhanced-motor-controller-class-uml-structure","title":"Enhanced Motor Controller Class UML Structure","text":"<pre><code>classDiagram\n    class MotorController {\n        -float _speed\n        -float _max_speed\n        -bool _is_running\n        +__init__(max_speed: float) MotorController\n        +speed: float\n        +max_speed: float\n        +is_running: bool\n        +start() void\n        +stop() void\n        +__str__() str\n        +__repr__() str\n    }\n\n    note for MotorController \"Uses property decorators for clean,\\nvalidated attribute access\"</code></pre> <pre><code>class MotorController:\n    \"\"\"Motor controller with property-based encapsulation.\"\"\"\n\n    def __init__(self, max_speed: float = 1.0):\n        \"\"\"\n        Initialize motor controller.\n\n        Args:\n            max_speed (float): Maximum allowed speed (0.0-1.0)\n        \"\"\"\n        self._speed = 0.0\n        self._max_speed = max_speed\n        self._is_running = False\n        print(f\"Motor controller initialized (max speed: {max_speed})\")\n\n    @property\n    def speed(self):\n        \"\"\"\n        Get current motor speed.\n\n        Returns:\n            float: Current speed (0.0-1.0)\n        \"\"\"\n        return self._speed\n\n    @speed.setter\n    def speed(self, value):\n        \"\"\"\n        Set motor speed with validation.\n\n        Args:\n            value (float): Desired speed (0.0-max_speed)\n\n        Raises:\n            ValueError: If speed is outside valid range\n            TypeError: If speed is not a number\n        \"\"\"\n        if not isinstance(value, (int, float)):\n            raise TypeError(\"Speed must be a number\")\n\n        if value &lt; 0.0:\n            raise ValueError(\"Speed cannot be negative\")\n\n        if value &gt; self._max_speed:\n            raise ValueError(f\"Speed cannot exceed {self._max_speed}\")\n\n        self._speed = float(value)\n        self._is_running = (self._speed &gt; 0.0)\n        print(f\"Motor speed set to {self._speed}\")\n\n    @property\n    def max_speed(self):\n        \"\"\"Get maximum allowed speed.\"\"\"\n        return self._max_speed\n\n    @property\n    def is_running(self):\n        \"\"\"Check if motor is currently running.\"\"\"\n        return self._is_running\n\n    def start(self):\n        \"\"\"Start motor at current speed setting.\"\"\"\n        if self._speed &gt; 0.0:\n            self._is_running = True\n            print(f\"Motor started at speed {self._speed}\")\n        else:\n            print(\"Cannot start motor: speed is 0.0\")\n\n    def stop(self):\n        \"\"\"Stop motor (sets speed to 0).\"\"\"\n        self._speed = 0.0\n        self._is_running = False\n        print(\"Motor stopped\")\n\n    def __str__(self):\n        \"\"\"User-friendly motor status.\"\"\"\n        status = \"RUNNING\" if self._is_running else \"STOPPED\"\n        return f\"Motor: {status} at {self._speed}/{self._max_speed} speed\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return f\"MotorController(max_speed={self._max_speed})\"\n\n# Usage demonstrating property access\nif __name__ == \"__main__\":\n    # Create motor controller\n    motor = MotorController(0.8)  # Max speed of 0.8\n    print(motor)\n\n    # Property access looks like normal attribute access\n    print(f\"Current speed: {motor.speed}\")\n    print(f\"Max speed: {motor.max_speed}\")\n    print(f\"Is running: {motor.is_running}\")\n\n    # Set speed using property (calls the setter)\n    motor.speed = 0.5\n    print(motor)\n\n    # Try invalid values\n    try:\n        motor.speed = 1.2  # Exceeds max_speed\n    except ValueError as e:\n        print(f\"Error: {e}\")\n\n    try:\n        motor.speed = \"fast\"  # Wrong type\n    except TypeError as e:\n        print(f\"Error: {e}\")\n\n    # Properties are read-only where no setter is defined\n    try:\n        motor.max_speed = 1.0  # This will raise AttributeError\n    except AttributeError as e:\n        print(f\"Error: can't set max_speed - {e}\")\n</code></pre>"},{"location":"images/session-05/#comparing-approaches","title":"Comparing Approaches","text":"Aspect Traditional Getters/Setters Property Decorators Syntax <code>robot.get_speed()</code> / <code>robot.set_speed(0.5)</code> <code>robot.speed</code> / <code>robot.speed = 0.5</code> Readability More verbose Clean, attribute-like access Validation \u2705 Full control \u2705 Full control Pythonic Less Pythonic \u2705 Highly Pythonic Learning Curve Easier to understand initially Requires understanding decorators <p>!!! tip \"When to Use Each Approach\" - Traditional getters/setters: When you need complex validation logic or multiple parameters - Property decorators: For simple attribute access with validation (recommended for most cases)</p>"},{"location":"images/session-05/#check-your-knowledge","title":"Check Your Knowledge","text":"<p>Test your understanding of the advanced OOP concepts covered in this session:</p> <p>Question 1: <code>__str__</code> vs <code>__repr__</code> Purpose</p> <p>Question: You have a <code>RobotSensor</code> object. When would Python call <code>__str__()</code> vs <code>__repr__()</code>? Give specific examples.</p> Click to reveal answer <p>Answer: : </p> <p><code>__str__()</code> is called when: - You use <code>print(sensor)</code> - You use <code>str(sensor)</code>  - String formatting like <code>f\"Sensor data: {sensor}\"</code></p> <p><code>__repr__()</code> is called when: - You use <code>repr(sensor)</code> - The object appears in a list: <code>print([sensor1, sensor2])</code> - In the debugger or interactive shell when you just type the variable name - When <code>__str__()</code> is not defined, Python falls back to <code>__repr__()</code></p> <p>Question 2: Property Decorator Syntax</p> <p>Question: Look at this code. What's wrong with it?</p> <pre><code>class Robot:\n    def __init__(self):\n        self._speed = 0.0\n\n    @property\n    def speed(self, value):\n        self._speed = value\n</code></pre> Click to reveal answer <p>Answer: </p> <p>The <code>@property</code> decorator is used incorrectly. The method decorated with <code>@property</code> should be the getter (no parameters except <code>self</code>). To set values, you need a separate setter:</p> <pre><code>class Robot:\n    def __init__(self):\n        self._speed = 0.0\n\n    @property\n    def speed(self):  # Getter - no value parameter\n        return self._speed\n\n    @speed.setter\n    def speed(self, value):  # Setter - has value parameter\n        self._speed = value\n</code></pre> <p>````</p> Question 3: When to Use Properties <p>Question: Your robot has a <code>battery_level</code> that should never go below 0 or above 100. Should you use a property or just a regular attribute? Why?</p> Click to reveal answer <p>Answer: </p> <p>Use a property because you need validation. Here's why:</p> <ul> <li>Validation needed: Battery levels have strict limits (0-100%)</li> <li>Safety critical: Invalid battery levels could cause unsafe robot behavior</li> <li>Clean syntax: <code>robot.battery_level = 85</code> is cleaner than <code>robot.set_battery_level(85)</code></li> </ul> <p>Example implementation: </p><pre><code>@property\ndef battery_level(self):\n    return self._battery_level\n\n@battery_level.setter\ndef battery_level(self, value):\n    if not 0 &lt;= value &lt;= 100:\n        raise ValueError(\"Battery level must be 0-100%\")\n    self._battery_level = value\n</code></pre> Question 4: Understanding <code>self</code> in Magic Methods <p>Question: In <code>def __str__(self):</code>, what does <code>self</code> refer to, and why don't you need to pass it when calling <code>print(robot)</code>?</p> Click to reveal answer <p>Answer: </p> <ul> <li><code>self</code> refers to: The specific robot object that <code>__str__()</code> is being called on</li> <li>Why you don't pass it: Python automatically passes <code>self</code> when you call methods on objects</li> </ul> <p>When you write <code>print(robot)</code>: 1. Python internally calls <code>robot.__str__()</code> 2. Python automatically passes the <code>robot</code> object as the <code>self</code> parameter 3. Your <code>__str__</code> method can then access <code>self.robot_id</code>, <code>self.battery_percentage</code>, etc.</p> <p>This is the same reason you don't write <code>robot.move_forward(robot, 0.5)</code> - Python handles the <code>self</code> parameter automatically.</p> Question 5: Property vs Method Decision <p>Question: For each of these robot operations, should it be a property or a method? Explain your reasoning.</p> <ul> <li><code>robot.current_speed</code> (just getting the speed)</li> <li><code>robot.turn_left()</code> (making the robot turn)  </li> <li><code>robot.battery_percentage</code> (getting/setting battery level)</li> <li><code>robot.emergency_stop()</code> (immediate stop command)</li> </ul> Click to reveal answer <p>Answer: </p> <ul> <li><code>robot.current_speed</code> \u2192 Property: Getting data, no action performed, feels like an attribute</li> <li><code>robot.turn_left()</code> \u2192 Method: Performs an action, changes robot state, side effects</li> <li><code>robot.battery_percentage</code> \u2192 Property: Data that might need validation, attribute-like access</li> <li><code>robot.emergency_stop()</code> \u2192 Method: Critical action, clear that something important happens</li> </ul> <p>Rule of thumb:  - Properties: For data access (getting/setting values) that feels like attribute access - Methods: For actions, operations, or anything that \"does something\" to the object</p>"},{"location":"images/session-05/#lab-2-line-follower-robot-implementation","title":"Lab 2: Line-follower Robot Implementation","text":"<p>In this lab, you will implement a line-following robot using object-oriented programming principles in the Webots simulator. This lab builds on the OOP concepts learned in Sessions 4 and 5, applying them to a real robotics problem.</p> <p>Lab Credits</p> <p>This lab is adapted from the excellent work by Felipe Martins:</p> <p>Original Repository: Robotics-Simulation-Labs Author: Felipe Nascimento Martins License: Available on GitHub</p> <p>We acknowledge and appreciate the open-source contribution to robotics education.</p>"},{"location":"images/session-05/#about-line-following","title":"About Line Following","text":"<p>Line following is a fundamental robotics task where a robot uses sensors to detect and follow a path marked on the ground. This requires:</p> <ul> <li>Sensor data processing: Reading and interpreting sensor values</li> <li>Decision making: Determining robot actions based on sensor data</li> <li>Motor control: Translating decisions into wheel movements</li> <li>Real-time operation: Continuously processing sensor data and adjusting behavior</li> </ul>"},{"location":"images/session-05/#lab-setup","title":"Lab Setup","text":"<p>Before starting the implementation, ensure you have:</p> <ol> <li>Webots simulator installed and working (from Session 4)</li> <li>Python 3.9+ configured with Webots</li> <li>Basic understanding of OOP concepts from Sessions 4 and 5</li> </ol>"},{"location":"images/session-05/#first-do-the-lab","title":"First - do the Lab !","text":"<p>Lab 2 - Line-Following https://felipenmartins.github.io/Robotics-Simulation-Labs/Lab2/ </p>"},{"location":"images/session-05/#lab-2-line-follower-with-state-machine","title":"Lab 2 \u2013 Line-follower with State Machine","text":""},{"location":"images/session-05/#objectives","title":"Objectives","text":"<p>The goal of this lab is to learn more about controllers in Webots via the implementation of state machine to make the robot follow a line. </p>"},{"location":"images/session-05/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>You must have Webots R2022a (or newer) properly configured to work with Python. </li> <li>You must know how to create a robot controller in Python and how to run a simulation. </li> </ul> <p>If you are still missing any of those, please go back to Lab 1 and complete the corresponding tasks.</p>"},{"location":"images/session-05/#the-e-puck-robot","title":"The e-puck robot","text":"<p>Webots contains a realistic model of e-puck, a small differential-drive mobile robot. The movement of this type of robot is controlled by independently adjusting the speeds of the left and right wheels. </p> <p>The e-puck robot has multiple sensors. To detect obstacles, the e-puck contains 8 infrared distance sensors around its body. Optionally, 3 infrared sensors can be mounted under its base, pointing to the floor, allowing the implementation of a line-following behavior. </p> <p>An explanation about the e-puck robot and how to use it in Webots is available in Webots Tutorial 4.</p>"},{"location":"images/session-05/#tasks","title":"Tasks","text":"<p>1- Follow Webots Tutorial 4 to better understand the e-puck model and learn how to control it in Python.</p> <p>2- After finishing tutorial 4, open the line-following sample world: Click on <code>File &gt; Open Sample Worlds</code> and go to <code>robots &gt; gctronic &gt; e-puck</code> and select <code>e-puck_botstudio_with_floor_sensors.wbt</code>. You should see a world similar to the one shown in Figure 1. In the next steps you must use the e-puck robot that is loaded with this sample world because it has the floor sensors to detect the line. </p> <p></p>"},{"location":"images/session-05/#figure-1-webots-screenshot-with-the-world-e-puck_botstudio_with_floor_sensorswbt","title":"Figure 1. Webots screenshot with the world \u201ce-puck_botstudio_with_floor_sensors.wbt\u201d.","text":"<p>3- You will need to make changes to the file, so you have to save the sample world with a different name on a folder of your choice. </p> <p>4- Write a simple program to investigate the values returned by the floor sensors when the robot is over the white floor and over the black line. You can use the print function to show the sensor values in the Webots console. More information about how to read the ground sensors is given below.</p> <p>5- Test the motor speeds to determine how fast the robot should run and turn in order to follow the line.</p> <p>6- Create a new controller in Python and implement a line-following behavior using what you learned from the steps above. You can use the state machine shown in Figure 2 as reference. </p> <p>7- Finally, add one extra state to stop the robot when no line is detected.</p> <p></p>"},{"location":"images/session-05/#figure-2-a-state-machine-diagram-that-implements-a-line-follower-behavior","title":"Figure 2. A state machine diagram that implements a line-follower behavior.","text":""},{"location":"images/session-05/#ground-sensors","title":"Ground sensors","text":"<p>In Tutorial 4 you made use of the distance sensors around the robot. To detect the line on the floor you need to use the ground sensors, instead. The simulator also treats the ground sensors as distance sensors because they are of the same type (infrared sensors). In Python you can access the ground sensors as shown below.</p> <p>To initialize the ground sensors: </p><pre><code>gs = []\ngsNames = ['gs0', 'gs1', 'gs2']\nfor i in range(3):\n    gs.append(robot.getDevice(gsNames[i]))\n    gs[i].enable(timestep)\n</code></pre> <p>To read the ground sensors inside the main loop: </p><pre><code>gsValues = []\nfor i in range(3):\n    gsValues.append(gs[i].getValue())\n</code></pre> <p>To read sensor values inside the main loop: </p><pre><code>line_right = gsValues[0]\nline_center = gsValues[1]\nline_left = gsValues[2]\n</code></pre> <p>If you need inspiration, check the template code available here!</p>"},{"location":"images/session-05/#solution","title":"Solution","text":"<p>Try to implement the state machine yourself before checking the solution! A possible solution (without the stop state) is available here.</p> <p>The video below shows the solution code in action:</p> <p>.</p>"},{"location":"images/session-05/#challenge-obstacle-avoidance","title":"Challenge: Obstacle Avoidance","text":"<p>Change the state machine to make e-puck avoid obstacles placed on its way. You can choose the type of obstacle to add: different formats might require different strategies of obstacle avoidance. Obstacles with round or rectangular shape usually are the less demanding, while obstacles with U-shape require more complex strategies.</p> <p>An illustration of obstacle avoidance with state machine is given in Figure 3. Note that the obstacle avoidance strategy that was implemented required four extra states, some executing the same action as others. The animation in Figure 3 shows the active state (in red) for each condition during the simulation.</p> <p></p>"},{"location":"images/session-05/#figure-3-illustration-of-obstacle-avoidance-strategy-added-to-the-existing-line-follower-state-machine","title":"Figure 3. Illustration of obstacle avoidance strategy added to the existing line-follower state machine.","text":"<p>Student Wilfred van Reenen made the video below to illustrate the excellent performance of his obstacle avoidance state machine. If you want to go above and beyond, try to get your robot to avoid all those obstacles!</p> <p>.</p>"},{"location":"images/session-05/#conclusion","title":"Conclusion","text":"<p>After following this lab you should know more about the e-puck robot model, how to program a controller for it in Python, and how to program a robot behavior based on state machine. </p>"},{"location":"images/session-05/#next-lab","title":"Next Lab","text":"<p>Go to Lab 3 - Odometry-based Localization</p> <p>Back to main page.</p>"},{"location":"images/session-05/#line-following-robot-architecture","title":"Line-Following Robot Architecture","text":"<p>Our robot will use an object-oriented architecture with these main components:</p>"},{"location":"images/session-05/#testing-your-implementation","title":"Testing Your Implementation","text":"<ol> <li>Load the line following world in Webots</li> <li>Replace the default controller with your <code>line_follower_robot.py</code></li> <li>Run the simulation and observe the robot behavior</li> <li>Monitor the console output to see sensor readings and motor commands</li> </ol>"},{"location":"images/session-05/#expected-behavior","title":"Expected Behavior","text":"<p>Your robot should:</p> <ul> <li>Follow the line smoothly using sensor feedback</li> <li>Stop when obstacles are detected</li> <li>Display clear debugging information using the magic methods</li> <li>Handle edge cases like losing the line temporarily</li> </ul>"},{"location":"images/session-05/#debugging-tips","title":"Debugging Tips","text":"<p>Common Issues and Solutions</p> <pre><code>**Robot doesn't move**: Check that motors are properly initialized and `timestep` is correct\n\n**Erratic behavior**: Adjust the `base_speed` and `turn_speed` parameters\n\n**Line not detected**: Verify the sensor threshold values for your specific world\n\n**Console spam**: The debug output is limited to ~1 second intervals to keep it readable\n</code></pre>"},{"location":"images/session-05/#extension-challenges","title":"Extension Challenges","text":"<p>Once you have the basic implementation working, try these enhancements:</p> <ol> <li>Add speed control: Make the robot slow down in tight turns</li> <li>Implement PID control: Use proportional, integral, and derivative control for smoother following</li> <li>Add line-lost recovery: Handle situations where the robot completely loses the line</li> <li>Implement different following modes: Allow switching between fast/slow/precise modes</li> </ol>"},{"location":"images/session-05/#session-summary-advanced-oop-features-in-robotics","title":"Session Summary: Advanced OOP Features in Robotics","text":"<p>In this session, you've learned how to make your robotics code more professional and maintainable through advanced OOP features:</p>"},{"location":"images/session-05/#key-concepts-mastered","title":"Key Concepts Mastered","text":"<pre><code>mindmap\n  root((Advanced OOP Features))\n    Magic Methods\n      __str__ for users\n      __repr__ for developers\n      Better debugging\n    Data Encapsulation\n      Traditional getters/setters\n      Property decorators\n      Data validation\n    Function Wrapping\n      Decorator foundations\n      Understanding @property\n      Code organization\n    Practical Application\n      Line following robot\n      Sensor fusion\n      Object-oriented architecture</code></pre>"},{"location":"images/session-05/#design-patterns-used","title":"Design Patterns Used","text":"<p>Throughout this session, we've implemented several important design patterns:</p> <ul> <li>Encapsulation: Hiding internal data and providing controlled access</li> <li>Composition: Building complex objects from simpler components</li> <li>Single Responsibility: Each class has one clear purpose</li> <li>Property Pattern: Clean attribute-like access with validation</li> </ul> <p>!!! success \"Professional Development\" The techniques learned in this session are used in production robotics software. You're now writing code that follows industry best practices!</p>"},{"location":"images/session-05/#out-of-class-research-activities","title":"Out-of-Class Research Activities","text":"<p>To reinforce your understanding and prepare for advanced topics:</p>"},{"location":"images/session-05/#research-topics","title":"Research Topics","text":"<ol> <li> <p>Python Magic Methods Deep Dive</p> <ul> <li>Research other useful magic methods (<code>__eq__</code>, <code>__lt__</code>, <code>__len__</code>)</li> <li>Find examples of magic methods in robotics frameworks</li> <li>Study how magic methods enable operator overloading</li> <li> <p>Property Decorators Advanced Usage</p> </li> <li> <p>Investigate read-only properties and computed properties</p> </li> <li>Research property caching for expensive calculations</li> <li>Look into property validation patterns</li> <li> <p>Robotics Control Systems</p> </li> <li> <p>Study PID controllers and their implementation in OOP</p> </li> <li>Research state machines for robot behavior</li> <li>Investigate sensor fusion algorithms and OOP design</li> <li> <p>Code Quality and Testing</p> </li> <li> <p>Research unit testing for robotics code</p> </li> <li>Study debugging techniques for real-time systems</li> <li>Investigate logging best practices for robotics applications</li> </ul> </li> </ol> <p>!!! tip \"Recommended Resources\" - Python official documentation on data model - Real Python articles on properties and magic methods - Open-source robotics projects showing OOP patterns - ROS (Robot Operating System) architectural documentation</p>"},{"location":"images/session-05/#next-session-preview","title":"Next Session Preview","text":"<p>Week 6: Inheritance &amp; Polymorphism</p> <ul> <li>Creating class hierarchies for different robot types</li> <li>Method overriding and super() usage</li> <li>Abstract base classes for robotics interfaces</li> <li>Polymorphic behavior in sensor and actuator systems</li> <li>Advanced UML diagrams and design patterns</li> </ul>"},{"location":"images/session-05/#resources","title":"Resources","text":""},{"location":"images/session-05/#downloads","title":"Downloads","text":"<ul> <li> Enhanced robot classes with magic methods</li> <li> Complete line follower implementation</li> <li> Property decorator examples</li> <li> Function wrapping tutorial</li> <li> All Week 5 resources</li> </ul>"},{"location":"images/session-05/#lab-files","title":"Lab Files","text":"<ul> <li> Line follower Webots world</li> <li> Robot controller template</li> </ul>"},{"location":"images/session-05/#further-reading","title":"Further Reading","text":"<ul> <li>Python Data Model Documentation</li> <li>Property Decorator Patterns</li> <li>Robotics Software Engineering Best Practices</li> <li>Object-Oriented Design Patterns in Robotics</li> </ul> <p>Navigation: \u2190 Week 4 | Learning Plan | Week 6 \u2192</p>"},{"location":"reference/glossary_page/","title":"Glossary","text":""},{"location":"reference/glossary_page/#glossary","title":"Glossary","text":"<p>A comprehensive reference for key terms and concepts used throughout the Robotics Programming Course.</p>"},{"location":"reference/glossary_page/#a","title":"A","text":"Abstract Base Class (ABC) A class that cannot be instantiated directly and is designed to be inherited by other classes. Contains one or more abstract methods that must be implemented by concrete subclasses. Algorithm A step-by-step procedure for solving a problem or completing a task, often implemented as a function or method in programming. API (Application Programming Interface) A set of protocols, routines, and tools for building software applications. Defines how software components should interact. Argument A value passed to a function or method when it is called. Arguments provide input data for the function to process."},{"location":"reference/glossary_page/#b","title":"B","text":"Binary Search An efficient algorithm for finding an item in a sorted list by repeatedly dividing the search interval in half. Bug An error or flaw in a computer program that causes it to produce incorrect or unexpected results."},{"location":"reference/glossary_page/#c","title":"C","text":"Class A blueprint or template for creating objects in object-oriented programming. Defines attributes and methods that the objects will have. Class Method A method that belongs to the class rather than any particular instance. Defined using the <code>@classmethod</code> decorator in Python. Component A modular, reusable piece of software that encapsulates functionality and can be integrated into larger systems. Constructor A special method called when an object is instantiated. In Python, this is the <code>__init__()</code> method that initializes the object's state. Control System A system that manages and regulates the behavior of other systems using control loops and feedback mechanisms."},{"location":"reference/glossary_page/#d","title":"D","text":"Debugging The process of finding and fixing bugs or errors in computer programs. Dependency A relationship where one piece of software relies on another to function properly. Docstring A string literal that appears as the first statement in a Python module, function, class, or method definition, used for documentation. Duck Typing A programming concept where the type or class of an object is less important than the methods it implements."},{"location":"reference/glossary_page/#e","title":"E","text":"Encapsulation An OOP principle that bundles data and methods that operate on that data within a single unit (class), hiding internal implementation details. E-puck Robot A small differential wheeled mobile robot developed for education and research, commonly used in robotics courses. Exception An error that occurs during program execution, which can be handled using try-catch blocks to prevent program crashes. Exercism An online platform providing coding practice exercises with mentorship, used for skill development in various programming languages."},{"location":"reference/glossary_page/#f","title":"F","text":"Felipe Martins Labs A series of progressive robotics exercises focusing on robot navigation, sensor processing, and autonomous behavior implementation. Function A reusable block of code that performs a specific task, takes inputs (parameters), and may return a value."},{"location":"reference/glossary_page/#g","title":"G","text":"Git A distributed version control system used for tracking changes in source code during software development. GUI (Graphical User Interface) A visual interface that allows users to interact with software through graphical elements like buttons, menus, and windows."},{"location":"reference/glossary_page/#i","title":"I","text":"IDE (Integrated Development Environment) A software application providing comprehensive facilities for software development, typically including a code editor, debugger, and build automation tools. Inheritance An OOP principle allowing a class to inherit attributes and methods from another class, promoting code reuse and establishing hierarchical relationships. Instance A concrete occurrence of a class; an object created from a class blueprint with its own unique state. Instance Method A method that operates on an instance of a class and has access to the instance's attributes through the <code>self</code> parameter. Instance Variable A variable that belongs to a specific instance of a class, holding data unique to that object. Integration Testing Testing performed to verify that different modules or components work correctly when combined."},{"location":"reference/glossary_page/#l","title":"L","text":"Library A collection of pre-written code and functions that can be imported and used in programs to provide specific functionality. Line Following A robotic behavior where a robot follows a predetermined path marked by a line on the ground using sensors."},{"location":"reference/glossary_page/#m","title":"M","text":"Magic Method (Dunder Method) Special methods in Python that start and end with double underscores (e.g., <code>__init__</code>, <code>__str__</code>), providing customizable behavior for built-in operations. Method A function defined within a class that can access and manipulate the object's attributes. Method Resolution Order (MRO) The order in which Python searches for methods in a class hierarchy, important for inheritance and method overriding. MkDocs A static site generator designed for creating project documentation from Markdown files. Modularity The design principle of breaking down complex systems into smaller, independent, and interchangeable components."},{"location":"reference/glossary_page/#o","title":"O","text":"Object An instance of a class that contains data (attributes) and code (methods) that operate on that data. Object-Oriented Programming (OOP) A programming paradigm based on the concept of objects, emphasizing encapsulation, inheritance, and polymorphism. Odometry A method of estimating position and orientation of a robot based on data from motion sensors. Operator Overloading The ability to define custom behavior for built-in operators (like +, -, ==) when used with user-defined classes."},{"location":"reference/glossary_page/#p","title":"P","text":"Package A collection of related modules organized in a directory structure, providing a way to organize and distribute code. Parameter A variable listed in a function definition that accepts values passed as arguments when the function is called. PID Controller A control loop mechanism that uses Proportional, Integral, and Derivative terms to minimize error in system control. Polymorphism An OOP principle allowing objects of different classes to be treated as instances of the same type through a common interface. Portfolio Assessment An evaluation method where students compile a collection of work demonstrating their learning and competency development. Property A Python feature that allows methods to be accessed like attributes, often used with getter and setter methods. pytest A testing framework for Python that makes it easy to write simple and scalable test cases. Python A high-level, interpreted programming language known for its simplicity and readability, widely used in robotics and education."},{"location":"reference/glossary_page/#r","title":"R","text":"Refactoring The process of restructuring existing code without changing its external behavior to improve readability, maintainability, or performance. Repository A storage location for software packages or source code, often managed by version control systems like Git. Robotics The interdisciplinary field combining mechanical engineering, electrical engineering, and computer science to design and operate robots. ROS (Robot Operating System) An open-source framework providing tools, libraries, and conventions for developing robot software."},{"location":"reference/glossary_page/#s","title":"S","text":"Sensor A device that detects and measures physical properties from the environment and converts them into signals for processing. Simulation The use of computer models to replicate real-world processes or systems for testing, training, or analysis purposes. Static Method A method that belongs to a class but doesn't access instance or class-specific data. Defined using the <code>@staticmethod</code> decorator in Python. Subclass A class that inherits from another class (superclass), extending or modifying its functionality. Superclass (Parent Class) A class from which other classes inherit attributes and methods."},{"location":"reference/glossary_page/#t","title":"T","text":"Test-Driven Development (TDD) A software development approach where tests are written before the actual code implementation. Test Suite A collection of test cases designed to verify that a software application behaves as expected. Type Hint Python syntax that allows developers to indicate the expected data types of function parameters and return values."},{"location":"reference/glossary_page/#u","title":"U","text":"Unit Testing Testing individual components or modules of software in isolation to ensure they work correctly. UML (Unified Modeling Language) A standardized modeling language used to visualize system design and architecture."},{"location":"reference/glossary_page/#v","title":"V","text":"Variable A named storage location in computer memory that holds data that can be modified during program execution. Version Control A system that records changes to files over time, allowing you to recall specific versions and collaborate with others. Virtual Environment An isolated Python environment that allows you to install packages without affecting the global Python installation."},{"location":"reference/glossary_page/#w","title":"W","text":"Webots A professional mobile robot simulation software package that provides a complete development environment for modeling, programming, and simulating mobile robots. Wheel Encoder A sensor that measures the rotation of robot wheels, used for odometry and motion control."},{"location":"reference/glossary_page/#additional-resources","title":"Additional Resources","text":"<p>Expanding Your Knowledge</p> <p>For more detailed explanations of programming concepts, consider these resources:</p> <ul> <li>Python Official Documentation: python.org</li> <li>Real Python Tutorials: In-depth Python programming guides</li> <li>ROS Documentation: ros.org</li> <li>Webots User Guide: Comprehensive simulation environment documentation</li> </ul> <p>Course-Specific Terms</p> <p>This glossary focuses on terms relevant to ICTPRG430 and ICTPRG439. Additional robotics and programming terminology may be encountered in advanced coursework.</p> <p>Last updated: August 2025 | Suggestions for additional terms? Contact your instructor.</p>"},{"location":"sessions/session-04/","title":"Week 4 - Object Model & Class Fundamentals","text":""},{"location":"sessions/session-04/#session-4-object-model-class-fundamentals","title":"Session 4: Object Model &amp; Class Fundamentals","text":"<p>Week: 4 Element: ICTPRG430 Element 2.1 Duration: 4 hours Phase: Object-Oriented Programming Theory</p>"},{"location":"sessions/session-04/#session-introduction","title":"Session Introduction","text":"<p>In this session you will explore the foundational concepts of Object-Oriented Programming (OOP) through practical robotics applications. You'll begin with understanding why OOP is essential for robotics development, then dive into hands-on implementation of classes and objects. The session includes a comprehensive theory component, followed by practical exercises where you'll create IR sensor classes, witness a live demonstration of LIDAR implementation across different programming paradigms (procedural, functional, and object-oriented), explore advanced filtering techniques, and conclude with setting up Webots for future simulation work.</p>"},{"location":"sessions/session-04/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this session, you will be able to:</p> <ul> <li>Understand fundamental OOP concepts: classes, objects, and object instantiation</li> <li>Implement states (using instance variables) and behaviors (using instance methods) for robot systems  </li> <li>Explain constructor design and instance variables</li> <li>Apply encapsulation principles in robotics contexts</li> <li>Create and use multiple sensor objects in a robotics context</li> <li>Compare procedural, functional, and object-oriented programming approaches</li> <li>Set up Webots robotics simulator for future labs</li> </ul>"},{"location":"sessions/session-04/#session-structure","title":"Session Structure","text":"<ol> <li>Theory Session - Object-Oriented Programming fundamentals</li> <li>Hands-on Exercise - Create IR Sensor classes</li> <li>Live Demonstration - LIDAR implementation in three programming paradigms</li> <li>Extension Activity - Advanced LIDAR data filtering techniques</li> <li>Lab Setup - Webots simulator installation and configuration</li> </ol>"},{"location":"sessions/session-04/#session-overview","title":"Session Overview","text":"<p>This session introduces the fundamental concepts of Object-Oriented Programming (OOP) through the lens of robotics applications. You'll learn why OOP is particularly valuable for robotics development and how to implement basic class structures.</p>"},{"location":"sessions/session-04/#pre-session-preparation","title":"Pre-Session Preparation","text":"<p>Required Reading</p> <p>Review the following materials before class:</p> <ul> <li>OOP programming fundamentals documentation</li> <li>Class design principles guide</li> <li>Download: Basic Robot Class Starter</li> </ul> <p>Setup Check</p> <p>Ensure your Python development environment is configured:</p> <ul> <li>Python 3.9+ installed and working</li> <li>VS Code with Python extension</li> <li>pytest framework installed</li> </ul>"},{"location":"sessions/session-04/#1-why-object-oriented-programming-for-robotics","title":"1. Why Object-Oriented Programming for Robotics?","text":"<p>Object-Oriented Programming was developed to manage the increasing complexity of large software systems. Robotics deals with highly intricate systems involving numerous sensors, actuators, and algorithms, making OOP an invaluable paradigm for developing robust and maintainable robot software.</p>"},{"location":"sessions/session-04/#key-advantages-for-robotics","title":"Key Advantages for Robotics","text":"EncapsulationModularityReusabilityFlexibility <p>Real-world Example: E-puck robot motors</p> <p>You don't need to know the internal wiring or low-level data formats to control motors. OOP's encapsulation hides complexity behind clear interfaces like <code>set_speed()</code> methods.</p> <pre><code># Clean interface - implementation details hidden\nmotor = RobotMotor(\"left_wheel\")\nmotor.set_speed(0.5)  # Simple, clear method call\n</code></pre> <p>Real-world Example: Robot subsystems</p> <p>Instead of monolithic code, your robot software becomes a collection of interacting components - motors, sensors, navigation modules.</p> <pre><code># Modular design\nnavigation = NavigationSystem()\nsensors = ProximitySensors()\nmotors = MotorController()\n</code></pre> <p>Real-world Example: Cross-platform compatibility</p> <p>Once you define a <code>Motor</code> class, it can be reused for every motor on your robot or even across different robot platforms.</p> <pre><code># Reusable across different robots\nleft_motor = Motor(\"left_wheel\")\nright_motor = Motor(\"right_wheel\")\narm_motor = Motor(\"gripper\")\n</code></pre> <p>Real-world Example: Sensor polymorphism</p> <p>Different sensor types can respond to the same interface, making your code adaptable to hardware changes.</p> <pre><code># All sensors respond to read_value()\nproximity_sensor.read_value()\nlight_sensor.read_value()\ntemperature_sensor.read_value()\n</code></pre>"},{"location":"sessions/session-04/#2-classes-and-objects-the-foundation","title":"2. Classes and Objects: The Foundation","text":""},{"location":"sessions/session-04/#understanding-the-relationship","title":"Understanding the Relationship","text":"<p>Key Concepts</p> <p>Class: A blueprint, template, or mold for creating objects</p> <ul> <li>Like architectural plans for a building</li> <li>Defines structure and capabilities</li> <li>Uses PascalCase naming (e.g., <code>RobotLED</code>, <code>EPuckMotor</code>)</li> </ul> <p>Object (Instance): Individual \"things\" created from a class</p> <ul> <li>Like actual buildings constructed from plans</li> <li>Has unique state and identity  </li> <li>Can have multiple objects from one class</li> </ul>"},{"location":"sessions/session-04/#practical-example-robot-led-system","title":"Practical Example: Robot LED System","text":""},{"location":"sessions/session-04/#robotled-class-uml-structure","title":"RobotLED Class UML Structure","text":"<pre><code>classDiagram\n    class RobotLED {\n        -str led_id\n        -bool is_on\n        +__init__(led_id: str) RobotLED\n        +turn_on() void\n        +turn_off() void\n    }\n\n    note for RobotLED \"Encapsulates LED state and provides\\ncontrol methods for individual LEDs\"</code></pre> <p>Let's compare procedural vs object-oriented approaches:</p> Procedural ApproachObject-Oriented Approach <pre><code># Global variable - problematic for multiple LEDs\ne_puck_led_is_on = False\n\ndef turn_led_on():\n    global e_puck_led_is_on\n    e_puck_led_is_on = True\n    print(f\"LED is now ON: {e_puck_led_is_on}\")\n\ndef turn_led_off():\n    global e_puck_led_is_on\n    e_puck_led_is_on = False\n    print(f\"LED is now OFF: {e_puck_led_is_on}\")\n</code></pre> <p>Problems: - Global variables create management issues - Difficult to handle multiple LEDs - Data and functions are disconnected - Limited reusability</p> <pre><code>class RobotLED:\n    \"\"\"Blueprint for robot LED objects.\"\"\"\n\n    def __init__(self, led_id: str):\n        \"\"\"Initialize LED with unique identifier.\"\"\"\n        self.led_id = led_id\n        self.is_on = False\n        print(f\"LED '{self.led_id}' initialized (OFF)\")\n\n    def turn_on(self):\n        \"\"\"Turn the LED on.\"\"\"\n        self.is_on = True\n        print(f\"LED '{self.led_id}' is now ON\")\n\n    def turn_off(self):\n        \"\"\"Turn the LED off.\"\"\"\n        self.is_on = False\n        print(f\"LED '{self.led_id}' is now OFF\")\n\n# Usage - multiple independent LEDs\nfront_led = RobotLED(\"front\")\nback_led = RobotLED(\"back\")\n\nfront_led.turn_on()   # Only affects front LED\nback_led.turn_off()   # Independent control\n</code></pre>"},{"location":"sessions/session-04/#3-object-instantiation-process","title":"3. Object Instantiation Process","text":"<p>Instantiation creates new objects from a class blueprint. Understanding this process is crucial for effective OOP.</p>"},{"location":"sessions/session-04/#the-two-step-process","title":"The Two-Step Process","text":"<pre><code># When you write this:\nrobot = EPuckRobot(\"Alpha_7\", 98.5)\n\n# Python internally does:\n# 1. __new__() - Allocates memory for the object\n# 2. __init__() - Initializes the object's state\n</code></pre>"},{"location":"sessions/session-04/#behind-the-scenes","title":"Behind the Scenes","text":"<ol> <li>Memory Allocation (<code>__new__</code>): Python allocates memory space for the new object</li> <li>Initialization (<code>__init__</code>): Your constructor method sets up the object's initial state</li> </ol>"},{"location":"sessions/session-04/#4-constructor-design-and-instance-variables","title":"4. Constructor Design and Instance Variables","text":"<p>The <code>__init__</code> method is your constructor - it defines how objects are created and initialized.</p>"},{"location":"sessions/session-04/#constructor-best-practices","title":"Constructor Best Practices","text":""},{"location":"sessions/session-04/#epuckrobot-class-uml-structure","title":"EPuckRobot Class UML Structure","text":"<pre><code>classDiagram\n    class EPuckRobot {\n        -str robot_id\n        -float battery_percentage\n        -float current_speed\n        -bool is_moving\n        +__init__(robot_id: str, initial_battery_percentage: float) EPuckRobot\n        +move_forward(speed: float) void\n        +stop() void\n        +report_status() str\n    }\n\n    note for EPuckRobot \"Main robot class managing movement,\\nbattery status, and robot identification\"</code></pre> <pre><code>class EPuckRobot:\n    \"\"\"A blueprint for EPuck robot objects.\"\"\"\n\n    def __init__(self, robot_id: str, initial_battery_percentage: float):\n        \"\"\"\n        Initialize a new EPuckRobot object.\n\n        Args:\n            robot_id (str): Unique identifier for the robot\n            initial_battery_percentage (float): Battery level (0.0-100.0)\n        \"\"\"\n        # Instance variables define object state\n        self.robot_id = robot_id\n        self.battery_percentage = initial_battery_percentage\n        self.current_speed = 0.0\n        self.is_moving = False\n\n        print(f\"EPuckRobot '{self.robot_id}' initialized with {self.battery_percentage}% battery\")\n</code></pre>"},{"location":"sessions/session-04/#instance-variables-state","title":"Instance Variables (State)","text":"<p>Instance variables store data unique to each object:</p> <pre><code># Each robot has its own independent state\nrobot_alpha = EPuckRobot(\"Alpha_7\", 98.5)\nrobot_beta = EPuckRobot(\"Beta_12\", 75.0)\n\n# Modifying one doesn't affect the other\nrobot_alpha.current_speed = 0.5\nrobot_alpha.is_moving = True\n\nprint(f\"Alpha speed: {robot_alpha.current_speed}\")  # 0.5\nprint(f\"Beta speed: {robot_beta.current_speed}\")    # 0.0 (unchanged)\n</code></pre>"},{"location":"sessions/session-04/#5-instance-methods-behavior","title":"5. Instance Methods (Behavior)","text":"<p>Instance methods define what objects can do - their behaviors.</p>"},{"location":"sessions/session-04/#method-definition-rules","title":"Method Definition Rules","text":"<pre><code>class EPuckRobot:\n    def __init__(self, robot_id: str, initial_battery_percentage: float):\n        self.robot_id = robot_id\n        self.battery_percentage = initial_battery_percentage\n        self.current_speed = 0.0\n        self.is_moving = False\n\n    def move_forward(self, speed: float):\n        \"\"\"Start moving the robot forward at specified speed.\"\"\"\n        if 0.0 &lt;= speed &lt;= 1.0:\n            self.current_speed = speed\n            self.is_moving = True\n            print(f\"Robot {self.robot_id} moving forward at speed {speed}\")\n        else:\n            print(\"Speed must be between 0.0 and 1.0\")\n\n    def stop(self):\n        \"\"\"Stop the robot movement.\"\"\"\n        self.current_speed = 0.0\n        self.is_moving = False\n        print(f\"Robot {self.robot_id} stopped\")\n\n    def report_status(self):\n        \"\"\"Report current robot status.\"\"\"\n        status = f\"Robot {self.robot_id}:\\n\"\n        status += f\"  Battery: {self.battery_percentage}%\\n\"\n        status += f\"  Speed: {self.current_speed}\\n\"\n        status += f\"  Moving: {self.is_moving}\"\n        return status\n</code></pre>"},{"location":"sessions/session-04/#hands-on-exercise-mock-ir-sensor-class","title":"Hands-on Exercise: Mock IR Sensor Class","text":"<p>In this practical activity, you will write a Python class that simulates infrared (IR) distance sensors commonly found on robots like the e-puck.</p>"},{"location":"sessions/session-04/#task-create-and-use-a-mock-ir-sensor-class","title":"Task: Create and Use a Mock IR Sensor Class","text":""},{"location":"sessions/session-04/#irsensor-class-uml-structure","title":"IRSensor Class UML Structure","text":"<pre><code>classDiagram\n    class IRSensor {\n        -str name\n        +__init__(name: str) IRSensor\n        +get_reading() int\n    }\n\n    note for IRSensor \"Simulates infrared distance sensor\\nreturning readings in centimeters (1-100)\"</code></pre> <p>You will create five separate sensor objects for different positions on the robot:</p> <ul> <li><code>front_left</code></li> <li><code>front_center</code> </li> <li><code>front_right</code></li> <li><code>back_left</code></li> <li><code>back_right</code></li> </ul>"},{"location":"sessions/session-04/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<ol> <li>Create a class named <code>IRSensor</code></li> <li>The <code>__init__</code> method should take one parameter <code>name</code> (string) to store the sensor's position</li> <li>Create a method <code>get_reading()</code> that returns a simulated reading (integer between 1 and 100 cm)</li> <li>Include a proper docstring for <code>get_reading()</code> with Parameters and Returns</li> <li>In your main code, create 5 separate instances of <code>IRSensor</code>, one for each position listed above</li> <li>Call <code>get_reading()</code> on each instance and print the results</li> </ol>"},{"location":"sessions/session-04/#example-implementation-template","title":"Example Implementation Template","text":"<pre><code>import random\n\nclass IRSensor:\n    \"\"\"Simulates an infrared distance sensor.\"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initialize the IR sensor with a position name.\"\"\"\n        self.name = name\n        print(f\"IR Sensor '{self.name}' initialized\")\n\n    def get_reading(self):\n        \"\"\"\n        Simulate getting a distance measurement from the IR sensor.\n\n        Parameters:\n            None\n\n        Returns:\n            int: Distance measurement in centimeters (1\u2013100).\n        \"\"\"\n        reading = random.randint(1, 100)\n        print(f\"{self.name} sensor reading: {reading} cm\")\n        return reading\n\nif __name__ == \"__main__\":\n    # Create sensor instances\n    front_left = IRSensor(\"Front Left\")\n    front_center = IRSensor(\"Front Center\")\n    front_right = IRSensor(\"Front Right\")\n    back_left = IRSensor(\"Back Left\")\n    back_right = IRSensor(\"Back Right\")\n\n    # Get readings from each sensor\n    print(\"\\n--- Sensor Readings ---\")\n    front_left.get_reading()\n    front_center.get_reading()\n    front_right.get_reading()\n    back_left.get_reading()\n    back_right.get_reading()\n</code></pre> <p>Extension Challenge</p> <p>In a later lesson, we will discuss composition and how to group these sensor objects into a single class that manages multiple sensors.</p>"},{"location":"sessions/session-04/#live-demonstration-lidar-implementation-across-programming-paradigms","title":"Live Demonstration: LIDAR Implementation Across Programming Paradigms","text":"<p>The instructor will now demonstrate how to implement a mock LIDAR sensor using three different programming approaches, showing the evolution from simple procedural code to sophisticated object-oriented design.</p>"},{"location":"sessions/session-04/#1-procedural-approach","title":"1. Procedural Approach","text":"<p>The simplest implementation using basic Python constructs:</p> <pre><code># lidar_procedural.py\nimport random\n\n# Procedural: all logic inline\nmeasurements = []\nfor _ in range(36):\n    measurement = random.randint(1, 1200)  # cm range\n    measurements.append(measurement)\n\nprint(\"LIDAR Scan (Procedural):\")\nprint(measurements)\n</code></pre> <p>Characteristics: - All code in linear sequence - No reusability - Hard to extend or modify - Good for simple, one-time tasks</p>"},{"location":"sessions/session-04/#2-functional-approach","title":"2. Functional Approach","text":"<p>Using functions to organize and reuse code:</p> <pre><code># lidar_functional.py\nimport random\n\ndef get_measurement():\n    \"\"\"Simulates one LIDAR measurement.\"\"\"\n    return random.randint(1, 1200)\n\ndef scan_lidar(num_measurements=36):\n    \"\"\"Performs a LIDAR scan and returns a list of measurements.\"\"\"\n    return [get_measurement() for _ in range(num_measurements)]\n\nif __name__ == \"__main__\":\n    readings = scan_lidar()\n    print(\"LIDAR Scan (Functional):\")\n    print(readings)\n</code></pre> <p>Characteristics: - Functions provide reusability - Better organization than procedural - Easy to test individual functions - Good for stateless operations</p>"},{"location":"sessions/session-04/#3-object-oriented-approach","title":"3. Object-Oriented Approach","text":""},{"location":"sessions/session-04/#lidar-class-uml-structure","title":"Lidar Class UML Structure","text":"<pre><code>classDiagram\n    class Lidar {\n        -int num_measurements\n        +__init__(num_measurements: int) Lidar\n        +get_measurement() int\n        +scan() list~int~\n        +get_status() str\n    }\n\n    note for Lidar \"Advanced sensor simulation with\\nconfigurable measurement points (default: 36)\"</code></pre> <p>Using classes to create reusable, stateful components:</p> <pre><code># lidar_oop.py\nimport random\n\nclass Lidar:\n    \"\"\"Simulates a LIDAR sensor with configurable parameters.\"\"\"\n\n    def __init__(self, num_measurements=36):\n        \"\"\"Initialize LIDAR with specified number of measurements.\"\"\"\n        self.num_measurements = num_measurements\n        print(f\"LIDAR initialized with {self.num_measurements} measurement points\")\n\n    def get_measurement(self):\n        \"\"\"Simulates a single LIDAR measurement.\"\"\"\n        return random.randint(1, 1200)  # Distance in cm\n\n    def scan(self):\n        \"\"\"Performs a full scan and returns a list of measurements.\"\"\"\n        readings = []\n        for _ in range(self.num_measurements):\n            readings.append(self.get_measurement())\n        return readings\n\n    def get_status(self):\n        \"\"\"Returns the current status of the LIDAR sensor.\"\"\"\n        return f\"LIDAR Status: {self.num_measurements} measurement points configured\"\n\nif __name__ == \"__main__\":\n    # Create LIDAR instance\n    lidar = Lidar()\n    print(lidar.get_status())\n\n    # Perform scan\n    readings = lidar.scan()\n    print(\"LIDAR Scan (OOP):\")\n    print(f\"Collected {len(readings)} measurements\")\n    print(f\"Sample readings: {readings[:5]}...\")  # Show first 5 readings\n</code></pre> <p>Characteristics: - Encapsulation of data and behavior - Reusable sensor objects - Easy to extend with new features - Maintainable and scalable - Perfect for robotics applications</p>"},{"location":"sessions/session-04/#comparison-summary","title":"Comparison Summary","text":"Aspect Procedural Functional Object-Oriented Reusability Low Medium High Maintainability Low Medium High Scalability Poor Good Excellent State Management Global vars Parameters Instance vars Best For Simple scripts Stateless operations Complex systems <p>Live Coding Session</p> <p>The instructor will demonstrate building each version from scratch, showing: - How to refactor from procedural to functional - How to convert functional code to object-oriented - Benefits and trade-offs of each approach - When to use each paradigm in robotics</p>"},{"location":"sessions/session-04/#extension-activity-advanced-lidar-data-filtering","title":"Extension Activity: Advanced LIDAR Data Filtering","text":"<p>Your LIDAR class currently returns a full 360\u00b0 scan with 36 measurements. Sometimes you may only want part of the scan \u2014 for example, the front arc. Here are three different design approaches to achieve this:</p>"},{"location":"sessions/session-04/#approach-1-add-a-scan_filtered-method","title":"Approach 1: Add a <code>scan_filtered()</code> Method","text":"<pre><code>def scan_filtered(self, start=0, end=36):\n    \"\"\"Return scan results between given indices.\"\"\"\n    full_scan = self.scan()\n    return full_scan[start:end]\n</code></pre> <p>Pros: - \u2705 Keeps filtering logic inside the class (good encapsulation) - \u2705 Easy to call: <code>lidar.scan_filtered(4, 20)</code> - \u2705 Can be extended later for angle-based filtering</p> <p>Cons: - \u274c Adds an extra method that mostly wraps existing logic</p>"},{"location":"sessions/session-04/#approach-2-add-optional-parameters-to-scan","title":"Approach 2: Add Optional Parameters to <code>scan()</code>","text":"<pre><code>def scan(self, start=0, end=36):\n    \"\"\"Perform scan with optional filtering.\"\"\"\n    full_readings = [self.get_measurement() for _ in range(self.num_measurements)]\n    return full_readings[start:end]\n</code></pre> <p>Pros: - \u2705 No new method \u2014 extends the original one - \u2705 Introduces default parameters</p> <p>Cons: - \u274c Mixes two responsibilities: generating data and filtering data</p>"},{"location":"sessions/session-04/#approach-3-process-after-the-scan","title":"Approach 3: Process After the Scan","text":"<pre><code># In your main code\nreadings = lidar.scan()\nfront_arc = readings[4:20]  # Extract front arc\n</code></pre> <p>Pros: - \u2705 Keeps <code>scan()</code> simple and single-purpose - \u2705 Flexible filtering in client code</p> <p>Cons: - \u274c Filtering logic is done outside the class - \u274c More code in the main application</p>"},{"location":"sessions/session-04/#design-recommendation","title":"Design Recommendation","text":"<p>A good design follows the Single Responsibility Principle: one method should do one thing well. The recommended approach is:</p> <ol> <li>Keep <code>scan()</code> for the full 360\u00b0 scan</li> <li>Filter with list slicing when needed</li> <li>If filtering becomes common, add a dedicated <code>scan_filtered()</code> method inside the class</li> </ol> <p>Extension Challenge</p> <p>Implement one of these filtering approaches in your LIDAR class and test it with different ranges: - Front arc: indices 14-22 (forward-facing sensors) - Left side: indices 27-35  - Right side: indices 1-9</p>"},{"location":"sessions/session-04/#out-of-class-research-activities","title":"Out-of-Class Research Activities","text":"<p>To reinforce your understanding of the concepts covered in this session, research the following topics:</p>"},{"location":"sessions/session-04/#research-topics","title":"Research Topics","text":"<ol> <li>Object-Oriented Programming Principles</li> <li>Investigate the four main principles of OOP: Encapsulation, Inheritance, Polymorphism, and Abstraction</li> <li>Find real-world examples of how each principle is applied in robotics software</li> <li> <p>Compare OOP with other programming paradigms (procedural, functional)</p> </li> <li> <p>Class Design Best Practices</p> </li> <li>Research the Single Responsibility Principle and how it applies to class design</li> <li>Look into naming conventions for classes and methods in Python</li> <li> <p>Study examples of well-designed classes in robotics frameworks</p> </li> <li> <p>Python Class Features</p> </li> <li>Explore Python's special methods (<code>__init__</code>, <code>__str__</code>, <code>__repr__</code>)</li> <li>Research property decorators and getters/setters</li> <li> <p>Investigate class methods vs instance methods vs static methods</p> </li> <li> <p>Robotics Software Architecture</p> </li> <li>Study how major robotics frameworks (ROS, ROS2) use object-oriented design</li> <li>Research component-based architectures in robotics</li> <li>Look into design patterns commonly used in robotics software</li> </ol> <p>Research Resources</p> <ul> <li>Python official documentation on classes</li> <li>ROS tutorials and documentation</li> <li>Robotics software engineering books and articles</li> <li>Open-source robotics projects on GitHub</li> </ul>"},{"location":"sessions/session-04/#lab-1-webots-robot-simulator-setup","title":"Lab 1: Webots Robot Simulator Setup","text":"<p>To complete this session, students will set up the Webots robotics simulator that will be used in future lab exercises.</p> <p>Lab Credits</p> <p>This lab is based on the excellent work by Felipe Martins:</p> <p>Original Repository: Robotics-Simulation-Labs Author: Felipe Nascimento Martins License: Available on GitHub</p> <p>We acknowledge and appreciate the open-source contribution to robotics education.</p>"},{"location":"sessions/session-04/#objectives","title":"Objectives","text":"<p>The goal of this lab is to guide you to install, configure and familiarize yourself with Webots simulator. At the end of this lab you should be able to run Python code to control your simulated robot.</p>"},{"location":"sessions/session-04/#about-webots","title":"About Webots","text":"<p>Webots is an open-source robotics simulator that can simulate several types of robots and sensors. It provides a complete development environment to model, program and simulate robots and the world they are in, including physics simulation. It is widely used in industry, education and research.</p> <p></p>"},{"location":"sessions/session-04/#installation-tasks","title":"Installation Tasks","text":"<p>To complete this lab you have to follow the steps described below:</p>"},{"location":"sessions/session-04/#1-download-and-install-webots","title":"1. Download and Install Webots","text":"<ul> <li>Download from https://cyberbotics.com/</li> <li>You need Webots R2022a or newer for the Robotics Simulation Labs</li> <li>Available for Windows, macOS and Linux</li> <li>The download and installation process can take a while</li> </ul>"},{"location":"sessions/session-04/#2-complete-webots-tutorial-1","title":"2. Complete Webots Tutorial 1","text":"<ul> <li>Follow Webots Tutorial 1 </li> <li>Complete through Hands-on #7</li> <li>After that, you'll configure Python (next step)</li> </ul>"},{"location":"sessions/session-04/#3-install-python-3-if-needed","title":"3. Install Python 3 (if needed)","text":"<ul> <li>You need the 64-bit version of Python 3</li> <li>Download from python.org</li> <li>Windows users: Select \"Add to PATH\" during installation</li> <li>Version compatibility: Not all Python versions work with all Webots versions</li> <li>Webots R2022b works with Python 3.7, 3.8, 3.9 and 3.10</li> <li>Webots R2022a does not support Python 3.10</li> </ul>"},{"location":"sessions/session-04/#4-reboot-your-system","title":"4. Reboot Your System","text":"<ul> <li>Important: Reboot after installing Python</li> </ul>"},{"location":"sessions/session-04/#5-test-python-installation","title":"5. Test Python Installation","text":"<ul> <li>Open Command Prompt/Terminal</li> <li>Type <code>python</code>, <code>python3</code>, or <code>python3.x</code> (depending on your version)</li> <li>You should see something like:</li> </ul> <pre><code>Python 3.10.5 (tags/v3.10.5:f377153, Jun  6 2022, 16:14:13) [MSC v.1929 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt;\n</code></pre> <ul> <li>Type <code>exit()</code> to return to terminal</li> </ul>"},{"location":"sessions/session-04/#6-install-required-libraries","title":"6. Install Required Libraries","text":"<ul> <li>Follow instructions here</li> <li>Install at least NumPy</li> <li>Optional: OpenCV (also installs NumPy)</li> </ul>"},{"location":"sessions/session-04/#7-configure-webots-for-python","title":"7. Configure Webots for Python","text":"<ul> <li>In Webots: <code>Tools &gt; Preferences &gt; Python command</code></li> <li>Set to <code>python</code> or <code>python3</code> (whatever worked in step 5)</li> <li>macOS/Windows without PATH: Use full path to Python installation</li> </ul>"},{"location":"sessions/session-04/#8-complete-tutorial","title":"8. Complete Tutorial","text":"<ul> <li>Continue from \"Create New Controller\"</li> <li>Complete through Hands-on #10</li> <li>Important: Select <code>Python</code> when viewing code examples</li> </ul>"},{"location":"sessions/session-04/#troubleshooting-tips","title":"Troubleshooting Tips","text":"<p>Common Issues</p> <p>64-bit Python Required: 32-bit versions don't work with Webots</p> <p>macOS: May need full Python path in Webots preferences</p> <p>Linux: Avoid symbolic links in project folders; consider APT version</p> <p>Windows PATH: If Python isn't found, add it to system PATH and reboot</p> <p>Hardware Warning: Intel GPU warning is normal and won't affect our labs</p>"},{"location":"sessions/session-04/#windows-installation-issues","title":"Windows Installation Issues","text":"<p>If you see a security warning when installing Webots on Windows, click \"More info\" then \"Run anyway\":</p> <p></p>"},{"location":"sessions/session-04/#python-path-configuration","title":"Python PATH Configuration","text":"<p>If you need to add Python to your Windows PATH manually, the configuration should look like this:</p> <p></p>"},{"location":"sessions/session-04/#performance-optimization","title":"Performance Optimization","text":"<p>If Webots runs slowly on your hardware:</p> <ul> <li>Click <code>WorldInfo &gt; FPS</code> and reduce to 20</li> <li>Increase <code>basicTimeStep</code> to 32</li> <li>Go to <code>Tools &gt; Preferences &gt; OpenGL</code></li> <li>Reduce <code>Ambient Occlusion</code> and <code>Texture Quality</code></li> </ul>"},{"location":"sessions/session-04/#conclusion","title":"Conclusion","text":"<p>After completing these steps, you should have: - Webots installed and configured for Python - Understanding of basic Webots concepts - Ability to write simple Python programs to control simulated robots</p> <p>Lab Complete</p> <p>You're now ready for future robotics simulation exercises using Webots!</p>"},{"location":"sessions/session-04/#session-summary-class-relationships-overview","title":"Session Summary: Class Relationships Overview","text":"<p>Here's a comprehensive overview of all the classes we've implemented in this session:</p> <pre><code>classDiagram\n    class RobotLED {\n        +str led_id\n        +bool is_on\n        +__init__(led_id: str)\n        +turn_on()\n        +turn_off()\n    }\n\n    class EPuckRobot {\n        +str robot_id\n        +float battery_percentage\n        +float current_speed\n        +bool is_moving\n        +__init__(robot_id: str, initial_battery_percentage: float)\n        +move_forward(speed: float)\n        +stop()\n        +report_status() str\n    }\n\n    class IRSensor {\n        +str name\n        +__init__(name: str)\n        +get_reading() int\n    }\n\n    class Lidar {\n        +int num_measurements\n        +__init__(num_measurements: int)\n        +get_measurement() int\n        +scan() list\n        +get_status() str\n    }\n\n    note for RobotLED \"Manages individual LED state\\nand behavior\"\n    note for EPuckRobot \"Main robot controller with\\nmovement and status tracking\"\n    note for IRSensor \"Simulates infrared distance\\nsensor readings\"\n    note for Lidar \"Simulates LIDAR sensor with\\nconfigurable measurements\"</code></pre>"},{"location":"sessions/session-04/#programming-paradigm-evolution","title":"Programming Paradigm Evolution","text":"<p>The evolution from procedural to object-oriented programming can be visualized as:</p> <pre><code>flowchart TD\n    A[Procedural Approach] --&gt; B[\"Global variables&lt;br/&gt;Separate functions&lt;br/&gt;Limited reusability\"]\n\n    C[Functional Approach] --&gt; D[\"Pure functions&lt;br/&gt;Parameter passing&lt;br/&gt;Better organization\"]\n\n    E[Object-Oriented Approach] --&gt; F[\"Encapsulated data&lt;br/&gt;Methods with data&lt;br/&gt;Reusable objects&lt;br/&gt;Scalable design\"]\n\n    B --&gt; G[\"\u274c Hard to maintain&lt;br/&gt;\u274c Global state issues&lt;br/&gt;\u274c No reusability\"]\n    D --&gt; H[\"\u2705 Better organization&lt;br/&gt;\u26a0\ufe0f Stateless only&lt;br/&gt;\u26a0\ufe0f Limited scalability\"]\n    F --&gt; I[\"\u2705 Highly maintainable&lt;br/&gt;\u2705 Reusable components&lt;br/&gt;\u2705 Scalable architecture&lt;br/&gt;\u2705 Perfect for robotics\"]\n\n    style A fill:#ffcccc\n    style C fill:#ffffcc\n    style E fill:#ccffcc\n    style G fill:#ffcccc\n    style H fill:#ffffcc\n    style I fill:#ccffcc</code></pre> <p>UML Diagram Benefits</p> <p>These UML diagrams help visualize: - Class structure: Attributes and methods at a glance - Relationships: How classes might interact in larger systems - Design patterns: Common robotics software patterns - Scalability: How to extend classes for more complex robots</p>"},{"location":"sessions/session-04/#key-takeaways","title":"Key Takeaways","text":"<p>Session Summary</p> <ul> <li>OOP Benefits: Encapsulation, modularity, reusability, and flexibility</li> <li>Classes vs Objects: Blueprints vs instances</li> <li>Instantiation: Memory allocation + initialization process</li> <li>Instance Variables: Store unique object state</li> <li>Instance Methods: Define object behaviors</li> <li>Constructor Design: Proper <code>__init__</code> method implementation</li> </ul>"},{"location":"sessions/session-04/#check-your-knowledge","title":"Check Your Knowledge","text":"<p>Test your understanding of the Object-Oriented Programming concepts covered in this session:</p> <p>Question 1: Class vs Object</p> <p>Question: What's the difference between a class and an object? Use the robot LED example to explain.</p> Click to reveal answer <p>Answer: </p> <ul> <li>Class: A blueprint or template (like <code>RobotLED</code> class) that defines what all LED objects will have</li> <li>Object: An actual LED created from that blueprint (like <code>front_led</code> or <code>back_led</code>)</li> </ul> <p>Think of it like a cookie cutter (class) and the actual cookies (objects). You use one cookie cutter to make many different cookies, just like you use one <code>RobotLED</code> class to create many different LED objects.</p> <p>Question 2: What does <code>self</code> mean?</p> <p>Question: In the method <code>def turn_on(self):</code>, what does the word <code>self</code> represent?</p> Click to reveal answer <p>Answer: </p> <p><code>self</code> refers to the specific object that the method is being called on. </p> <p>When you write <code>front_led.turn_on()</code>, inside the <code>turn_on()</code> method, <code>self</code> refers to the <code>front_led</code> object. This is how the method knows which LED to turn on - it's the one that called the method!</p> <p>Question 3: Instance Variables vs Class Variables</p> <p>Question: Look at these two pieces of code. What's the difference?</p> <pre><code>Code A: self.led_id = \"front\"\nCode B: led_count = 0\n</code></pre> Click to reveal answer <p>Answer: </p> <ul> <li> <p>Code A (<code>self.led_id</code>): This is an instance variable. Each LED object has its own <code>led_id</code>. The front LED has <code>led_id = \"front\"</code> and the back LED has <code>led_id = \"back\"</code>.</p> </li> <li> <p>Code B (<code>led_count</code>): This is a class variable. There's only one <code>led_count</code> shared by all LED objects. If you wanted to count how many total LEDs exist, you'd use a class variable.</p> </li> </ul> <p>Key difference: Instance variables are unique to each object, class variables are shared by all objects.</p> <p>Question 4: Why use OOP for robots?</p> <pre><code>**Question**: Name two main benefits of using object-oriented programming for robotics instead of just writing simple functions.\n</code></pre> Click to reveal answer <p>Answer: </p> <ol> <li> <p>Organization: Each robot component (LED, sensor, motor) can be its own class, making the code much more organized and easier to understand.</p> </li> <li> <p>Reusability: Once you write a <code>RobotLED</code> class, you can use it for any robot project. You don't have to rewrite LED control code every time.</p> </li> </ol> <p>Bonus: Independence - Each object manages its own data, so turning on one LED won't accidentally affect another LED.</p> <p>Question 5: Object Instantiation</p> <p>Question: When you write <code>my_led = RobotLED(\"status\")</code>, what two things happen inside Python?</p> Click to reveal answer <p>Answer: </p> <ol> <li>Memory allocation: Python creates space in memory for the new LED object</li> <li>Initialization: Python calls the <code>__init__</code> method to set up the object's initial values (like setting <code>led_id</code> to \"status\" and <code>is_on</code> to <code>False</code>)</li> </ol> <p>After these two steps, you have a fully working LED object stored in the variable <code>my_led</code>.</p>"},{"location":"sessions/session-04/#next-session-preview","title":"Next Session Preview","text":"<p>Week 5: Advanced Class Features &amp; Magic Methods</p> <ul> <li>Python magic methods (<code>__str__</code>, <code>__repr__</code>, <code>__eq__</code>)</li> <li>Property decorators and getters/setters</li> <li>Class methods and static methods</li> <li>Operator overloading for custom classes</li> </ul>"},{"location":"sessions/session-04/#resources","title":"Resources","text":""},{"location":"sessions/session-04/#downloads","title":"Downloads","text":"<ul> <li> Robot class starter code</li> <li> Complete class implementations</li> <li> LIDAR procedural version</li> <li> LIDAR functional version</li> <li> LIDAR object-oriented version</li> <li> All Week 4 resources</li> </ul>"},{"location":"sessions/session-04/#further-reading","title":"Further Reading","text":"<ul> <li>Python Classes Documentation</li> <li>OOP Design Patterns</li> <li>Robotics Software Architecture</li> </ul> <p>Navigation: \u2190 Week 3 | Learning Plan | Week 5 \u2192</p>"},{"location":"sessions/session-05/","title":"Week 5 - Advanced Class Features","text":""},{"location":"sessions/session-05/#session-5-advanced-class-features-magic-methods","title":"Session 5: Advanced Class Features &amp; Magic Methods","text":"<p>Week: 5 Element: ICTPRG430 Element 2.2 Duration: 4 hours Phase: Object-Oriented Programming </p>"},{"location":"sessions/session-05/#session-introduction","title":"Session Introduction","text":"<p>In this session, you'll explore advanced Python class features that make your robotics code more professional and maintainable. You'll learn how to make your robot objects display themselves clearly using magic methods (<code>__str__</code> and <code>__repr__</code>), understand the fundamentals of data encapsulation through getters and setters (both traditional and decorator approaches), and see how function wrapping works. The session culminates with Lab 2, where you'll implement a line-following robot using object-oriented principles in Webots simulator.</p>"},{"location":"sessions/session-05/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this session, you will be able to:</p> <ul> <li>Implement and distinguish between <code>__str__</code> and <code>__repr__</code> magic methods</li> <li>Understand when and why to use each string representation method</li> <li>Create getter and setter methods for controlled data access</li> <li>Apply the <code>@property</code> decorator for Pythonic attribute access</li> <li>Understand function wrapping concepts as preparation for decorators</li> <li>Design object-oriented solutions for line-following robot behaviors</li> <li>Implement sensor fusion and control logic in a robotics context</li> </ul>"},{"location":"sessions/session-05/#session-structure","title":"Session Structure","text":"<ol> <li>Theory Session - Magic methods and string representations</li> <li>Hands-on Exercise - Implementing <code>__str__</code> and <code>__repr__</code> for robot classes</li> <li>Data Encapsulation - Traditional getters/setters and property decorators</li> <li>Function Wrapping - Understanding decorator foundations</li> <li>Lab 2 - Line-following robot implementation in Webots</li> </ol>"},{"location":"sessions/session-05/#session-overview","title":"Session Overview","text":"<p>This session builds on the foundational OOP concepts from Session 4, introducing advanced class features that make your robotics code more robust and professional. We'll focus on how objects represent themselves and how to control access to object data.</p>"},{"location":"sessions/session-05/#pre-session-preparation","title":"Pre-Session Preparation","text":"<p>Setup Check</p> <p>Ensure your development environment is ready:</p> <ul> <li>Python 3.9+ with Webots integration working</li> <li>VS Code with Python</li> <li>Completed Session 4 robot class exercises</li> </ul>"},{"location":"sessions/session-05/#1-magic-methods-making-objects-talk","title":"1. Magic Methods: Making Objects Talk","text":"<p>Magic methods (also called \"dunder methods\" because they have **d**ouble **under**scores) are special Python methods that define how objects behave in specific situations. Today we'll focus on the two most important ones for displaying object information: <code>__str__</code> and <code>__repr__</code>.</p>"},{"location":"sessions/session-05/#why-magic-methods-matter-in-robotics","title":"Why Magic Methods Matter in Robotics","text":"<p>When debugging robot behavior, you need clear, informative output about your objects. Without magic methods, Python gives you useless information:</p> <pre><code># Without magic methods - unhelpful output\nrobot = EPuckRobot(\"Alpha_7\", 98.5)\nprint(robot)\n# Output: &lt;__main__.EPuckRobot object at 0x7f8b8c0a1d30&gt;\n</code></pre> <p>With proper magic methods, you get meaningful information:</p> <pre><code># With magic methods - useful output\nrobot = EPuckRobot(\"Alpha_7\", 98.5)\nprint(robot)\n# Output: EPuckRobot(robot_id='Alpha_7', battery=98.5%, speed=0.0, moving=False)\n</code></pre>"},{"location":"sessions/session-05/#understanding-__str__-vs-__repr__","title":"Understanding <code>__str__</code> vs <code>__repr__</code>","text":"<p>Abstract</p> <p>\"Key Differences\"</p> <p><code>__str__</code> : For end users - human-readable, friendly format</p> <ul> <li>Called by <code>print()</code> and <code>str()</code></li> <li>Should be clear and informative for users</li> <li>Think: \"What would a robot operator want to see?\"</li> </ul> <p><code>__repr__</code>: For developers - precise, unambiguous format</p> <ul> <li>Called by <code>repr()</code> and when displaying in lists/debugger</li> <li>Should ideally be valid Python code to recreate the object</li> <li>Think: \"What would help a programmer debug this?\"</li> </ul>"},{"location":"sessions/session-05/#2-implementing-string-representations","title":"2. Implementing String Representations","text":"<p>Let's enhance our EPuckRobot class from Session 4 with proper string representations.</p>"},{"location":"sessions/session-05/#epuckrobot-enhanced-class-uml-structure","title":"EPuckRobot Enhanced Class UML Structure","text":"<pre><code>classDiagram\n    class EPuckRobot {\n        -str robot_id\n        -float battery_percentage\n        -float current_speed\n        -bool is_moving\n        +__init__(robot_id: str, initial_battery_percentage: float) EPuckRobot\n        +__str__() str\n        +__repr__() str\n        +move_forward(speed: float) void\n        +stop() void\n        +report_status() str\n    }\n\n    note for EPuckRobot \"Enhanced with string representation methods\\nfor better debugging and user interaction\"</code></pre> <p>Interactive Code Example</p> <p>Try this interactive example to experiment with the concepts:</p> <p></p>"},{"location":"sessions/session-05/#hands-on-exercise-enhanced-ir-sensor-with-string-representations","title":"Hands-on Exercise: Enhanced IR Sensor with String Representations","text":"<p>Building on Session 4's IR Sensor class, you'll now add professional string representations.</p>"},{"location":"sessions/session-05/#task-enhance-irsensor-with-magic-methods","title":"Task: Enhance IRSensor with Magic Methods","text":""},{"location":"sessions/session-05/#enhanced-irsensor-class-uml-structure","title":"Enhanced IRSensor Class UML Structure","text":"<pre><code>classDiagram\n    class IRSensor {\n        -str name\n        -int last_reading\n        +__init__(name: str) IRSensor\n        +__str__() str\n        +__repr__() str\n        +get_reading() int\n        +get_status() str\n    }\n\n    note for IRSensor \"Enhanced sensor with string representations\\nand reading history for better debugging\"</code></pre>"},{"location":"sessions/session-05/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<ol> <li> <p>Enhance your IRSensor class from Session 4 with these additions:</p> <ul> <li>Add a <code>last_reading</code> instance variable to store the most recent reading</li> <li>Implement <code>__str__()</code> for user-friendly display</li> <li>Implement <code>__repr__()</code> for debugging</li> <li>Add a <code>get_status()</code> method that returns detailed sensor information</li> <li> <p>Requirements for string methods:</p> </li> <li> <p><code>__str__()</code>: Should show sensor name and last reading in a friendly format</p> </li> <li><code>__repr__()</code>: Should show exact constructor call needed to recreate the sensor</li> <li>Handle the case when no reading has been taken yet</li> </ul> </li> </ol>"},{"location":"sessions/session-05/#complete-implementation-template","title":"Complete Implementation Template","text":"<pre><code>import random\n\nclass IRSensor:\n    \"\"\"Enhanced infrared distance sensor with string representations.\"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"\n        Initialize the IR sensor with a position name.\n\n        Args:\n            name (str): Position identifier for the sensor\n        \"\"\"\n        pass\n\n    def __str__(self):\n        \"\"\"\n        Return user-friendly string representation.\n\n        Returns:\n            str: Human-readable sensor status\n        \"\"\"\n        pass\n\n\n    def __repr__(self):\n        \"\"\"\n        Return developer-friendly string representation.\n\n        Returns:\n            str: Precise representation for debugging\n        \"\"\"\n        pass\n\n    def get_reading(self):\n        \"\"\"\n        Simulate getting a distance measurement from the IR sensor.\n\n        Returns:\n            int: Distance measurement in centimeters (1-100)\n        \"\"\"\n        pass\n\n    def get_status(self):\n        \"\"\"\n        Get detailed status information about the sensor.\n\n        Returns:\n            str: Detailed sensor status\n        \"\"\"\n        pass\n\"\n\nif __name__ == \"__main__\":\n    # Create sensor instances\n    sensors = [\n        IRSensor(\"Front Left\"),\n        IRSensor(\"Front Center\"),\n        IRSensor(\"Front Right\"),\n        IRSensor(\"Back Left\"),\n        IRSensor(\"Back Right\")\n    ]\n\n    print(\"\\n=== Initial Sensor Status ===\")\n    for sensor in sensors:\n        print(sensor)  # Uses __str__\n\n    print(\"\\n=== After Taking Readings ===\")\n    for sensor in sensors:\n        sensor.get_reading()\n\n    print(\"\\n=== Updated Sensor Display ===\")\n    for sensor in sensors:\n        print(sensor)  # Shows readings now\n\n    print(\"\\n=== Debugging View ===\")\n    print(\"Sensor list:\", sensors)  # Uses __repr__ for each sensor\n\n    print(\"\\n=== Detailed Status ===\")\n    for sensor in sensors:\n        print(sensor.get_status())\n</code></pre> <p>Expected Output (values will change for yours):</p> <pre><code>IR Sensor 'Front Left' initialized\nIR Sensor 'Front Center' initialized\nIR Sensor 'Front Right' initialized\nIR Sensor 'Back Left' initialized\nIR Sensor 'Back Right' initialized\n\n=== Initial Sensor Status ===\nFront Left Sensor: No readings taken\nFront Center Sensor: No readings taken\nFront Right Sensor: No readings taken\nBack Left Sensor: No readings taken\nBack Right Sensor: No readings taken\n\n=== After Taking Readings ===\nFront Left sensor reading: 42 cm\nFront Center sensor reading: 78 cm\nFront Right sensor reading: 15 cm\nBack Left sensor reading: 91 cm\nBack Right sensor reading: 33 cm\n\n=== Updated Sensor Display ===\nFront Left Sensor: 42 cm\nFront Center Sensor: 78 cm\nFront Right Sensor: 15 cm\nBack Left Sensor: 91 cm\nBack Right Sensor: 33 cm\n\n=== Debugging View ===\nSensor list: [IRSensor(name='Front Left'), IRSensor(name='Front Center'), IRSensor(name='Front Right'), IRSensor(name='Back Left'), IRSensor(name='Back Right')]\n\n=== Detailed Status ===\nSensor 'Front Left': Active (last reading: 42 cm)\nSensor 'Front Center': Active (last reading: 78 cm)\nSensor 'Front Right': Active (last reading: 15 cm)\nSensor 'Back Left': Active (last reading: 91 cm)\nSensor 'Back Right': Active (last reading: 33 cm)\n</code></pre> <p>!!! tip \"Best Practice Tip\" Notice how <code>__str__</code> provides information useful to robot operators, while <code>__repr__</code> shows exactly how to recreate the object. This distinction helps both users and developers.</p>"},{"location":"sessions/session-05/#3-data-encapsulation-controlling-access-to-object-data","title":"3. Data Encapsulation: Controlling Access to Object Data","text":"<p>Data encapsulation is about controlling how external code accesses and modifies object data. In robotics, this prevents dangerous operations like setting invalid motor speeds or battery levels.</p>"},{"location":"sessions/session-05/#the-problem-with-direct-attribute-access","title":"The Problem with Direct Attribute Access","text":"<pre><code># Direct access can lead to problems\nrobot = EPuckRobot(\"Alpha_7\", 98.5)\nrobot.battery_percentage = 150.0  # Invalid! Batteries can't exceed 100%\nrobot.current_speed = -0.5        # Invalid! Negative speed doesn't make sense\n</code></pre>"},{"location":"sessions/session-05/#traditional-getter-and-setter-methods","title":"Traditional Getter and Setter Methods","text":"<p>Before we learn the elegant decorator approach, let's understand the traditional method:</p>"},{"location":"sessions/session-05/#battery-management-class-uml-structure","title":"Battery Management Class UML Structure","text":"<pre><code>classDiagram\n    class BatteryManager {\n        -float _battery_level\n        +__init__(initial_level: float) BatteryManager\n        +get_battery_level() float\n        +set_battery_level(level: float) void\n        +is_battery_low() bool\n        +__str__() str\n        +__repr__() str\n    }\n\n    note for BatteryManager \"Encapsulates battery data with\\nvalidation and controlled access\"</code></pre> <pre><code>class BatteryManager:\n    \"\"\"Manages robot battery with controlled access.\"\"\"\n\n    def __init__(self, initial_level: float):\n        \"\"\"Initialize battery manager with validation.\"\"\"\n        self._battery_level = 0.0  # Private attribute (by convention)\n        self.set_battery_level(initial_level)  # Use setter for validation\n\n    def get_battery_level(self):\n        \"\"\"\n        Get current battery level.\n\n        Returns:\n            float: Battery level as percentage (0.0-100.0)\n        \"\"\"\n        return self._battery_level\n\n    def set_battery_level(self, level: float):\n        \"\"\"\n        Set battery level with validation.\n\n        Args:\n            level (float): Battery level percentage\n\n        Raises:\n            ValueError: If level is outside valid range\n        \"\"\"\n        if not isinstance(level, (int, float)):\n            raise TypeError(\"Battery level must be a number\")\n\n        if level &lt; 0.0:\n            raise ValueError(\"Battery level cannot be negative\")\n\n        if level &gt; 100.0:\n            raise ValueError(\"Battery level cannot exceed 100%\")\n\n        self._battery_level = float(level)\n        print(f\"Battery level set to {self._battery_level}%\")\n\n    def is_battery_low(self):\n        \"\"\"\n        Check if battery is low.\n\n        Returns:\n            bool: True if battery is below 20%\n        \"\"\"\n        return self._battery_level &lt; 20.0\n\n    def __str__(self):\n        \"\"\"User-friendly battery status.\"\"\"\n        status = \"LOW\" if self.is_battery_low() else \"OK\"\n        return f\"Battery: {self._battery_level}% ({status})\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return f\"BatteryManager(initial_level={self._battery_level})\"\n\n# Usage example\nif __name__ == \"__main__\":\n    # Create battery manager\n    battery = BatteryManager(85.0)\n    print(battery)\n\n    # Safe access through getters/setters\n    print(f\"Current level: {battery.get_battery_level()}%\")\n\n    # Validation prevents invalid values\n    try:\n        battery.set_battery_level(150.0)  # Will raise ValueError\n    except ValueError as e:\n        print(f\"Error: {e}\")\n\n    # Check battery status\n    battery.set_battery_level(15.0)\n    print(battery)\n    print(f\"Battery low: {battery.is_battery_low()}\")\n</code></pre>"},{"location":"sessions/session-05/#4-function-wrapping-understanding-decorator-foundations","title":"4. Function Wrapping: Understanding Decorator Foundations","text":"<p>Before learning the <code>@property</code> decorator, let's understand how function wrapping works. This concept is fundamental to understanding decorators.</p>"},{"location":"sessions/session-05/#basic-function-wrapping-example","title":"Basic Function Wrapping Example","text":"<pre><code>def validate_positive(func):\n    \"\"\"Wrapper that validates function arguments are positive.\"\"\"\n    def wrapper(value):\n        print(f\"Validating that {value} is positive...\")\n        if value &lt; 0:\n            raise ValueError(\"Value must be positive\")\n        result = func(value)\n        print(f\"Validation passed, result: {result}\")\n        return result\n    return wrapper\n\ndef calculate_square_root(number):\n    \"\"\"Calculate square root of a number.\"\"\"\n    return number ** 0.5\n\n# Wrap the function manually\nsafe_square_root = validate_positive(calculate_square_root)\n\n# Test the wrapped function\ntry:\n    result = safe_square_root(16.0)  # Works fine\n    print(f\"\u221a16 = {result}\")\n\n    result = safe_square_root(-4.0)  # Raises error\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"sessions/session-05/#how-this-relates-to-properties","title":"How This Relates to Properties","text":"<p>The <code>@property</code> decorator works similarly - it wraps your method to make it behave like an attribute. Understanding this concept helps you grasp how decorators work \"under the hood.\"</p>"},{"location":"sessions/session-05/#5-property-decorators-the-pythonic-way","title":"5. Property Decorators: The Pythonic Way","text":"<p>Now that you understand function wrapping, let's see how the <code>@property</code> decorator provides a cleaner approach to getters and setters.</p>"},{"location":"sessions/session-05/#enhanced-motor-controller-class-uml-structure","title":"Enhanced Motor Controller Class UML Structure","text":"<pre><code>classDiagram\n    class MotorController {\n        -float _speed\n        -float _max_speed\n        -bool _is_running\n        +__init__(max_speed: float) MotorController\n        +speed: float\n        +max_speed: float\n        +is_running: bool\n        +start() void\n        +stop() void\n        +__str__() str\n        +__repr__() str\n    }\n\n    note for MotorController \"Uses property decorators for clean,\\nvalidated attribute access\"</code></pre> <pre><code>class MotorController:\n    \"\"\"Motor controller with property-based encapsulation.\"\"\"\n\n    def __init__(self, max_speed: float = 1.0):\n        \"\"\"\n        Initialize motor controller.\n\n        Args:\n            max_speed (float): Maximum allowed speed (0.0-1.0)\n        \"\"\"\n        self._speed = 0.0\n        self._max_speed = max_speed\n        self._is_running = False\n        print(f\"Motor controller initialized (max speed: {max_speed})\")\n\n    @property\n    def speed(self):\n        \"\"\"\n        Get current motor speed.\n\n        Returns:\n            float: Current speed (0.0-1.0)\n        \"\"\"\n        return self._speed\n\n    @speed.setter\n    def speed(self, value):\n        \"\"\"\n        Set motor speed with validation.\n\n        Args:\n            value (float): Desired speed (0.0-max_speed)\n\n        Raises:\n            ValueError: If speed is outside valid range\n            TypeError: If speed is not a number\n        \"\"\"\n        if not isinstance(value, (int, float)):\n            raise TypeError(\"Speed must be a number\")\n\n        if value &lt; 0.0:\n            raise ValueError(\"Speed cannot be negative\")\n\n        if value &gt; self._max_speed:\n            raise ValueError(f\"Speed cannot exceed {self._max_speed}\")\n\n        self._speed = float(value)\n        self._is_running = (self._speed &gt; 0.0)\n        print(f\"Motor speed set to {self._speed}\")\n\n    @property\n    def max_speed(self):\n        \"\"\"Get maximum allowed speed.\"\"\"\n        return self._max_speed\n\n    @property\n    def is_running(self):\n        \"\"\"Check if motor is currently running.\"\"\"\n        return self._is_running\n\n    def start(self):\n        \"\"\"Start motor at current speed setting.\"\"\"\n        if self._speed &gt; 0.0:\n            self._is_running = True\n            print(f\"Motor started at speed {self._speed}\")\n        else:\n            print(\"Cannot start motor: speed is 0.0\")\n\n    def stop(self):\n        \"\"\"Stop motor (sets speed to 0).\"\"\"\n        self._speed = 0.0\n        self._is_running = False\n        print(\"Motor stopped\")\n\n    def __str__(self):\n        \"\"\"User-friendly motor status.\"\"\"\n        status = \"RUNNING\" if self._is_running else \"STOPPED\"\n        return f\"Motor: {status} at {self._speed}/{self._max_speed} speed\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return f\"MotorController(max_speed={self._max_speed})\"\n\n# Usage demonstrating property access\nif __name__ == \"__main__\":\n    # Create motor controller\n    motor = MotorController(0.8)  # Max speed of 0.8\n    print(motor)\n\n    # Property access looks like normal attribute access\n    print(f\"Current speed: {motor.speed}\")\n    print(f\"Max speed: {motor.max_speed}\")\n    print(f\"Is running: {motor.is_running}\")\n\n    # Set speed using property (calls the setter)\n    motor.speed = 0.5\n    print(motor)\n\n    # Try invalid values\n    try:\n        motor.speed = 1.2  # Exceeds max_speed\n    except ValueError as e:\n        print(f\"Error: {e}\")\n\n    try:\n        motor.speed = \"fast\"  # Wrong type\n    except TypeError as e:\n        print(f\"Error: {e}\")\n\n    # Properties are read-only where no setter is defined\n    try:\n        motor.max_speed = 1.0  # This will raise AttributeError\n    except AttributeError as e:\n        print(f\"Error: can't set max_speed - {e}\")\n</code></pre>"},{"location":"sessions/session-05/#comparing-approaches","title":"Comparing Approaches","text":"Aspect Traditional Getters/Setters Property Decorators Syntax <code>robot.get_speed()</code> / <code>robot.set_speed(0.5)</code> <code>robot.speed</code> / <code>robot.speed = 0.5</code> Readability More verbose Clean, attribute-like access Validation \u2705 Full control \u2705 Full control Pythonic Less Pythonic \u2705 Highly Pythonic Learning Curve Easier to understand initially Requires understanding decorators <p>!!! tip \"When to Use Each Approach\" - Traditional getters/setters: When you need complex validation logic or multiple parameters - Property decorators: For simple attribute access with validation (recommended for most cases)</p>"},{"location":"sessions/session-05/#check-your-knowledge","title":"Check Your Knowledge","text":"<p>Test your understanding of the advanced OOP concepts covered in this session:</p> <p>Question 1: <code>__str__</code> vs <code>__repr__</code> Purpose</p> <p>Question: You have a <code>RobotSensor</code> object. When would Python call <code>__str__()</code> vs <code>__repr__()</code>? Give specific examples.</p> Click to reveal answer <p>Answer: : </p> <p><code>__str__()</code> is called when: - You use <code>print(sensor)</code> - You use <code>str(sensor)</code>  - String formatting like <code>f\"Sensor data: {sensor}\"</code></p> <p><code>__repr__()</code> is called when: - You use <code>repr(sensor)</code> - The object appears in a list: <code>print([sensor1, sensor2])</code> - In the debugger or interactive shell when you just type the variable name - When <code>__str__()</code> is not defined, Python falls back to <code>__repr__()</code></p> <p>Question 2: Property Decorator Syntax</p> <p>Question: Look at this code. What's wrong with it?</p> <pre><code>class Robot:\n    def __init__(self):\n        self._speed = 0.0\n\n    @property\n    def speed(self, value):\n        self._speed = value\n</code></pre> Click to reveal answer <p>Answer: </p> <p>The <code>@property</code> decorator is used incorrectly. The method decorated with <code>@property</code> should be the getter (no parameters except <code>self</code>). To set values, you need a separate setter:</p> <pre><code>class Robot:\n    def __init__(self):\n        self._speed = 0.0\n\n    @property\n    def speed(self):  # Getter - no value parameter\n        return self._speed\n\n    @speed.setter\n    def speed(self, value):  # Setter - has value parameter\n        self._speed = value\n</code></pre> <p>````</p> Question 3: When to Use Properties <p>Question: Your robot has a <code>battery_level</code> that should never go below 0 or above 100. Should you use a property or just a regular attribute? Why?</p> Click to reveal answer <p>Answer: </p> <p>Use a property because you need validation. Here's why:</p> <ul> <li>Validation needed: Battery levels have strict limits (0-100%)</li> <li>Safety critical: Invalid battery levels could cause unsafe robot behavior</li> <li>Clean syntax: <code>robot.battery_level = 85</code> is cleaner than <code>robot.set_battery_level(85)</code></li> </ul> <p>Example implementation: </p><pre><code>@property\ndef battery_level(self):\n    return self._battery_level\n\n@battery_level.setter\ndef battery_level(self, value):\n    if not 0 &lt;= value &lt;= 100:\n        raise ValueError(\"Battery level must be 0-100%\")\n    self._battery_level = value\n</code></pre> Question 4: Understanding <code>self</code> in Magic Methods <p>Question: In <code>def __str__(self):</code>, what does <code>self</code> refer to, and why don't you need to pass it when calling <code>print(robot)</code>?</p> Click to reveal answer <p>Answer: </p> <ul> <li><code>self</code> refers to: The specific robot object that <code>__str__()</code> is being called on</li> <li>Why you don't pass it: Python automatically passes <code>self</code> when you call methods on objects</li> </ul> <p>When you write <code>print(robot)</code>: 1. Python internally calls <code>robot.__str__()</code> 2. Python automatically passes the <code>robot</code> object as the <code>self</code> parameter 3. Your <code>__str__</code> method can then access <code>self.robot_id</code>, <code>self.battery_percentage</code>, etc.</p> <p>This is the same reason you don't write <code>robot.move_forward(robot, 0.5)</code> - Python handles the <code>self</code> parameter automatically.</p> Question 5: Property vs Method Decision <p>Question: For each of these robot operations, should it be a property or a method? Explain your reasoning.</p> <ul> <li><code>robot.current_speed</code> (just getting the speed)</li> <li><code>robot.turn_left()</code> (making the robot turn)  </li> <li><code>robot.battery_percentage</code> (getting/setting battery level)</li> <li><code>robot.emergency_stop()</code> (immediate stop command)</li> </ul> Click to reveal answer <p>Answer: </p> <ul> <li><code>robot.current_speed</code> \u2192 Property: Getting data, no action performed, feels like an attribute</li> <li><code>robot.turn_left()</code> \u2192 Method: Performs an action, changes robot state, side effects</li> <li><code>robot.battery_percentage</code> \u2192 Property: Data that might need validation, attribute-like access</li> <li><code>robot.emergency_stop()</code> \u2192 Method: Critical action, clear that something important happens</li> </ul> <p>Rule of thumb:  - Properties: For data access (getting/setting values) that feels like attribute access - Methods: For actions, operations, or anything that \"does something\" to the object</p>"},{"location":"sessions/session-05/#lab-2-line-follower-robot-implementation","title":"Lab 2: Line-follower Robot Implementation","text":"<p>In this lab, you will implement a line-following robot using object-oriented programming principles in the Webots simulator. This lab builds on the OOP concepts learned in Sessions 4 and 5, applying them to a real robotics problem.</p> <p>Lab Credits</p> <p>This lab is adapted from the excellent work by Felipe Martins:</p> <p>Original Repository: Robotics-Simulation-Labs Author: Felipe Nascimento Martins License: Available on GitHub</p> <p>We acknowledge and appreciate the open-source contribution to robotics education.</p>"},{"location":"sessions/session-05/#about-line-following","title":"About Line Following","text":"<p>Line following is a fundamental robotics task where a robot uses sensors to detect and follow a path marked on the ground. This requires:</p> <ul> <li>Sensor data processing: Reading and interpreting sensor values</li> <li>Decision making: Determining robot actions based on sensor data</li> <li>Motor control: Translating decisions into wheel movements</li> <li>Real-time operation: Continuously processing sensor data and adjusting behavior</li> </ul>"},{"location":"sessions/session-05/#lab-setup","title":"Lab Setup","text":"<p>Before starting the implementation, ensure you have:</p> <ol> <li>Webots simulator installed and working (from Session 4)</li> <li>Python 3.9+ configured with Webots</li> <li>Basic understanding of OOP concepts from Sessions 4 and 5</li> </ol>"},{"location":"sessions/session-05/#lab-2-line-follower-with-state-machine","title":"Lab 2 \u2013 Line-follower with State Machine","text":""},{"location":"sessions/session-05/#objectives","title":"Objectives","text":"<p>The goal of this lab is to learn more about controllers in Webots via the implementation of state machine to make the robot follow a line. </p>"},{"location":"sessions/session-05/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>You must have Webots R2022a (or newer) properly configured to work with Python. </li> <li>You must know how to create a robot controller in Python and how to run a simulation. </li> </ul> <p>If you are still missing any of those, please go back to Lab 1 and complete the corresponding tasks.</p>"},{"location":"sessions/session-05/#the-e-puck-robot","title":"The e-puck robot","text":"<p>Webots contains a realistic model of e-puck, a small differential-drive mobile robot. The movement of this type of robot is controlled by independently adjusting the speeds of the left and right wheels. </p> <p>The e-puck robot has multiple sensors. To detect obstacles, the e-puck contains 8 infrared distance sensors around its body. Optionally, 3 infrared sensors can be mounted under its base, pointing to the floor, allowing the implementation of a line-following behavior. </p> <p>An explanation about the e-puck robot and how to use it in Webots is available in Webots Tutorial 4.</p>"},{"location":"sessions/session-05/#tasks","title":"Tasks","text":"<p>1- Follow Webots Tutorial 4 to better understand the e-puck model and learn how to control it in Python.</p> <p>2- After finishing tutorial 4, open the line-following sample world: Click on <code>File &gt; Open Sample Worlds</code> and go to <code>robots &gt; gctronic &gt; e-puck</code> and select <code>e-puck_botstudio_with_floor_sensors.wbt</code>. You should see a world similar to the one shown in Figure 1. In the next steps you must use the e-puck robot that is loaded with this sample world because it has the floor sensors to detect the line. </p> <p></p>"},{"location":"sessions/session-05/#figure-1-webots-screenshot-with-the-world-e-puck_botstudio_with_floor_sensorswbt","title":"Figure 1. Webots screenshot with the world \u201ce-puck_botstudio_with_floor_sensors.wbt\u201d.","text":"<p>3- You will need to make changes to the file, so you have to save the sample world with a different name on a folder of your choice. </p> <p>4- Write a simple program to investigate the values returned by the floor sensors when the robot is over the white floor and over the black line. You can use the print function to show the sensor values in the Webots console. More information about how to read the ground sensors is given below.</p> <p>5- Test the motor speeds to determine how fast the robot should run and turn in order to follow the line.</p> <p>6- Create a new controller in Python and implement a line-following behavior using what you learned from the steps above. You can use the state machine shown in Figure 2 as reference. </p> <p>7- Finally, add one extra state to stop the robot when no line is detected.</p> <p></p>"},{"location":"sessions/session-05/#figure-2-a-state-machine-diagram-that-implements-a-line-follower-behavior","title":"Figure 2. A state machine diagram that implements a line-follower behavior.","text":""},{"location":"sessions/session-05/#ground-sensors","title":"Ground sensors","text":"<p>In Tutorial 4 you made use of the distance sensors around the robot. To detect the line on the floor you need to use the ground sensors, instead. The simulator also treats the ground sensors as distance sensors because they are of the same type (infrared sensors). In Python you can access the ground sensors as shown below.</p> <p>To initialize the ground sensors: </p><pre><code>gs = []\ngsNames = ['gs0', 'gs1', 'gs2']\nfor i in range(3):\n    gs.append(robot.getDevice(gsNames[i]))\n    gs[i].enable(timestep)\n</code></pre> <p>To read the ground sensors inside the main loop: </p><pre><code>gsValues = []\nfor i in range(3):\n    gsValues.append(gs[i].getValue())\n</code></pre> <p>To read sensor values inside the main loop: </p><pre><code>line_right = gsValues[0]\nline_center = gsValues[1]\nline_left = gsValues[2]\n</code></pre> <p>If you need inspiration, check the template code available here!</p>"},{"location":"sessions/session-05/#solution","title":"Solution","text":"<p>Try to implement the state machine yourself before checking the solution! A possible solution (without the stop state) is available here.</p> <p>The video below shows the solution code in action:</p> <p>.</p>"},{"location":"sessions/session-05/#challenge-obstacle-avoidance","title":"Challenge: Obstacle Avoidance","text":"<p>Change the state machine to make e-puck avoid obstacles placed on its way. You can choose the type of obstacle to add: different formats might require different strategies of obstacle avoidance. Obstacles with round or rectangular shape usually are the less demanding, while obstacles with U-shape require more complex strategies.</p> <p>An illustration of obstacle avoidance with state machine is given in Figure 3. Note that the obstacle avoidance strategy that was implemented required four extra states, some executing the same action as others. The animation in Figure 3 shows the active state (in red) for each condition during the simulation.</p> <p></p>"},{"location":"sessions/session-05/#figure-3-illustration-of-obstacle-avoidance-strategy-added-to-the-existing-line-follower-state-machine","title":"Figure 3. Illustration of obstacle avoidance strategy added to the existing line-follower state machine.","text":"<p>Student Wilfred van Reenen made the video below to illustrate the excellent performance of his obstacle avoidance state machine. If you want to go above and beyond, try to get your robot to avoid all those obstacles!</p> <p>.</p> <p>OOP Refactoring task</p>"},{"location":"sessions/session-05/#lab-2-object-oriented-programming-refactoring","title":"Lab 2: Object-Oriented Programming Refactoring","text":""},{"location":"sessions/session-05/#task-overview","title":"Task Overview","text":"<p>Refactor the provided procedural line-following robot code into an object-oriented design.</p>"},{"location":"sessions/session-05/#main-task","title":"Main Task","text":"<ol> <li>Complete the <code>LineFollowingRobot</code> class</li> <li>Fill in all <code>TODO</code> methods in the provided framework</li> <li>Move global variables into the class as instance variables</li> <li>Break the main loop into logical methods</li> <li>Test that your robot still follows lines correctly</li> </ol>"},{"location":"sessions/session-05/#learning-objectives_1","title":"Learning Objectives","text":"<ul> <li>Practice encapsulation (data and methods together)</li> <li>Learn to organize code into classes and methods</li> <li>Understand how OOP improves code structure and readability</li> </ul>"},{"location":"sessions/session-05/#line-following-robot-architecture","title":"Line-Following Robot Architecture","text":"<p>Our robot will use an object-oriented architecture with these main components:</p>"},{"location":"sessions/session-05/#line-following-architecture-uml-diagram","title":"Line-Following Architecture UML Diagram","text":"<pre><code>    classDiagram\n    class LineFollowingRobot {\n        -MAX_SPEED: float\n        -COUNTER_MAX: int\n        -current_state: str\n        -counter: int\n        -robot: WebotsRobot\n        -timestep: int\n        -ground_sensors: list\n        -leftMotor: Motor\n        -rightMotor: Motor\n        +__init__()\n        +read_sensors(): tuple\n        +move_forward()\n        +turn_right()\n        +turn_left()\n        +update_state(line_left: bool, line_right: bool)\n        +run()\n    }</code></pre>"},{"location":"sessions/session-05/#submission-template","title":"Submission template","text":"<pre><code># Lab 2: Object-Oriented Programming - Line Following Robot\n\n\nfrom controller import Robot as WebotsRobot, DistanceSensor, Motor\n\n\nclass LineFollowingRobot:\n    \"\"\"A simple robot that follows lines\"\"\"\n\n    def __init__(self):\n        \"\"\"Set up the robot and its sensors/motors\"\"\"\n        self.MAX_SPEED = 6.28\n        self.COUNTER_MAX = 5\n\n        # State variables\n        self.current_state = 'forward'\n        self.counter = 0\n\n        # TODO: Create robot instance\n\n        # TODO: Get timestep from robot\n\n        # TODO: Initialize ground sensors\n\n        # TODO: Initialize motors\n\n\n    def read_sensors(self):\n        \"\"\"Read ground sensors and return line detection\"\"\"\n        # TODO: Read ground sensor values\n\n        # TODO: Check if line is detected on left and right\n\n        # TODO: Return (line_left, line_right)\n\n\n    def move_forward(self):\n        \"\"\"Move robot forward\"\"\"\n        # TODO: Set motor speeds for forward movement\n\n\n    def turn_right(self):\n        \"\"\"Turn robot right\"\"\"\n        # TODO: Set motor speeds for right turn\n\n\n    def turn_left(self):\n        \"\"\"Turn robot left\"\"\"  \n        # TODO: Set motor speeds for left turn\n\n\n    def update_state(self, line_left, line_right):\n        \"\"\"Update robot state based on line detection\"\"\"\n        # TODO: Implement state machine logic\n\n\n    def run(self):\n        \"\"\"Main robot loop\"\"\"\n        # TODO: Implement main loop\n\n\n\n    # Run the robot\n    if __name__ == \"__main__\":\n        robot = LineFollowingRobot()\n        robot.run()\n</code></pre>"},{"location":"sessions/session-05/#deliverables","title":"Deliverables","text":"<ul> <li>Completed <code>LineFollowingRobot</code> class</li> <li>Working robot simulation</li> <li>Brief reflection: How does the OOP version compare to the original procedural code?</li> </ul>"},{"location":"sessions/session-05/#conclusion","title":"Conclusion","text":"<p>After following this lab you should know more about the e-puck robot model, how to program a controller for it in Python, and how to program a robot behavior based on state machine. </p>"},{"location":"sessions/session-05/#debugging-tips","title":"Debugging Tips","text":"<p>Common Issues and Solutions</p> <p>Robot doesn't move: Check that motors are properly initialized and <code>timestep</code> is correct</p> <p>Erratic behavior: Adjust the <code>base_speed</code> and <code>turn_speed</code> parameters</p> <p>Line not detected: Verify the sensor threshold values for your specific world</p> <p>Console spam: The debug output is limited to ~1 second intervals to keep it readable</p>"},{"location":"sessions/session-05/#extension-challenges","title":"Extension Challenges","text":"<p>Once you have the basic implementation working, try these enhancements:</p> <ol> <li>Add speed control: Make the robot slow down in tight turns</li> <li>Implement PID control: Use proportional, integral, and derivative control for smoother following</li> <li>Add line-lost recovery: Handle situations where the robot completely loses the line</li> <li>Implement different following modes: Allow switching between fast/slow/precise modes</li> </ol>"},{"location":"sessions/session-05/#session-summary-advanced-oop-features-in-robotics","title":"Session Summary: Advanced OOP Features in Robotics","text":"<p>In this session, you've learned how to make your robotics code more professional and maintainable through advanced OOP features:</p>"},{"location":"sessions/session-05/#key-concepts-mastered","title":"Key Concepts Mastered","text":"<pre><code>mindmap\n  root((Advanced OOP Features))\n    Magic Methods\n      __str__ for users\n      __repr__ for developers\n      Better debugging\n    Data Encapsulation\n      Traditional getters/setters\n      Property decorators\n      Data validation\n    Function Wrapping\n      Decorator foundations\n      Understanding @property\n      Code organization\n    Practical Application\n      Line following robot\n      Sensor fusion\n      Object-oriented architecture</code></pre>"},{"location":"sessions/session-05/#design-patterns-used","title":"Design Patterns Used","text":"<p>Throughout this session, we've implemented several important design patterns:</p> <ul> <li>Encapsulation: Hiding internal data and providing controlled access</li> <li>Composition: Building complex objects from simpler components</li> <li>Single Responsibility: Each class has one clear purpose</li> <li>Property Pattern: Clean attribute-like access with validation</li> </ul> <p>!!! success \"Professional Development\" The techniques learned in this session are used in production robotics software. You're now writing code that follows industry best practices!</p>"},{"location":"sessions/session-05/#out-of-class-research-activities","title":"Out-of-Class Research Activities","text":"<p>To reinforce your understanding and prepare for advanced topics:</p>"},{"location":"sessions/session-05/#research-topics","title":"Research Topics","text":"<ol> <li> <p>Python Magic Methods Deep Dive</p> <ul> <li>Research other useful magic methods (<code>__eq__</code>, <code>__lt__</code>, <code>__len__</code>)</li> <li>Find examples of magic methods in robotics frameworks</li> <li>Study how magic methods enable operator overloading</li> <li> <p>Property Decorators Advanced Usage</p> </li> <li> <p>Investigate read-only properties and computed properties</p> </li> <li>Research property caching for expensive calculations</li> <li>Look into property validation patterns</li> <li> <p>Robotics Control Systems</p> </li> <li> <p>Study PID controllers and their implementation in OOP</p> </li> <li>Research state machines for robot behavior</li> <li>Investigate sensor fusion algorithms and OOP design</li> <li> <p>Code Quality and Testing</p> </li> <li> <p>Research unit testing for robotics code</p> </li> <li>Study debugging techniques for real-time systems</li> <li>Investigate logging best practices for robotics applications</li> </ul> </li> </ol> <p>Recommended Resources</p> <ul> <li>Python official documentation on data model - Real Python articles on properties and magic methods  </li> <li>Open-source robotics projects showing OOP patterns - ROS (Robot Operating System) architectural documentation</li> </ul>"},{"location":"sessions/session-05/#next-session-preview","title":"Next Session Preview","text":"<p>Week 6: Inheritance &amp; Polymorphism</p> <ul> <li>Creating class hierarchies for different robot types</li> <li>Method overriding and super() usage</li> <li>Abstract base classes for robotics interfaces</li> <li>Polymorphic behavior in sensor and actuator systems</li> <li>Advanced UML diagrams and design patterns</li> </ul>"},{"location":"sessions/session-05/#further-reading","title":"Further Reading","text":"<ul> <li>Python Data Model Documentation</li> <li>Property Decorator Patterns</li> <li>Robotics Software Engineering Best Practices</li> <li>Object-Oriented Design Patterns in Robotics</li> </ul> <p>Navigation: \u2190 Week 4 | Learning Plan | Week 6 \u2192</p>"},{"location":"sessions/session-05_oop/","title":"Session 05 oop","text":""},{"location":"sessions/session-05_oop/#system-architecture-uml-diagram","title":"System Architecture UML Diagram","text":"<pre><code>classDiagram\n    class LineFollowerRobot {\n        -DistanceSensors distance_sensors\n        -GroundSensors ground_sensors  \n        -WheelMotors motors\n        +__init__()\n        +run()\n        +__str__()\n        +__repr__()\n    }\n\n    class DistanceSensors {\n        -list sensor_objects\n        +__init__(robot)\n        +get_readings()\n        +detect_obstacle()\n        +__str__()\n    }\n\n    class GroundSensors {\n        -list sensor_objects\n        +__init__(robot) \n        +get_readings()\n        +detect_line()\n        +calculate_line_position()\n        +__str__()\n    }\n\n    class WheelMotors {\n        -Motor left_motor\n        -Motor right_motor\n        -float _max_speed\n        +__init__(robot)\n        +set_speeds(left, right)\n        +stop()\n        +speed: float\n        +__str__()\n    }\n\n    LineFollowerRobot --&gt; DistanceSensors : uses\n    LineFollowerRobot --&gt; GroundSensors : uses  \n    LineFollowerRobot --&gt; WheelMotors : uses\n\n    note for LineFollowerRobot \"Main controller coordinating\\nall robot subsystems\"\n    note for DistanceSensors \"Manages IR distance sensors\\nfor obstacle detection\"\n    note for GroundSensors \"Manages ground-facing sensors\\nfor line detection\"\n    note for WheelMotors \"Controls left and right wheel\\nmotors with speed validation\"</code></pre>"},{"location":"sessions/session-05_oop/#step-1-ground-sensors-class-implementation","title":"Step 1: Ground Sensors Class Implementation","text":"<p>The ground sensors detect the line by measuring light reflection from the ground. Dark lines reflect less light than the surrounding surface.</p> <pre><code>class GroundSensors:\n    \"\"\"Manages ground-facing sensors for line detection.\"\"\"\n\n    def __init__(self, robot):\n        \"\"\"\n        Initialize ground sensors.\n\n        Args:\n            robot: Webots robot object\n        \"\"\"\n        # Get ground sensor objects from Webots\n        self.sensors = []\n        sensor_names = ['gs0', 'gs1', 'gs2']  # Ground sensor names in Webots\n\n        for name in sensor_names:\n            sensor = robot.getDevice(name)\n            sensor.enable(robot.timestep)\n            self.sensors.append(sensor)\n\n        self.num_sensors = len(self.sensors)\n        print(f\"Ground sensors initialized: {self.num_sensors} sensors\")\n\n    @property\n    def readings(self):\n        \"\"\"\n        Get current sensor readings.\n\n        Returns:\n            list: List of sensor values (higher = lighter surface)\n        \"\"\"\n        return [sensor.getValue() for sensor in self.sensors]\n\n    def detect_line(self, threshold=500):\n        \"\"\"\n        Detect if any sensor sees the line.\n\n        Args:\n            threshold (float): Value below which we consider line detected\n\n        Returns:\n            bool: True if line is detected by any sensor\n        \"\"\"\n        readings = self.readings\n        return any(reading &lt; threshold for reading in readings)\n\n    def calculate_line_position(self, threshold=500):\n        \"\"\"\n        Calculate line position relative to robot center.\n\n        Args:\n            threshold (float): Line detection threshold\n\n        Returns:\n            float: Position from -1.0 (far left) to 1.0 (far right), 0.0 = center\n        \"\"\"\n        readings = self.readings\n\n        # Convert readings to binary (0 = line, 1 = no line)\n        binary_readings = [1 if reading &lt; threshold else 0 for reading in readings]\n\n        # Calculate weighted average position\n        if sum(binary_readings) == 0:\n            return 0.0  # No line detected, assume center\n\n        total_weight = 0\n        weighted_sum = 0\n\n        for i, reading in enumerate(binary_readings):\n            if reading == 1:  # Line detected\n                position = (i - (self.num_sensors - 1) / 2) / ((self.num_sensors - 1) / 2)\n                weighted_sum += position * reading\n                total_weight += reading\n\n        return weighted_sum / total_weight if total_weight &gt; 0 else 0.0\n\n    def __str__(self):\n        \"\"\"User-friendly sensor status.\"\"\"\n        readings = self.readings\n        return f\"Ground Sensors: {[f'{r:.0f}' for r in readings]} (line detected: {self.detect_line()})\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return f\"GroundSensors(num_sensors={self.num_sensors})\"\n</code></pre>"},{"location":"sessions/session-05_oop/#step-2-distance-sensors-class-implementation","title":"Step 2: Distance Sensors Class Implementation","text":"<p>The distance sensors detect obstacles in front of the robot.</p> <pre><code>class DistanceSensors:\n    \"\"\"Manages IR distance sensors for obstacle detection.\"\"\"\n\n    def __init__(self, robot):\n        \"\"\"\n        Initialize distance sensors.\n\n        Args:\n            robot: Webots robot object\n        \"\"\"\n        # Get distance sensor objects from Webots  \n        self.sensors = []\n        sensor_names = ['ps0', 'ps1', 'ps2', 'ps5', 'ps6', 'ps7']  # Front-facing sensors\n\n        for name in sensor_names:\n            sensor = robot.getDevice(name)\n            sensor.enable(robot.timestep)\n            self.sensors.append(sensor)\n\n        print(f\"Distance sensors initialized: {len(self.sensors)} sensors\")\n\n    @property  \n    def readings(self):\n        \"\"\"\n        Get current sensor readings.\n\n        Returns:\n            list: List of sensor values (higher = closer object)\n        \"\"\"\n        return [sensor.getValue() for sensor in self.sensors]\n\n    def detect_obstacle(self, threshold=100):\n        \"\"\"\n        Detect if obstacle is too close.\n\n        Args:\n            threshold (float): Distance threshold for obstacle detection\n\n        Returns:\n            bool: True if obstacle detected\n        \"\"\"\n        front_sensors = self.readings[1:5]  # Use middle sensors\n        return any(reading &gt; threshold for reading in front_sensors)\n\n    def __str__(self):\n        \"\"\"User-friendly sensor status.\"\"\"\n        readings = self.readings\n        obstacle = \"YES\" if self.detect_obstacle() else \"NO\"\n        return f\"Distance Sensors: obstacle={obstacle}, readings={[f'{r:.0f}' for r in readings[:3]]}\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return f\"DistanceSensors(num_sensors={len(self.sensors)})\"\n</code></pre>"},{"location":"sessions/session-05_oop/#step-3-motor-controller-class-implementation","title":"Step 3: Motor Controller Class Implementation","text":"<p>The motor controller manages wheel speeds and implements the control algorithm.</p> <pre><code>class WheelMotors:\n    \"\"\"Controls robot wheel motors with validation.\"\"\"\n\n    def __init__(self, robot, max_speed=6.28):\n        \"\"\"\n        Initialize wheel motors.\n\n        Args:\n            robot: Webots robot object\n            max_speed (float): Maximum wheel speed in rad/s\n        \"\"\"\n        # Get motor objects from Webots\n        self.left_motor = robot.getDevice('left wheel motor')\n        self.right_motor = robot.getDevice('right wheel motor')\n\n        # Set motors to velocity control mode\n        self.left_motor.setPosition(float('inf'))\n        self.right_motor.setPosition(float('inf'))\n\n        self._max_speed = max_speed\n        self._current_left_speed = 0.0\n        self._current_right_speed = 0.0\n\n        print(f\"Motors initialized with max speed: {max_speed} rad/s\")\n\n    @property\n    def max_speed(self):\n        \"\"\"Get maximum motor speed.\"\"\"\n        return self._max_speed\n\n    @property  \n    def speeds(self):\n        \"\"\"Get current motor speeds as tuple (left, right).\"\"\"\n        return (self._current_left_speed, self._current_right_speed)\n\n    def set_speeds(self, left_speed, right_speed):\n        \"\"\"\n        Set motor speeds with validation.\n\n        Args:\n            left_speed (float): Left wheel speed (-max_speed to +max_speed)\n            right_speed (float): Right wheel speed (-max_speed to +max_speed)\n        \"\"\"\n        # Validate and clamp speeds\n        left_speed = max(-self._max_speed, min(self._max_speed, left_speed))\n        right_speed = max(-self._max_speed, min(self._max_speed, right_speed))\n\n        # Apply speeds to motors\n        self.left_motor.setVelocity(left_speed)\n        self.right_motor.setVelocity(right_speed)\n\n        # Store current speeds\n        self._current_left_speed = left_speed\n        self._current_right_speed = right_speed\n\n    def stop(self):\n        \"\"\"Stop both motors.\"\"\"\n        self.set_speeds(0.0, 0.0)\n        print(\"Motors stopped\")\n\n    def __str__(self):\n        \"\"\"User-friendly motor status.\"\"\"\n        left, right = self.speeds\n        return f\"Motors: L={left:.2f}, R={right:.2f} (max: {self._max_speed:.2f} rad/s)\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return f\"WheelMotors(max_speed={self._max_speed})\"\n</code></pre>"},{"location":"sessions/session-05_oop/#step-4-main-line-follower-robot-class","title":"Step 4: Main Line Follower Robot Class","text":"<p>Now we'll create the main robot class that coordinates all subsystems.</p> <pre><code>from controller import Robot\n\nclass LineFollowerRobot:\n    \"\"\"Main line-following robot controller.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the line follower robot.\"\"\"\n        # Initialize Webots robot\n        self.robot = Robot()\n        self.timestep = int(self.robot.getBasicTimeStep())\n\n        # Initialize subsystems  \n        self.ground_sensors = GroundSensors(self.robot)\n        self.distance_sensors = DistanceSensors(self.robot)\n        self.motors = WheelMotors(self.robot)\n\n        # Control parameters\n        self.base_speed = 3.0      # Base forward speed\n        self.turn_speed = 2.0      # Speed adjustment for turning\n\n        print(\"Line follower robot initialized successfully!\")\n\n    def calculate_motor_speeds(self, line_position):\n        \"\"\"\n        Calculate motor speeds based on line position.\n\n        Args:\n            line_position (float): Line position from -1.0 to 1.0\n\n        Returns:\n            tuple: (left_speed, right_speed)\n        \"\"\"\n        # PID-like control: stronger turning for larger errors\n        error = line_position\n        turn_adjustment = error * self.turn_speed\n\n        # Calculate individual wheel speeds\n        left_speed = self.base_speed - turn_adjustment\n        right_speed = self.base_speed + turn_adjustment\n\n        return (left_speed, right_speed)\n\n    def run(self):\n        \"\"\"Main control loop.\"\"\"\n        print(\"Starting line following behavior...\")\n        print(\"Use Ctrl+C to stop the robot\")\n\n        try:\n            while self.robot.step(self.timestep) != -1:\n                # Check for obstacles first\n                if self.distance_sensors.detect_obstacle():\n                    print(\"Obstacle detected! Stopping robot.\")\n                    self.motors.stop()\n                    continue\n\n                # Get line position\n                line_position = self.ground_sensors.calculate_line_position()\n\n                # Calculate and apply motor speeds\n                left_speed, right_speed = self.calculate_motor_speeds(line_position)\n                self.motors.set_speeds(left_speed, right_speed)\n\n                # Debug output every 50 steps (reduce console spam)\n                if self.robot.getTime() % 1.0 &lt; self.timestep / 1000.0:  # Every ~1 second\n                    print(f\"Line pos: {line_position:+.2f}, Motors: L={left_speed:.2f} R={right_speed:.2f}\")\n                    print(f\"  {self.ground_sensors}\")\n                    print(f\"  {self.distance_sensors}\")\n                    print()\n\n        except KeyboardInterrupt:\n            print(\"\\nRobot stopped by user\")\n            self.motors.stop()\n\n    def __str__(self):\n        \"\"\"User-friendly robot status.\"\"\"\n        return f\"LineFollowerRobot: base_speed={self.base_speed}, turn_speed={self.turn_speed}\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return \"LineFollowerRobot()\"\n\n# Main execution\nif __name__ == \"__main__\":\n    # Create and run the robot\n    robot = LineFollowerRobot()\n    print(robot)\n    print(repr(robot))\n    robot.run()\n</code></pre>"},{"location":"sessions/session-05_oop/#step-5-complete-implementation","title":"Step 5: Complete Implementation","text":"<p>Here's how to put it all together in a single file (<code>line_follower_robot.py</code>):</p> <pre><code>\"\"\"\nLine Following Robot Implementation\nUses object-oriented programming principles for modular robotics code.\n\"\"\"\n\nfrom controller import Robot\n\n# [Include all the class implementations above in order:]\n# 1. GroundSensors class\n# 2. DistanceSensors class  \n# 3. WheelMotors class\n# 4. LineFollowerRobot class\n# 5. Main execution code\n\n# Run the robot\nif __name__ == \"__main__\":\n    robot = LineFollowerRobot()\n    robot.run()\n</code></pre>"},{"location":"sessions/session-06/","title":"Week 6 - Inheritance & Polymorphism","text":""},{"location":"sessions/session-06/#session-6-inheritance-polymorphism","title":"Session 6: Inheritance &amp; Polymorphism","text":"<p>Week: 6 Element: ICTPRG430 Element 2.1 Duration: 4 hours Phase: Object-Oriented Programming Theory</p>"},{"location":"sessions/session-06/#session-introduction","title":"Session Introduction","text":"<p>In this session, you will deepen your understanding of Object-Oriented Programming (OOP) by exploring two fundamental tenets: Inheritance and Polymorphism. This builds on the foundational concepts from Session 4 and advanced class features from Session 5. You will learn how to structure your robot software to maximize code reuse through inheritance, applying the \"is-a\" relationship for specialized robot types, and how to define flexible interfaces using polymorphism.</p> <p>Crucially, we will delve into the powerful design principle of favoring composition over inheritance (the \"has-a\" relationship) to create more robust and adaptable robotics systems. The session includes comprehensive theory, practical exercises to design robot hierarchies and polymorphic interfaces, and a live demonstration of advanced navigation algorithms using abstract base classes.</p>"},{"location":"sessions/session-06/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this session, you will be able to:</p> <ul> <li>Understand and implement class inheritance hierarchies for different robot types</li> <li>Apply method overriding and the <code>super()</code> function appropriately</li> <li>Implement polymorphic interfaces for code extensibility and flexible robot behaviors</li> <li>Analyze and apply the \"is-a\" vs. \"has-a\" relationships, favoring composition over inheritance in design</li> <li>Design and utilize abstract base classes to define clear contracts for robot components</li> </ul>"},{"location":"sessions/session-06/#session-structure","title":"Session Structure","text":"<ol> <li>Theory Session - Inheritance and Polymorphism Fundamentals</li> <li>Hands-on Exercise - Designing Robot Hierarchies and Polymorphic Interfaces</li> <li>Data Encapsulation Deep-dive - Refactoring for Composition</li> <li>Live Demonstration - Polymorphic Navigation Strategies using ABCs</li> <li>Extension Activity - Understanding Multiple Inheritance and MRO</li> </ol>"},{"location":"sessions/session-06/#session-overview","title":"Session Overview","text":"<p>This session builds on the foundational OOP concepts from Session 4 and advanced class features introduced in Session 5, focusing on two core tenets of OOP: Inheritance and Polymorphism. You will learn how to structure your robot software for reusability and flexibility by applying \"is-a\" and \"has-a\" relationships, with a particular emphasis on composition as a design principle.</p>"},{"location":"sessions/session-06/#pre-session-preparation","title":"Pre-Session Preparation","text":"<p>Required Reading</p> <p>Review the following materials before class:</p> <pre><code>- Review \"Object Model &amp; Class Fundamentals\" (Session 4)\n- Review \"Advanced Class Features &amp; Magic Methods\" (Session 5)\n</code></pre> <p>Setup Check</p> <p>Ensure your Python development environment and Webots simulator are configured and working from Session 4.</p>"},{"location":"sessions/session-06/#1-introduction-to-inheritance-the-is-a-relationship","title":"1. Introduction to Inheritance: The \"Is-A\" Relationship","text":"<p>Inheritance is a fundamental principle of OOP that allows a class to acquire attributes (methods and instance variables) from another class. This creates a parent-child relationship between classes, or more formally, a superclass/subclass relationship.</p> <p></p> <p>The subclass inherits from the superclass, meaning it gains access to the superclass's methods and properties, promoting code reuse and reducing duplication. Inheritance models the \"is-a\" relationship. For example, a <code>LineFollowingRobot</code> is a type of <code>RobotController</code>.</p>"},{"location":"sessions/session-06/#basic-inheritance-syntax","title":"Basic Inheritance Syntax","text":"<p>Python Syntax: To create a child class, you put the name of the existing parent class in parentheses in the class statement.</p> <pre><code>class Vehicle:\n    def __init__(self, max_speed):\n        self.max_speed = max_speed\n        self.current_speed = 0.0\n\n    def drive(self):\n        print(f'I am driving at {self.current_speed} speed.')\n\n    def accelerate(self, speed_increase):\n        self.current_speed = min(self.current_speed + speed_increase, self.max_speed)\n        print(f'Accelerating to {self.current_speed}')\n\nclass Car(Vehicle):  # Car inherits from Vehicle\n    def __init__(self, max_speed, doors):\n        super().__init__(max_speed)  # Call parent constructor\n        self.doors = doors\n\n    def honk(self):\n        print('Beep beep!')\n\n# Usage\ncar = Car(120, 4)\ncar.drive()        # Inherited method: I am driving at 0.0 speed.\ncar.accelerate(50) # Inherited method: Accelerating to 50\ncar.honk()         # Own method: Beep beep!\n</code></pre>"},{"location":"sessions/session-06/#basic-inheritance-uml-diagram","title":"Basic Inheritance UML Diagram","text":"<pre><code>classDiagram\n    class Vehicle {\n        +float max_speed\n        +float current_speed\n        +__init__(max_speed: float)\n        +drive() void\n        +accelerate(speed_increase: float) void\n    }\n\n    class Car {\n        +int doors\n        +__init__(max_speed: float, doors: int)\n        +honk() void\n    }\n\n    Vehicle &lt;|-- Car : inherits\n\n    note for Vehicle \"Base class defining\\ncommon vehicle behavior\"\n    note for Car \"Specialized vehicle with\\nadditional car-specific features\"</code></pre> <p>This diagram illustrates <code>Car</code> inheriting from <code>Vehicle</code>, representing an \"is-a\" relationship where Car is a specialized type of Vehicle.</p>"},{"location":"sessions/session-06/#2-method-overriding-and-super","title":"2. Method Overriding and <code>super()</code>","text":"<p>Subclasses can override inherited methods to provide new or specialized implementations. Python checks the subclass first for a method; if found, it invokes that method instead of the superclass's version.</p> <pre><code>class Motorcycle(Vehicle):\n    def __init__(self, max_speed, engine_type):\n        super().__init__(max_speed)\n        self.engine_type = engine_type\n\n    def drive(self):  # Overrides Vehicle's drive method\n        print(f'I am riding my {self.engine_type} motorcycle at {self.current_speed} speed!')\n\n    def wheelie(self):\n        if self.current_speed &gt; 20:\n            print('Performing a wheelie! \ud83c\udfcd\ufe0f')\n        else:\n            print('Need more speed for a wheelie')\n\n# Usage\nmotorcycle = Motorcycle(180, \"V-twin\")\nmotorcycle.accelerate(30)\nmotorcycle.drive()    # Output: I am riding my V-twin motorcycle at 30 speed!\nmotorcycle.wheelie()  # Output: Performing a wheelie! \ud83c\udfcd\ufe0f\n</code></pre>"},{"location":"sessions/session-06/#the-super-function","title":"The <code>super()</code> Function","text":"<p>The <code>super()</code> function allows you to call methods from the parent (superclass) within the subclass. This is particularly useful in <code>__init__</code> methods to ensure the parent class is properly initialized.</p> <pre><code>class ElectricCar(Car):\n    def __init__(self, max_speed, doors, battery_capacity):\n        super().__init__(max_speed, doors)  # Calls Car's __init__\n        self.battery_capacity = battery_capacity\n        self.charge_level = 100.0\n\n    def drive(self):\n        if self.charge_level &gt; 0:\n            super().drive()  # Call parent's drive method\n            self.charge_level -= 1\n            print(f'Battery level: {self.charge_level}%')\n        else:\n            print('Battery empty! Please recharge.')\n\n    def charge(self):\n        self.charge_level = 100.0\n        print('Fully charged!')\n</code></pre>"},{"location":"sessions/session-06/#robotics-example-enhanced-sensor-hierarchy","title":"Robotics Example: Enhanced Sensor Hierarchy","text":"<p>Building on Session 5's <code>IRSensor</code>, let's create a sensor hierarchy:</p> <pre><code>import random\nfrom abc import ABC, abstractmethod\n\nclass Sensor(ABC):\n    \"\"\"Base sensor class with common functionality.\"\"\"\n\n    def __init__(self, name, sensor_type):\n        self.name = name\n        self.sensor_type = sensor_type\n        self._last_reading = None\n        self._is_active = True\n\n    def get_status(self):\n        \"\"\"Get common sensor status information.\"\"\"\n        status = \"ACTIVE\" if self._is_active else \"INACTIVE\"\n        reading = self._last_reading if self._last_reading is not None else \"No data\"\n        return f\"{self.sensor_type} '{self.name}': {status} (Last: {reading})\"\n\n    @abstractmethod\n    def read_value(self):\n        \"\"\"Abstract method - must be implemented by subclasses.\"\"\"\n        pass\n\n    def calibrate(self):\n        \"\"\"Default calibration routine.\"\"\"\n        print(f\"Calibrating {self.sensor_type} sensor '{self.name}'...\")\n        return True\n\nclass IRSensor(Sensor):\n    \"\"\"Infrared distance sensor implementation.\"\"\"\n\n    def __init__(self, name):\n        super().__init__(name, \"IR Distance\")  # Call parent constructor\n        self.min_range = 1\n        self.max_range = 100\n\n    def read_value(self):\n        \"\"\"Read IR distance value.\"\"\"\n        if self._is_active:\n            self._last_reading = random.randint(self.min_range, self.max_range)\n            print(f\"{self.name} sensor reading: {self._last_reading} cm\")\n            return self._last_reading\n        return None\n\n    def __str__(self):\n        reading_str = f\"{self._last_reading} cm\" if self._last_reading else \"No readings\"\n        return f\"{self.name} IR Sensor: {reading_str}\"\n\nclass LIDARSensor(Sensor):\n    \"\"\"LIDAR sensor implementation with enhanced capabilities.\"\"\"\n\n    def __init__(self, name, scan_range=360):\n        super().__init__(name, \"LIDAR\")\n        self.scan_range = scan_range\n        self.resolution = 1.0  # degrees per measurement\n\n    def read_value(self):\n        \"\"\"Read LIDAR scan data.\"\"\"\n        if self._is_active:\n            # Simulate LIDAR returning multiple distance measurements\n            num_points = int(self.scan_range / self.resolution)\n            scan_data = [random.randint(10, 500) for _ in range(num_points)]\n            self._last_reading = {\n                'points': len(scan_data),\n                'min_distance': min(scan_data),\n                'max_distance': max(scan_data),\n                'average_distance': sum(scan_data) / len(scan_data)\n            }\n            print(f\"{self.name} LIDAR scan complete: {self._last_reading['points']} points\")\n            return self._last_reading\n        return None\n\n    def calibrate(self):\n        \"\"\"Override with LIDAR-specific calibration.\"\"\"\n        super().calibrate()  # Call parent calibration\n        print(f\"Performing LIDAR-specific calibration for {self.scan_range}\u00b0 range\")\n        return True\n</code></pre>"},{"location":"sessions/session-06/#sensor-hierarchy-uml-diagram","title":"Sensor Hierarchy UML Diagram","text":"<pre><code>classDiagram\n    class Sensor {\n        &lt;&lt;abstract&gt;&gt;\n        #str name\n        #str sensor_type\n        #object _last_reading\n        #bool _is_active\n        +__init__(name: str, sensor_type: str)\n        +get_status() str\n        +calibrate() bool\n        +read_value()* object\n    }\n\n    class IRSensor {\n        +int min_range\n        +int max_range\n        +__init__(name: str)\n        +read_value() int\n        +__str__() str\n    }\n\n    class LIDARSensor {\n        +int scan_range\n        +float resolution\n        +__init__(name: str, scan_range: int)\n        +read_value() dict\n        +calibrate() bool\n    }\n\n    Sensor &lt;|-- IRSensor : inherits\n    Sensor &lt;|-- LIDARSensor : inherits\n\n    note for Sensor \"Abstract base class\\ndefines sensor interface\"\n    note for IRSensor \"Simple distance sensor\\nfrom Session 5\"\n    note for LIDARSensor \"Advanced sensor with\\noverride behavior\"</code></pre>"},{"location":"sessions/session-06/#3-polymorphism-responding-to-a-common-interface","title":"3. Polymorphism: Responding to a Common Interface","text":"<p>Polymorphism (meaning \"many forms\") is the ability for different objects to respond to the same method call, each in their own way, without the calling code needing to know the specific type of the object.</p> <p>In Python, polymorphism is often achieved through duck typing: \"If it walks like a duck and quacks like a duck, it's a duck.\" This means that as long as objects provide the required methods (interface), they can be used interchangeably.</p>"},{"location":"sessions/session-06/#benefits-in-robotics","title":"Benefits in Robotics","text":"<p>This allows for flexible robot behaviors, where different sensor types (e.g., IR, LIDAR, Camera) can all implement a <code>read_value()</code> method, and a <code>RobotController</code> can simply call <code>sensor.read_value()</code> without knowing the sensor's exact type.</p>"},{"location":"sessions/session-06/#polymorphic-example-sensor-array","title":"Polymorphic Example: Sensor Array","text":"<pre><code>class SensorArray:\n    \"\"\"Manages multiple sensors polymorphically.\"\"\"\n\n    def __init__(self):\n        self.sensors = []\n\n    def add_sensor(self, sensor):\n        \"\"\"Add any type of sensor to the array.\"\"\"\n        if hasattr(sensor, 'read_value'):  # Duck typing check\n            self.sensors.append(sensor)\n            print(f\"Added {sensor.sensor_type} sensor: {sensor.name}\")\n        else:\n            raise ValueError(\"Object must have a read_value method\")\n\n    def read_all_sensors(self):\n        \"\"\"Read all sensors polymorphically.\"\"\"\n        readings = {}\n        for sensor in self.sensors:\n            # Polymorphism in action - same method call, different behavior\n            readings[sensor.name] = sensor.read_value()\n        return readings\n\n    def calibrate_all_sensors(self):\n        \"\"\"Calibrate all sensors.\"\"\"\n        for sensor in self.sensors:\n            sensor.calibrate()  # Each sensor may calibrate differently\n\n    def get_sensor_status_report(self):\n        \"\"\"Generate comprehensive status report.\"\"\"\n        print(\"=== SENSOR ARRAY STATUS ===\")\n        for sensor in self.sensors:\n            print(sensor.get_status())\n\n# Usage example demonstrating polymorphism\nif __name__ == \"__main__\":\n    # Create sensor array\n    robot_sensors = SensorArray()\n\n    # Add different types of sensors\n    robot_sensors.add_sensor(IRSensor(\"Front Left\"))\n    robot_sensors.add_sensor(IRSensor(\"Front Right\"))\n    robot_sensors.add_sensor(LIDARSensor(\"Main LIDAR\", 270))\n\n    print(\"\\n\" + \"=\"*40)\n    print(\"DEMONSTRATING POLYMORPHISM\")\n    print(\"=\"*40)\n\n    # Polymorphic behavior - same method call, different implementations\n    all_readings = robot_sensors.read_all_sensors()\n    print(f\"\\nCollected readings from {len(all_readings)} sensors\")\n\n    # Status report\n    print()\n    robot_sensors.get_sensor_status_report()\n\n    print(\"\\n\" + \"=\"*40)\n    print(\"CALIBRATION (Polymorphic)\")\n    print(\"=\"*40)\n    robot_sensors.calibrate_all_sensors()\n</code></pre>"},{"location":"sessions/session-06/#polymorphism-uml-diagram","title":"Polymorphism UML Diagram","text":"<pre><code>classDiagram\n    class SensorArray {\n        -list~Sensor~ sensors\n        +add_sensor(sensor: Sensor) void\n        +read_all_sensors() dict\n        +calibrate_all_sensors() void\n        +get_sensor_status_report() void\n    }\n\n    class Sensor {\n        &lt;&lt;interface&gt;&gt;\n        +read_value() object\n        +calibrate() bool\n        +get_status() str\n    }\n\n    class IRSensor {\n        +read_value() int\n        +calibrate() bool\n        +get_status() str\n    }\n\n    class LIDARSensor {\n        +read_value() dict\n        +calibrate() bool\n        +get_status() str\n    }\n\n    class CameraSensor {\n        +read_value() Image\n        +calibrate() bool\n        +get_status() str\n    }\n\n    SensorArray o-- Sensor : manages\n    Sensor &lt;|.. IRSensor : implements\n    Sensor &lt;|.. LIDARSensor : implements\n    Sensor &lt;|.. CameraSensor : implements\n\n    note for SensorArray \"Uses sensors polymorphically\\nwithout knowing their specific types\"\n    note for Sensor \"Common interface enables\\npolymorphic behavior\"</code></pre>"},{"location":"sessions/session-06/#4-composition-over-inheritance-the-has-a-relationship","title":"4. Composition Over Inheritance: The \"Has-A\" Relationship","text":"<p>While inheritance (the \"is-a\" relationship) is powerful, it can lead to rigid designs if overused. The principle of favoring composition over inheritance (COI) suggests that using a \"has-a\" relationship is often more flexible and safer.</p> <p></p> <p>Composition means that a class includes one or more objects of other classes as attributes, delegating responsibilities to these \"component\" objects. For example, a <code>Robot</code> has a <code>Motor</code>, has a <code>Sensor</code>, or has a <code>NavigationSystem</code>.</p>"},{"location":"sessions/session-06/#benefits-of-composition","title":"Benefits of Composition","text":"<ul> <li>Modularity: Components can be developed and tested independently</li> <li>Flexibility: Easy to swap components without changing the main class</li> <li>Loose Coupling: Changes to components don't break the main system</li> <li>Reusability: Components can be reused in different contexts</li> </ul>"},{"location":"sessions/session-06/#refactoring-example-robot-architecture","title":"Refactoring Example: Robot Architecture","text":"<p>Let's refactor a robotics system to use composition effectively:</p>"},{"location":"sessions/session-06/#initial-design-inheritance-heavy-less-flexible","title":"Initial Design (Inheritance-Heavy - Less Flexible)","text":"<pre><code># PROBLEMATIC APPROACH - Too much inheritance\nclass SensorProcessor:\n    def process_sensors(self):\n        pass\n\nclass LineFollowingRobot(SensorProcessor):  # Robot \"is-a\" sensor processor?\n    def move_along_line(self):\n        self.process_sensors()  # Tight coupling\n\nclass NavigationRobot(SensorProcessor):  # Robot \"is-a\" sensor processor?\n    def navigate_to_target(self):\n        self.process_sensors()  # Duplicated pattern\n</code></pre>"},{"location":"sessions/session-06/#improved-design-composition-more-flexible","title":"Improved Design (Composition - More Flexible)","text":"<pre><code>class SensorProcessor:\n    \"\"\"Handles sensor data processing and interpretation.\"\"\"\n\n    def __init__(self):\n        self.sensors = []\n        self.processing_algorithms = []\n\n    def add_sensor(self, sensor):\n        self.sensors.append(sensor)\n\n    def process_sensors(self):\n        \"\"\"Process all sensors and return interpreted data.\"\"\"\n        raw_data = {}\n        for sensor in self.sensors:\n            raw_data[sensor.name] = sensor.read_value()\n\n        # Process raw data into useful information\n        processed_data = self._interpret_sensor_data(raw_data)\n        return processed_data\n\n    def _interpret_sensor_data(self, raw_data):\n        \"\"\"Convert raw sensor data into actionable information.\"\"\"\n        # Placeholder for complex processing algorithms\n        return {\n            'obstacles_detected': any(reading &lt; 20 for reading in raw_data.values() if isinstance(reading, int)),\n            'clear_path_ahead': True,  # Simplified logic\n            'sensor_count': len(raw_data)\n        }\n\nclass MotorController:\n    \"\"\"Controls robot movement.\"\"\"\n\n    def __init__(self, max_speed=1.0):\n        self.max_speed = max_speed\n        self.current_speed = 0.0\n        self.direction = 0.0  # 0 = straight, -1 = left, 1 = right\n\n    def move_forward(self, speed=0.5):\n        self.current_speed = min(speed, self.max_speed)\n        self.direction = 0.0\n        print(f\"Moving forward at speed {self.current_speed}\")\n\n    def turn(self, direction, speed=0.3):\n        self.current_speed = min(speed, self.max_speed)\n        self.direction = direction\n        action = \"left\" if direction &lt; 0 else \"right\"\n        print(f\"Turning {action} at speed {self.current_speed}\")\n\n    def stop(self):\n        self.current_speed = 0.0\n        self.direction = 0.0\n        print(\"Motors stopped\")\n\nclass Robot:\n    \"\"\"Base robot using composition - Robot HAS-A sensor processor and motor controller.\"\"\"\n\n    def __init__(self, robot_id):\n        self.robot_id = robot_id\n        # Composition: Robot HAS-A sensor processor\n        self.sensor_processor = SensorProcessor()\n        # Composition: Robot HAS-A motor controller\n        self.motor_controller = MotorController()\n        self._is_running = False\n\n    def add_sensor(self, sensor):\n        \"\"\"Add a sensor to the robot's sensor processor.\"\"\"\n        self.sensor_processor.add_sensor(sensor)\n\n    def start(self):\n        self._is_running = True\n        print(f\"Robot {self.robot_id} started\")\n\n    def stop(self):\n        self._is_running = False\n        self.motor_controller.stop()\n        print(f\"Robot {self.robot_id} stopped\")\n\n    def get_sensor_data(self):\n        \"\"\"Delegate sensor processing to the sensor processor component.\"\"\"\n        return self.sensor_processor.process_sensors()\n\nclass LineFollowingRobot(Robot):\n    \"\"\"Specialized robot for line following - inherits from Robot, uses composition for capabilities.\"\"\"\n\n    def __init__(self, robot_id):\n        super().__init__(robot_id)\n        self.line_following_active = False\n        # Add appropriate sensors for line following\n        self.add_sensor(IRSensor(\"Left Line Sensor\"))\n        self.add_sensor(IRSensor(\"Center Line Sensor\"))\n        self.add_sensor(IRSensor(\"Right Line Sensor\"))\n\n    def start_line_following(self):\n        \"\"\"Start line following behavior.\"\"\"\n        self.line_following_active = True\n        self.start()\n        print(f\"Line following activated for {self.robot_id}\")\n\n    def move_along_line(self):\n        \"\"\"Use composition to coordinate line following.\"\"\"\n        if not self.line_following_active:\n            return\n\n        # Get processed sensor data from the sensor processor component\n        sensor_data = self.get_sensor_data()\n\n        # Make movement decisions based on processed data\n        if sensor_data['obstacles_detected']:\n            self.motor_controller.stop()\n            print(\"Line following paused - obstacle detected\")\n        else:\n            # Simplified line following logic\n            self.motor_controller.move_forward(0.4)\n            print(\"Following line...\")\n\nclass NavigationRobot(Robot):\n    \"\"\"Specialized robot for navigation - different specialization, same composition benefits.\"\"\"\n\n    def __init__(self, robot_id):\n        super().__init__(robot_id)\n        self.target_position = None\n        # Add appropriate sensors for navigation\n        self.add_sensor(LIDARSensor(\"Navigation LIDAR\"))\n        self.add_sensor(IRSensor(\"Front Obstacle Detector\"))\n\n    def set_target(self, x, y):\n        self.target_position = (x, y)\n        print(f\"Target set to ({x}, {y})\")\n\n    def navigate_to_target(self):\n        \"\"\"Navigate to target using sensor processor and motor controller components.\"\"\"\n        if not self.target_position:\n            print(\"No target set!\")\n            return\n\n        # Use the same sensor processor component, but for navigation\n        sensor_data = self.get_sensor_data()\n\n        if sensor_data['clear_path_ahead']:\n            self.motor_controller.move_forward(0.6)\n            print(f\"Navigating to {self.target_position}...\")\n        else:\n            self.motor_controller.turn(-0.5)  # Turn left to avoid obstacle\n            print(\"Avoiding obstacle during navigation\")\n</code></pre>"},{"location":"sessions/session-06/#composition-vs-inheritance-uml-diagram","title":"Composition vs Inheritance UML Diagram","text":"<pre><code>classDiagram\n    class Robot {\n        +str robot_id\n        +SensorProcessor sensor_processor\n        +MotorController motor_controller\n        +bool _is_running\n        +__init__(robot_id: str)\n        +add_sensor(sensor: Sensor) void\n        +start() void\n        +stop() void\n        +get_sensor_data() dict\n    }\n\n    class SensorProcessor {\n        +list~Sensor~ sensors\n        +list processing_algorithms\n        +add_sensor(sensor: Sensor) void\n        +process_sensors() dict\n        -_interpret_sensor_data(raw_data: dict) dict\n    }\n\n    class MotorController {\n        +float max_speed\n        +float current_speed\n        +float direction\n        +__init__(max_speed: float)\n        +move_forward(speed: float) void\n        +turn(direction: float, speed: float) void\n        +stop() void\n    }\n\n    class LineFollowingRobot {\n        +bool line_following_active\n        +start_line_following() void\n        +move_along_line() void\n    }\n\n    class NavigationRobot {\n        +tuple target_position\n        +set_target(x: float, y: float) void\n        +navigate_to_target() void\n    }\n\n    Robot *-- SensorProcessor : has-a (composition)\n    Robot *-- MotorController : has-a (composition)\n    Robot &lt;|-- LineFollowingRobot : is-a (inheritance)\n    Robot &lt;|-- NavigationRobot : is-a (inheritance)\n    SensorProcessor o-- Sensor : manages\n\n    note for Robot \"Uses composition for capabilities\\n(HAS-A relationship)\"\n    note for LineFollowingRobot \"Inherits robot structure\\nUses composed components\"\n    note for SensorProcessor \"Reusable component\\ncan be used by any robot\"</code></pre>"},{"location":"sessions/session-06/#composition-benefits-demonstration","title":"Composition Benefits Demonstration","text":"<pre><code># Usage example demonstrating flexibility of composition\nif __name__ == \"__main__\":\n    # Create different types of robots\n    line_robot = LineFollowingRobot(\"LineBot-01\")\n    nav_robot = NavigationRobot(\"NavBot-02\")\n\n    print(\"=== LINE FOLLOWING ROBOT ===\")\n    line_robot.start_line_following()\n    line_robot.move_along_line()\n\n    print(\"\\n=== NAVIGATION ROBOT ===\")\n    nav_robot.set_target(10.5, 7.2)\n    nav_robot.start()\n    nav_robot.navigate_to_target()\n\n    print(\"\\n=== COMPOSITION FLEXIBILITY ===\")\n    # Easy to add new sensors to existing robots\n    line_robot.add_sensor(LIDARSensor(\"Safety LIDAR\"))\n    nav_robot.add_sensor(IRSensor(\"Backup Sensor\"))\n\n    # Components can be replaced or modified independently\n    # For example, upgrading the motor controller:\n    print(\"Upgrading navigation robot motor controller...\")\n    nav_robot.motor_controller = MotorController(max_speed=1.5)  # Faster motors\n\n    print(\"Both robots benefit from the same sensor processing logic!\")\n</code></pre> <p>Key Insight</p> <p>Notice how both <code>LineFollowingRobot</code> and <code>NavigationRobot</code> can reuse the same <code>SensorProcessor</code> and <code>MotorController</code> components, but for different purposes. This is the power of composition - the components are decoupled and reusable!</p>"},{"location":"sessions/session-06/#5-abstract-base-classes-abcs-defining-contracts","title":"5. Abstract Base Classes (ABCs): Defining Contracts","text":"<p>Abstract classes are blueprints that cannot be instantiated directly but serve as templates for other classes. They are used to define a common interface (a set of methods that subclasses must implement) without providing a full implementation.</p> <p>In Python, Abstract Base Classes (ABCs) are created using the <code>abc</code> module and the <code>@abc.abstractmethod</code> decorator for abstract methods.</p>"},{"location":"sessions/session-06/#benefits-of-abcs","title":"Benefits of ABCs","text":"<ul> <li>Enforce contracts: Guarantee that subclasses implement required methods</li> <li>Support polymorphism: Enable different objects to share a common interface</li> <li>Documentation: Clearly define what methods a class family should provide</li> <li>Early error detection: Fail fast if required methods are not implemented</li> </ul>"},{"location":"sessions/session-06/#navigation-strategy-example","title":"Navigation Strategy Example","text":"<p>A robot navigation system might need different pathfinding algorithms (<code>DFS</code>, <code>BFS</code>, <code>A*</code>). An ABC can define the common interface for these strategies:</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import Tuple, List\n\nclass NavigationStrategy(ABC):\n    \"\"\"Abstract base class for robot navigation algorithms.\"\"\"\n\n    @abstractmethod\n    def find_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -&gt; List[Tuple[int, int]]:\n        \"\"\"Find path from start to goal. Must be implemented by subclasses.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_strategy_name(self) -&gt; str:\n        \"\"\"Return the name of this navigation strategy.\"\"\"\n        pass\n\nclass SimpleStrategy(NavigationStrategy):\n    \"\"\"Direct line navigation - ignores obstacles.\"\"\"\n\n    def find_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -&gt; List[Tuple[int, int]]:\n        print(f\"Simple: Moving directly from {start} to {goal}\")\n        return [start, goal]\n\n    def get_strategy_name(self) -&gt; str:\n        return \"Direct Line\"\n\nclass SmartStrategy(NavigationStrategy):\n    \"\"\"Advanced pathfinding with obstacle avoidance.\"\"\"\n\n    def find_path(self, start: Tuple[int, int], goal: Tuple[int, int]) -&gt; List[Tuple[int, int]]:\n        print(f\"Smart: Planning optimal route from {start} to {goal}\")\n        # Simulate pathfinding algorithm\n        waypoint = ((start[0] + goal[0]) // 2, (start[1] + goal[1]) // 2)\n        return [start, waypoint, goal]\n\n    def get_strategy_name(self) -&gt; str:\n        return \"A* Pathfinding\"\n\nclass Robot:\n    \"\"\"Robot that uses different navigation strategies polymorphically.\"\"\"\n\n    def __init__(self, name: str, strategy: NavigationStrategy):\n        self.name = name\n        self.strategy = strategy\n        self.position = (0, 0)\n\n    def navigate_to(self, target: Tuple[int, int]):\n        \"\"\"Navigate using current strategy - polymorphic behavior.\"\"\"\n        print(f\"\\n{self.name} using {self.strategy.get_strategy_name()}\")\n        path = self.strategy.find_path(self.position, target)\n        self.position = target\n        print(f\"Path: {' -&gt; '.join(map(str, path))}\")\n        return path\n\n    def change_strategy(self, new_strategy: NavigationStrategy):\n        \"\"\"Switch navigation algorithm at runtime.\"\"\"\n        self.strategy = new_strategy\n        print(f\"{self.name} switched to {self.strategy.get_strategy_name()}\")\n\n# Demo\nif __name__ == \"__main__\":\n    # Create robots with different strategies\n    scout = Robot(\"Scout\", SimpleStrategy())\n    explorer = Robot(\"Explorer\", SmartStrategy())\n\n    # Same interface, different behaviors (polymorphism)\n    target = (10, 15)\n    scout.navigate_to(target)\n    explorer.navigate_to(target)\n\n    # Runtime strategy switching\n    scout.change_strategy(SmartStrategy())\n    scout.navigate_to((20, 25))\n</code></pre>"},{"location":"sessions/session-06/#navigation-strategy-abc-uml-diagram","title":"Navigation Strategy ABC UML Diagram","text":"<pre><code>classDiagram\n    class NavigationStrategy {\n        &lt;&lt;abstract&gt;&gt;\n        +find_path(start, goal)* List~Tuple~\n        +get_strategy_name()* str\n    }\n\n    class SimpleStrategy {\n        +find_path(start, goal) List~Tuple~\n        +get_strategy_name() str\n    }\n\n    class SmartStrategy {\n        +find_path(start, goal) List~Tuple~\n        +get_strategy_name() str\n    }\n\n    class Robot {\n        -name: str\n        -strategy: NavigationStrategy\n        -position: Tuple~int, int~\n        +__init__(name, strategy)\n        +navigate_to(target) List~Tuple~\n        +change_strategy(new_strategy) void\n    }\n\n    NavigationStrategy &lt;|-- SimpleStrategy : implements\n    NavigationStrategy &lt;|-- SmartStrategy : implements\n    Robot o-- NavigationStrategy : uses\n\n    note for NavigationStrategy \"Abstract Base Class\\nDefines contract for\\nnavigation algorithms\"\n    note for Robot \"Uses Strategy pattern\\nwith polymorphism\"</code></pre> <p>ABC Benefits in Action</p>"},{"location":"sessions/session-06/#uderstanding-multiple-inheritance-and-mro","title":"Uderstanding Multiple Inheritance and MRO","text":"<p>Python supports multiple inheritance, where a class can inherit from multiple parent classes. While powerful, this can create complexity, particularly the \"diamond problem.\"</p>"},{"location":"sessions/session-06/#multiple-inheritance-example","title":"Multiple Inheritance Example","text":"<pre><code>class Pet:\n    def __init__(self, name):\n        self.name = name\n        print(f\"Pet.__init__: {name}\")\n\n    def play(self):\n        print(f'{self.name} is playing as a pet')\n\n    def show_affection(self):\n        print(f'{self.name} shows affection')\n\nclass Predator:\n    def __init__(self, hunting_skill):\n        self.hunting_skill = hunting_skill\n        print(f\"Predator.__init__: skill level {hunting_skill}\")\n\n    def hunt(self):\n        print(f'Hunting with skill level {self.hunting_skill}')\n\n    def show_aggression(self):\n        print('Showing predatory aggression')\n\nclass Cat(Pet, Predator):  # Multiple inheritance\n    def __init__(self, name, hunting_skill):\n        # Need to carefully manage multiple parent constructors\n        Pet.__init__(self, name)\n        Predator.__init__(self, hunting_skill)\n        print(f\"Cat.__init__: {name} created\")\n\n    def purr(self):\n        print(f'{self.name} is purring')\n\n    def play(self):\n        # Override Pet's play method\n        super().play()  # Calls Pet.play() due to MRO\n        print(f'{self.name} also stalks and pounces')\n\n# Usage\ncat = Cat(\"Whiskers\", 8)\nprint(f\"\\nMRO: {Cat.__mro__}\")\ncat.play()\ncat.hunt()\ncat.purr()\n</code></pre>"},{"location":"sessions/session-06/#method-resolution-order-mro","title":"Method Resolution Order (MRO)","text":"<p>Python uses the C3 linearization algorithm to determine the order in which methods are searched:</p> <pre><code># Check the MRO\nprint(\"Cat MRO:\", [cls.__name__ for cls in Cat.__mro__])\n# Output: Cat MRO: ['Cat', 'Pet', 'Predator', 'object']\n\n# You can also use:\nhelp(Cat)  # Shows detailed MRO information\n</code></pre>"},{"location":"sessions/session-06/#the-diamond-problem","title":"The Diamond Problem","text":"<pre><code>class Animal:\n    def __init__(self, species):\n        self.species = species\n        print(f\"Animal.__init__: {species}\")\n\n    def move(self):\n        print(\"Animal moves\")\n\nclass Mammal(Animal):\n    def __init__(self, species, fur_color):\n        super().__init__(species)\n        self.fur_color = fur_color\n        print(f\"Mammal.__init__: {fur_color} fur\")\n\n    def move(self):\n        print(\"Mammal walks on land\")\n\nclass Aquatic(Animal):\n    def __init__(self, species, water_type):\n        super().__init__(species)\n        self.water_type = water_type\n        print(f\"Aquatic.__init__: lives in {water_type}\")\n\n    def move(self):\n        print(\"Aquatic swims in water\")\n\nclass Whale(Mammal, Aquatic):  # Diamond inheritance\n    def __init__(self, species, fur_color, water_type, size):\n        # This is tricky! Need to handle diamond problem\n        Mammal.__init__(self, species, fur_color)\n        # Aquatic.__init__ would call Animal.__init__ again!\n        # Better approach using super():\n        self.water_type = water_type\n        self.size = size\n        print(f\"Whale.__init__: {size} whale created\")\n\n# Check MRO to understand method resolution\nprint(\"Whale MRO:\", [cls.__name__ for cls in Whale.__mro__])\n# Output: ['Whale', 'Mammal', 'Aquatic', 'Animal', 'object']\n\nwhale = Whale(\"Orca\", \"black\", \"ocean\", \"large\")\nwhale.move()  # Which move() method gets called?\n</code></pre>"},{"location":"sessions/session-06/#better-multiple-inheritance-with-super","title":"Better Multiple Inheritance with <code>super()</code>","text":"<pre><code>class Animal:\n    def __init__(self, species, **kwargs):\n        self.species = species\n        print(f\"Animal.__init__: {species}\")\n        super().__init__(**kwargs)  # Cooperative inheritance\n\nclass Mammal(Animal):\n    def __init__(self, fur_color, **kwargs):\n        self.fur_color = fur_color\n        print(f\"Mammal.__init__: {fur_color} fur\")\n        super().__init__(**kwargs)\n\nclass Aquatic(Animal):\n    def __init__(self, water_type, **kwargs):\n        self.water_type = water_type\n        print(f\"Aquatic.__init__: lives in {water_type}\")\n        super().__init__(**kwargs)\n\nclass Whale(Mammal, Aquatic):\n    def __init__(self, species, fur_color, water_type, size):\n        self.size = size\n        print(f\"Whale.__init__: {size} whale\")\n        # Using cooperative inheritance\n        super().__init__(\n            species=species,\n            fur_color=fur_color,\n            water_type=water_type\n        )\n\n# This approach avoids calling Animal.__init__ multiple times\nwhale = Whale(\"Blue Whale\", \"none\", \"ocean\", \"massive\")\n</code></pre>"},{"location":"sessions/session-06/#student-task-simple-robot-factory-system","title":"Student Task: Simple Robot Factory System","text":"<p>Create a simple robot factory system that demonstrates fundamental object-oriented programming concepts: inheritance, polymorphism, and basic composition.</p>"},{"location":"sessions/session-06/#task-requirements","title":"Task Requirements","text":"<p>!!! assignment \"Your Challenge\" Build a Robot Factory System that can create different types of robots and manage their basic operations.</p>"},{"location":"sessions/session-06/#what-you-need-to-create","title":"What You Need to Create","text":"<p>Part 1: Basic Robot Classes (Inheritance)</p> <p>Create these classes with the exact names and methods shown:</p> <pre><code># Base class - you need to implement all methods\nclass Robot:\n    def __init__(self, robot_id, robot_type):\n        # Store robot_id and robot_type\n        # Set initial position to (0, 0)\n        # Set battery_level to 100\n        pass\n\n    def move(self, distance):\n        # Print movement message\n        # Reduce battery by distance amount\n        pass\n\n    def get_info(self):\n        # Return string with robot info\n        pass\n\n    def recharge(self):\n        # Set battery back to 100\n        pass\n\n# Specialized robot types - inherit from Robot\nclass CleaningRobot(Robot):\n    def __init__(self, robot_id):\n        # Call parent constructor with \"Cleaning\" as robot_type\n        # Add cleaning_mode attribute (start with \"sweep\")\n        pass\n\n    def move(self, distance):\n        # Call parent move method\n        # Print additional cleaning message\n        pass\n\n    def clean(self, area):\n        # Print cleaning message for the area\n        # Reduce battery by 10\n        pass\n\nclass DeliveryRobot(Robot):\n    def __init__(self, robot_id):\n        # Call parent constructor with \"Delivery\" as robot_type  \n        # Add cargo attribute (start empty as None)\n        pass\n\n    def move(self, distance):\n        # Call parent move method\n        # If carrying cargo, print cargo transport message\n        pass\n\n    def load_cargo(self, item):\n        # Store item in cargo attribute\n        # Print loading message\n        pass\n\n    def deliver_cargo(self):\n        # If cargo exists, print delivery message and clear cargo\n        # If no cargo, print \"no cargo to deliver\"\n        pass\n</code></pre> <p>Part 2: Robot Factory (Composition &amp; Polymorphism)</p> <pre><code>class RobotFactory:\n    def __init__(self):\n        # Create empty list to store robots\n        pass\n\n    def create_robot(self, robot_type, robot_id):\n        # Create appropriate robot type based on robot_type parameter\n        # Add to robots list\n        # Return the created robot\n        pass\n\n    def get_all_robots(self):\n        # Return list of all robots\n        pass\n\n    def move_all_robots(self, distance):\n        # Make all robots move the same distance\n        # This demonstrates polymorphism - same method, different behavior\n        pass\n\n    def get_factory_report(self):\n        # Return string showing count of each robot type\n        pass\n</code></pre>"},{"location":"sessions/session-06/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<p>!!! info \"Implementation Steps\" 1. Start with the Robot base class - implement <code>__init__</code>, <code>move</code>, <code>get_info</code>, and <code>recharge</code> 2. Create CleaningRobot class - inherit from Robot and add cleaning functionality 3. Create DeliveryRobot class - inherit from Robot and add delivery functionality 4. Build RobotFactory class - use composition to manage multiple robots 5. Test your implementation using the test code provided below</p>"},{"location":"sessions/session-06/#testing-your-code","title":"Testing Your Code","text":"<p>Use this code to test your implementation:</p> <pre><code># Test your classes with this code\ndef test_robot_system():\n    # Create factory\n    factory = RobotFactory()\n\n    # Create different robots\n    cleaner1 = factory.create_robot(\"cleaning\", \"Clean-01\")\n    cleaner2 = factory.create_robot(\"cleaning\", \"Clean-02\") \n    delivery1 = factory.create_robot(\"delivery\", \"Deliver-01\")\n\n    print(\"=== INITIAL STATUS ===\")\n    for robot in factory.get_all_robots():\n        print(robot.get_info())\n\n    print(\"\\n=== TESTING MOVEMENT (Polymorphism) ===\")\n    factory.move_all_robots(5)  # All robots move, but differently\n\n    print(\"\\n=== TESTING SPECIALIZED METHODS ===\")\n    cleaner1.clean(\"Kitchen\")\n    delivery1.load_cargo(\"Package A\")\n    delivery1.move(3)\n    delivery1.deliver_cargo()\n\n    print(\"\\n=== FINAL STATUS ===\")\n    for robot in factory.get_all_robots():\n        print(robot.get_info())\n\n    print(f\"\\n=== FACTORY REPORT ===\")\n    print(factory.get_factory_report())\n\n# Run the test\ntest_robot_system()\n</code></pre>"},{"location":"sessions/session-06/#expected-output","title":"Expected Output","text":"<p>Your program should produce output similar to:</p> <pre><code>=== INITIAL STATUS ===\nRobot Clean-01 (Cleaning) at (0, 0), Battery: 100%\nRobot Clean-02 (Cleaning) at (0, 0), Battery: 100%\nRobot Deliver-01 (Delivery) at (0, 0), Battery: 100%\n\n=== TESTING MOVEMENT (Polymorphism) ===\nRobot Clean-01 moved 5 units\nCleaning path as I move\nRobot Clean-02 moved 5 units  \nCleaning path as I move\nRobot Deliver-01 moved 5 units\n\n=== TESTING SPECIALIZED METHODS ===\nClean-01 cleaning Kitchen area\nDeliver-01 loaded: Package A\nRobot Deliver-01 moved 3 units\nTransporting Package A\nDeliver-01 delivered: Package A\n\n=== FINAL STATUS ===\nRobot Clean-01 (Cleaning) at (0, 0), Battery: 85%\nRobot Clean-02 (Cleaning) at (0, 0), Battery: 95%\nRobot Deliver-01 (Delivery) at (0, 0), Battery: 92%\n\n=== FACTORY REPORT ===\nFactory contains: 2 Cleaning robots, 1 Delivery robot\n</code></pre>"},{"location":"sessions/session-06/#what-this-task-demonstrates","title":"What This Task Demonstrates","text":"<ul> <li>Inheritance: <code>CleaningRobot</code> and <code>DeliveryRobot</code> inherit from <code>Robot</code></li> <li>Polymorphism: Same <code>move()</code> method works differently for each robot type</li> <li>Composition: <code>RobotFactory</code> contains multiple robot objects</li> <li>Method Overriding: Specialized robots override the base <code>move()</code> method</li> </ul>"},{"location":"sessions/session-06/#submission-requirements","title":"Submission Requirements","text":"<ol> <li>Python file with all classes implemented correctly</li> <li>Test results showing your code produces the expected output</li> <li>Brief explanation (3-4 sentences) of how your code demonstrates inheritance and polymorphism</li> </ol> <p>!!! warning \"Important Notes\" - Use the exact class and method names shown above - Your code will be tested with automated unit tests - Focus on making the basic functionality work correctly - Don't add extra complexity - keep it simple and working</p>"},{"location":"sessions/session-06/#session-summary","title":"Session Summary","text":"<p>In this comprehensive session, you explored the advanced Object-Oriented Programming concepts that form the backbone of sophisticated robotics software systems.</p>"},{"location":"sessions/session-06/#key-concepts-mastered","title":"Key Concepts Mastered","text":"<p>Inheritance:</p> <ul> <li>Class hierarchies and the \"is-a\" relationship</li> <li>Method overriding and the <code>super()</code> function</li> <li>Building specialized robot types from base classes</li> </ul> <p>Polymorphism:</p> <ul> <li>Duck typing and common interfaces</li> <li>Polymorphic method calls and behavior</li> <li>Strategy pattern for flexible algorithms</li> </ul> <p>Composition over Inheritance:</p> <ul> <li>\"Has-a\" relationships for system modularity</li> <li>Component-based architecture design</li> <li>Loose coupling and high cohesion</li> </ul> <p>Abstract Base Classes:</p> <ul> <li>Interface definition and enforcement</li> <li>Contract specification for subclasses</li> <li>Supporting polymorphic behavior</li> </ul> <p>Multiple Inheritance:</p> <ul> <li>Method Resolution Order (MRO)</li> <li>The diamond problem and solutions</li> <li>Cooperative inheritance with <code>super()</code></li> </ul>"},{"location":"sessions/session-06/#real-world-applications","title":"Real-World Applications","text":"<p>These concepts are fundamental to:</p> <ul> <li>Robot Operating System (ROS) architecture</li> <li>Modular robotics platforms like Boston Dynamics' robots</li> <li>Industrial automation systems with multiple robot types</li> <li>Autonomous vehicle software with sensor fusion</li> <li>Swarm robotics coordination systems</li> </ul>"},{"location":"sessions/session-06/#next-steps","title":"Next Steps","text":"<p>Building on this session's concepts:</p> <ul> <li>Session 7 will explore error handling and debugging strategies</li> <li>Session 8 will cover file I/O and data persistence</li> <li>Session 9 will introduce networking and communication protocols</li> <li>Session 10 will integrate everything into a capstone robotics project</li> </ul>"},{"location":"sessions/session-06/#additional-resources","title":"Additional Resources","text":"<p>!!! resources \"Further Learning\" - Python's <code>abc</code> module documentation for advanced ABC usage - Design Patterns in Python by Gamma et al. (Gang of Four patterns) - Effective Python by Brett Slatkin for advanced Python OOP techniques - ROS2 architectural patterns for real-world robotics applications - UML modeling tools like PlantUML or Lucidchart for design visualization</p> <p>!!! success \"Session Complete!\" You've now mastered the advanced OOP concepts essential for building scalable, maintainable robotics software. The combination of inheritance, polymorphism, and composition provides the foundation for creating sophisticated robot control systems that can adapt and evolve with changing requirements.</p> <p>Preparation for Next Session: Review error handling concepts and debugging strategies. Consider how robust error handling would improve the robot systems you've designed in this session.</p>"},{"location":"sessions/session-07/","title":"Week 7 - File I/O & Documentation","text":""},{"location":"sessions/session-07/#session-7-file-io-configuration-ros2-launch-files","title":"Session 7: File I/O, Configuration &amp; ROS2 Launch Files","text":"<p>Week: 7 Element: ICTPRG430 Element 2.2 Duration: 4 hours Phase: Object-Oriented Programming Theory</p>"},{"location":"sessions/session-07/#session-introduction","title":"Session Introduction","text":"<p>In this session you will explore fundamental Python file handling, structured data serialization, and ROS2 launch files crucial for robust robotics applications. Building on your mastery of inheritance, polymorphism, and composition, you'll learn how configuration files enable dynamic robot behavior changes. The session includes a lightweight introduction to ROS2 concepts, followed by hands-on exercises implementing configuration systems, and preparation for refactoring Labs 3-4 with launch file integration.</p>"},{"location":"sessions/session-07/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this session, you will be able to:</p> <ul> <li>Understand and implement file handling operations for robot configuration management.</li> <li>Utilize JSON and XML formats for structured robot parameter storage.</li> <li>Apply basic ROS2 concepts including nodes and launch files for robot system configuration.</li> <li>Design configuration systems that leverage polymorphic interfaces from previous sessions.</li> <li>Prepare launch file configurations for Labs 3-4 refactoring activities.</li> </ul>"},{"location":"sessions/session-07/#session-structure","title":"Session Structure","text":"<ol> <li>Theory Session - File I/O Fundamentals &amp; ROS2 Introduction.</li> <li>Hands-on Exercise - Building Configuration Systems.</li> <li>Live Demonstration - ROS2 Launch Files for Robot Configuration.</li> <li>Extension Activity - Advanced Configuration Validation.</li> <li>Lab Preparation - Launch File Setup for Labs 3-4 Refactoring.</li> </ol>"},{"location":"sessions/session-07/#session-overview","title":"Session Overview","text":"<p>This session bridges the gap between object-oriented programming theory and real-world robotics practice. You'll learn how robots store and retrieve configuration data, and how industry-standard tools like ROS2 manage complex robotic systems. The focus is on practical application of your OOP knowledge to create flexible, configurable robot systems that can adapt behaviour through external configuration files.</p> <p>Pre-Session Preparation</p> <p>Ensure your development environment is ready: * Python 3.9+ installed and configured. * Review your Labs 3-4 implementations - particularly the classes and interfaces you created.</p>"},{"location":"sessions/session-07/#1-file-io-fundamentals-for-robotics","title":"1. File I/O Fundamentals for Robotics","text":"<p>Understanding file operations is essential for robotics, as robots must load configurations, save sensor data, and manage mission parameters.</p>"},{"location":"sessions/session-07/#basic-file-operations","title":"Basic File Operations","text":"<pre><code># Reading configuration files\nwith open('robot_config.json', 'r') as file:\n    config_data = json.load(file)\n\n# Writing robot logs\nwith open('sensor_log.txt', 'a') as file:\n    file.write(f\"{timestamp}: {sensor_reading}\\n\")\n</code></pre> <p>Key Concepts</p> <ul> <li>File Modes: <code>'r'</code> (read), <code>'w'</code> (write), <code>'a'</code> (append)</li> <li>Context Managers: Using <code>with</code> statements for automatic resource cleanup</li> <li>Error Handling: Managing <code>FileNotFoundError</code> and parsing errors</li> </ul>"},{"location":"sessions/session-07/#2-structured-data-with-json-and-xml","title":"2. Structured Data with JSON and XML","text":"<p>For complex robot configurations, structured data formats provide standardized ways to store hierarchical parameters.</p>"},{"location":"sessions/session-07/#json-for-robot-configuration","title":"JSON for Robot Configuration","text":"<pre><code># Example robot configuration structure\n{\n    \"robot_id\": \"explorer_001\",\n    \"navigation\": {\n        \"max_speed\": 2.0,\n        \"localization_strategy\": \"odometry\",\n        \"pathfinding_algorithm\": \"a_star\"\n    },\n    \"sensors\": {\n        \"lidar_enabled\": true,\n        \"camera_resolution\": [640, 480]\n    }\n}\n</code></pre>"},{"location":"sessions/session-07/#xml-for-ros2-launch-files","title":"XML for ROS2 Launch Files","text":"<pre><code>&lt;!-- Basic launch file structure --&gt;\n&lt;launch&gt;\n    &lt;node pkg=\"robot_navigation\" exec=\"localization_node\" name=\"localization\"&gt;\n        &lt;param name=\"strategy\" value=\"odometry\"/&gt;\n        &lt;param name=\"max_speed\" value=\"2.0\"/&gt;\n    &lt;/node&gt;\n&lt;/launch&gt;\n</code></pre>"},{"location":"sessions/session-07/#3-introduction-to-ros2-concepts","title":"3. Introduction to ROS2 Concepts","text":"<p>ROS2 (Robot Operating System 2) is the industry standard for building modular, distributed robotic systems. We'll focus on the basics relevant to configuration management.</p>"},{"location":"sessions/session-07/#core-ros2-concepts","title":"Core ROS2 Concepts","text":"<ul> <li>Nodes: Independent processes that perform specific robot functions</li> <li>Parameters: Configuration values that nodes use to modify behavior</li> <li>Launch Files: XML files that start multiple nodes with specific configurations</li> </ul>"},{"location":"sessions/session-07/#why-ros2-matters-for-your-projects","title":"Why ROS2 Matters for Your Projects","text":"<ul> <li>Modularity: Separate localization, navigation, and control into different nodes</li> <li>Configurability: Change robot behavior without recompiling code</li> <li>Industry Standard: Used in commercial robots worldwide</li> </ul> <pre><code># Pseudocode: ROS2 node structure\nclass LocalizationNode:\n    def __init__(self):\n        # Get parameters from launch file\n        self.strategy = self.get_parameter('localization_strategy')\n        self.max_speed = self.get_parameter('max_speed')\n\n        # Create strategy using polymorphism\n        self.localization = LocalizationFactory.create(self.strategy)\n</code></pre>"},{"location":"sessions/session-07/#hands-on-exercise-configuration-manager-for-labs-3-4","title":"Hands-on Exercise: Configuration Manager for Labs 3-4","text":"<p>You'll create a configuration system that prepares for your Labs 3-4 refactoring, leveraging the polymorphic interfaces you've already mastered. See: Lab 3 \u2192 and Lab 4 \u2192</p>"},{"location":"sessions/session-07/#system-architecture","title":"System Architecture","text":"<pre><code>classDiagram\n    class ConfigurationManager {\n        -config_data: dict\n        +load_config(file_path: str)\n        +get_navigation_params(): dict\n        +get_localization_strategy(): str\n        +get_pathfinding_algorithm(): str\n    }\n\n    class LocalizationStrategy {\n        &lt;&lt;abstract&gt;&gt;\n        +localize(sensor_data): Position\n    }\n\n    class OdometryStrategy {\n        +localize(sensor_data): Position\n    }\n\n    class ParticleFilterStrategy {\n        +localize(sensor_data): Position\n    }\n\n    class PathfindingAlgorithm {\n        &lt;&lt;abstract&gt;&gt;\n        +find_path(start, goal, obstacles): Path\n    }\n\n    class AStarAlgorithm {\n        +find_path(start, goal, obstacles): Path\n    }\n\n    class DFSAlgorithm {\n        +find_path(start, goal, obstacles): Path\n    }\n\n    ConfigurationManager --&gt; LocalizationStrategy\n    ConfigurationManager --&gt; PathfindingAlgorithm\n    LocalizationStrategy &lt;|-- OdometryStrategy\n    LocalizationStrategy &lt;|-- ParticleFilterStrategy\n    PathfindingAlgorithm &lt;|-- AStarAlgorithm\n    PathfindingAlgorithm &lt;|-- DFSAlgorithm</code></pre>"},{"location":"sessions/session-07/#task-create-a-configuration-system","title":"Task: Create a Configuration System","text":"<p>Step 1: Configuration Manager Class</p> <pre><code>class ConfigurationManager:\n    def __init__(self, config_path: str):\n        # TODO: Initialize with config file path\n        # TODO: Create empty config_data dictionary\n        pass\n\n    def load_config(self) -&gt; None:\n        \"\"\"Load configuration from JSON file.\"\"\"\n        # TODO: Open and parse JSON file\n        # TODO: Handle FileNotFoundError\n        # TODO: Validate required configuration keys\n        pass\n\n    def get_localization_strategy(self) -&gt; str:\n        \"\"\"Return the configured localization strategy name.\"\"\"\n        # TODO: Extract from config_data[\"navigation\"][\"localization_strategy\"]\n        pass\n\n    def get_pathfinding_algorithm(self) -&gt; str:\n        \"\"\"Return the configured pathfinding algorithm name.\"\"\"\n        # TODO: Extract from config_data[\"navigation\"][\"pathfinding_algorithm\"]\n        pass\n\n    def get_pid_parameters(self) -&gt; dict:\n        \"\"\"Return PID controller parameters.\"\"\"\n        # TODO: Extract PID gains (kp, ki, kd) from configuration\n        pass\n</code></pre> <p>Step 2: Factory Classes</p> <pre><code>class LocalizationFactory:\n    @staticmethod\n    def create(strategy_name: str) -&gt; LocalizationStrategy:\n        \"\"\"Create localization strategy based on configuration.\"\"\"\n        # TODO: Use strategy_name to return appropriate strategy instance\n        # TODO: Support \"odometry\", \"particle_filter\", etc.\n        pass\n\nclass PathfindingFactory:\n    @staticmethod\n    def create(algorithm_name: str) -&gt; PathfindingAlgorithm:\n        \"\"\"Create pathfinding algorithm based on configuration.\"\"\"\n        # TODO: Use algorithm_name to return appropriate algorithm instance\n        # TODO: Support \"a_star\", \"dfs\", \"bfs\", etc.\n        pass\n</code></pre> <p>Step 3: Sample Configuration File Create a <code>robot_config.json</code> file with the structure needed for Labs 3-4:</p> <pre><code>{\n    \"robot_id\": \"lab_robot\",\n    \"navigation\": {\n        \"max_speed\": 1.5,\n        \"localization_strategy\": \"odometry\",\n        \"pathfinding_algorithm\": \"a_star\"\n    },\n    \"control\": {\n        \"pid_gains\": {\n            \"kp\": 1.0,\n            \"ki\": 0.1,\n            \"kd\": 0.05\n        }\n    },\n    \"simulation\": {\n        \"world_size\": [10, 10],\n        \"obstacles\": [[2, 3], [7, 8]]\n    }\n}\n</code></pre>"},{"location":"sessions/session-07/#live-demonstration-ros2-launch-files","title":"Live Demonstration: ROS2 Launch Files","text":"<p>The instructor will demonstrate how ROS2 launch files configure multiple robot nodes and how this relates to your Labs 3-4 refactoring.</p>"},{"location":"sessions/session-07/#basic-launch-file-structure","title":"Basic Launch File Structure","text":"<pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;launch&gt;\n    &lt;!-- Localization Node --&gt;\n    &lt;node pkg=\"lab_robot\" exec=\"localization_node\" name=\"localization\"&gt;\n        &lt;param name=\"strategy\" value=\"odometry\"/&gt;\n        &lt;param name=\"max_speed\" value=\"1.5\"/&gt;\n    &lt;/node&gt;\n\n    &lt;!-- Navigation Node --&gt;\n    &lt;node pkg=\"lab_robot\" exec=\"navigation_node\" name=\"navigation\"&gt;\n        &lt;param name=\"pathfinding\" value=\"a_star\"/&gt;\n        &lt;param name=\"pid_kp\" value=\"1.0\"/&gt;\n        &lt;param name=\"pid_ki\" value=\"0.1\"/&gt;\n        &lt;param name=\"pid_kd\" value=\"0.05\"/&gt;\n    &lt;/node&gt;\n&lt;/launch&gt;\n</code></pre> <p>Live Coding Session</p> <p>The instructor will demonstrate: * Creating launch files that configure different strategies for Labs 3-4 * Parameter passing from launch files to Python nodes * Running multiple configurations without changing code</p>"},{"location":"sessions/session-07/#extension-activity-configuration-validation","title":"Extension Activity: Configuration Validation","text":"<p>Advanced configuration systems include validation to prevent runtime errors.</p>"},{"location":"sessions/session-07/#schema-validation-example","title":"Schema Validation Example","text":"<pre><code># Configuration schema definition\nROBOT_CONFIG_SCHEMA = {\n    \"type\": \"object\",\n    \"required\": [\"robot_id\", \"navigation\", \"control\"],\n    \"properties\": {\n        \"navigation\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"localization_strategy\": {\n                    \"type\": \"string\",\n                    \"enum\": [\"odometry\", \"particle_filter\"]\n                }\n            }\n        }\n    }\n}\n\nclass ConfigurationValidator:\n    def validate(self, config_data: dict) -&gt; bool:\n        \"\"\"Validate configuration against schema.\"\"\"\n        # TODO: Implement schema validation\n        # TODO: Check required fields exist\n        # TODO: Verify enum values are valid\n        pass\n</code></pre>"},{"location":"sessions/session-07/#lab-preparation-launch-files-for-labs-3-4","title":"Lab Preparation: Launch Files for Labs 3-4","text":"<p>Prepare for next week's refactoring by creating launch file templates:</p>"},{"location":"sessions/session-07/#lab-3-odometry-localization-launch","title":"Lab 3: Odometry Localization Launch","text":"<pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;launch&gt;\n    &lt;!-- TODO: Create node for odometry-based localization --&gt;\n    &lt;!-- TODO: Add parameters for localization strategy --&gt;\n    &lt;!-- TODO: Configure sensor parameters --&gt;\n&lt;/launch&gt;\n</code></pre>"},{"location":"sessions/session-07/#lab-4-go-to-goal-navigation-launch","title":"Lab 4: Go-to-Goal Navigation Launch","text":"<pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;launch&gt;\n    &lt;!-- TODO: Create node for PID controller --&gt;\n    &lt;!-- TODO: Add parameters for PID gains --&gt;\n    &lt;!-- TODO: Configure pathfinding algorithm --&gt;\n&lt;/launch&gt;\n</code></pre>"},{"location":"sessions/session-07/#portfolio-assessment-preparation","title":"Portfolio Assessment Preparation","text":"<p>Portfolio 1 Assessment: AT Task 1 - OOP Fundamentals is due at the end of this session.</p> <p>Your configuration system work directly supports this assessment by demonstrating:</p> <ul> <li>Class Design: Configuration manager with proper encapsulation</li> <li>Factory Patterns: Creating objects based on configuration</li> <li>File I/O Integration: Loading external configuration data</li> </ul>"},{"location":"sessions/session-07/#key-takeaways","title":"Key Takeaways","text":"<p>Session Summary</p> <ul> <li>Configuration Management: External files enable dynamic robot behavior without code changes * ROS2 Fundamentals: Industry-standard approach to modular robot systems * Factory Patterns: Configuration-driven object creation supports polymorphism * Launch Files: XML-based system configuration for complex robot applications</li> </ul>"},{"location":"sessions/session-07/#check-your-knowledge","title":"Check Your Knowledge","text":"<p>Question 1: Configuration vs Hard-coding</p> <pre><code>**Question:** Why is loading robot parameters from a configuration file better than hard-coding them in your classes?\n</code></pre> Click to reveal answer <p>Answer:</p> <p>Question 2: Polymorphism + Configuration</p> <p>Question: How does a configuration file enable you to switch between different localization strategies without changing your main robot code?</p> Click to reveal answer <p>Answer:</p> <p>Question 3: ROS2 Benefits</p> <p>Question: What advantages does using ROS2 nodes provide compared to running everything in a single Python script?</p> Click to reveal answer <p>Answer:</p>"},{"location":"sessions/session-07/#further-reading","title":"Further Reading","text":"<ul> <li>ROS2 Documentation: Launch file syntax and node parameters</li> <li>Python JSON Module: Official documentation and examples</li> <li>Factory Pattern: Design patterns in Python for robotics</li> </ul> <p>Navigation: \u2190 Week 6 | Learning Plan | Week 8 \u2192</p>"},{"location":"sessions/session-08/","title":"Week 8 - Lab 1 OOP Refactoring","text":""},{"location":"sessions/session-08/#session-8-lab-completion-ros2-integration","title":"Session 8: Lab Completion &amp; ROS2 Integration","text":"<p>Week: 8 Element: ICTPRG430 Element 2.2 Duration: 4 hours Phase: Webots Labs</p>"},{"location":"sessions/session-08/#session-introduction","title":"Session Introduction","text":"<p>This session is dedicated to completing the hands-on exercises and lab preparation work from Session 7. You will finalize your configuration management systems, complete the ROS2 launch file implementations, and ensure your Labs 3-4 are properly refactored with the new configuration-driven approach. All lab work and exercises from Session 7 must be completed by the end of this session.</p> <p>The session focuses on practical implementation and completion of: - Configuration Manager system for Labs 3-4 - ROS2 launch file templates and integration - Configuration validation and error handling - Final preparation for Portfolio Assessment 1 (AT Task 1 - OOP Fundamentals)</p>"},{"location":"sessions/session-08/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this session, you will have:</p> <ul> <li>Completed the Configuration Manager implementation from Session 7's hands-on exercise</li> <li>Finalized ROS2 launch file templates for Labs 3-4 integration</li> <li>Implemented configuration validation and proper error handling</li> <li>Successfully refactored Labs 3-4 to use external configuration files</li> <li>Prepared and validated your Portfolio Assessment 1 submission</li> </ul>"},{"location":"sessions/session-08/#session-structure","title":"Session Structure","text":"<ol> <li>Lab Completion Phase - Finishing Session 7 hands-on exercises</li> <li>ROS2 Launch File Implementation - Completing launch file templates</li> <li>Configuration System Testing - Validation and error handling</li> <li>Labs 3-4 Integration - Refactoring with configuration management</li> <li>Portfolio Assessment Review - Final preparation and submission check</li> </ol>"},{"location":"sessions/session-08/#required-completions-from-session-7","title":"Required Completions from Session 7","text":"<p>Session 7 Lab Requirements - Due Today</p> <p>The following items from Session 7 must be completed by the end of this session:</p> <p>\u2705 Labs 3-4 Refactoring - Integration with configuration system</p>"},{"location":"sessions/session-08/#what-you-need-to-complete-today","title":"What You Need to Complete Today","text":""},{"location":"sessions/session-08/#1-configuration-manager-system-from-session-7-exercise","title":"1. Configuration Manager System (From Session 7 Exercise)","text":"<p>Complete the implementation of your <code>ConfigurationManager</code> class with all required methods:</p> <ul> <li><code>__init__(self, config_path: str)</code> - Initialize with config file path</li> <li><code>load_config(self) -&gt; None</code> - Load and parse JSON configuration</li> <li><code>get_localization_strategy(self) -&gt; str</code> - Extract localization strategy</li> <li><code>get_pathfinding_algorithm(self) -&gt; str</code> - Extract pathfinding algorithm</li> <li><code>get_pid_parameters(self) -&gt; dict</code> - Extract PID controller parameters</li> </ul>"},{"location":"sessions/session-08/#2-factory-pattern-implementation","title":"2. Factory Pattern Implementation","text":"<p>Ensure your factory classes are fully functional:</p> <ul> <li><code>LocalizationFactory.create(strategy_name: str)</code> - Create localization strategies</li> <li><code>PathfindingFactory.create(algorithm_name: str)</code> - Create pathfinding algorithms</li> </ul>"},{"location":"sessions/session-08/#3-ros2-launch-file-integration","title":"3. ROS2 Launch File Integration","text":"<p>Complete the launch file templates started in Session 7:</p>"},{"location":"sessions/session-08/#lab-3-launch-file-odometry-localization-with-configurable-parameters","title":"Lab 3 Launch File:  Odometry localization with configurable parameters","text":""},{"location":"sessions/session-08/#lab-4-launch-file-go-to-goal-navigation-with-pid-configuration","title":"Lab 4 Launch File: Go-to-goal navigation with PID configuration","text":""},{"location":"sessions/session-08/#session-workflow","title":"Session Workflow","text":"<p>Phase 1: Lab Completion - Review and complete unfinished Session 7 exercises     - Implement missing methods in ConfigurationManager     - Test factory pattern implementations</p> <p>Phase 2: ROS2 Integration      - Finalize launch file templates     - Test parameter passing from launch files     - Validate XML syntax and structure</p> <p>Phase 3: System Testing     - Implement configuration validation     - Test error handling scenarios     - Verify Labs 3-4 integration</p> <p>Navigation: \u2190 Week 7 | Learning Plan | Week 9 \u2192</p>"},{"location":"sessions/session-09/","title":"Week 9 - Lab 2 OOP Implementation","text":""},{"location":"sessions/session-09/#session-9-ari-robot-hardware-component-reuse-analysis","title":"Session 9: ARI Robot Hardware &amp; Component Reuse Analysis","text":"<p>Week: 9 Element: ICTPRG430 Applied Practice + ICTPRG439 Preview Duration: 4 hours Phase: Lab Work + Industry Insight</p>"},{"location":"sessions/session-09/#session-introduction","title":"Session Introduction","text":"<p>This session provides dedicated lab time for students to continue their work on Labs 3-4 while introducing real-world component reuse through hands-on exploration of the PAL Robotics ARI humanoid robot. With the robot's covers removed, students will examine both hardware and software component reuse strategies that directly connect to next term's ICTPRG439 component integration work.</p> <p>Key Takeaways</p> <p>By the end of this session, students will understand:</p> <ol> <li>Hardware component reuse reduces development time and cost</li> <li>Software libraries and frameworks provide tested, reliable functionality  </li> <li>Standardized interfaces (like ROS) enable component interchangeability</li> <li>Configuration systems allow behavior changes without code modification</li> <li>Commercial robots extensively use both open-source and proprietary components</li> </ol> <p>This foundation will be essential for next term's focus on evaluating, selecting, and integrating pre-existing components into robotics projects.</p>"},{"location":"sessions/session-09/#session-structure","title":"Session Structure","text":""},{"location":"sessions/session-09/#part-1-lab-work-time-120-minutes","title":"Part 1: Lab Work Time (120 minutes)","text":"<ul> <li>Individual/Group Lab Progress - Continue Labs 3-4 with instructor support</li> <li>OOP Implementation Review - Apply Sessions 6-7 concepts to current work</li> <li>Configuration Integration - Implement file I/O and parameter management</li> </ul>"},{"location":"sessions/session-09/#part-2-ari-hardware-analysis-90-minutes","title":"Part 2: ARI Hardware Analysis (90 minutes)","text":"<ul> <li>Physical Component Examination - Explore sensors, actuators, computing units</li> <li>Integration Architecture - Understand how components connect and communicate</li> <li>Component Reuse Identification - Spot standardized vs. custom components</li> </ul>"},{"location":"sessions/session-09/#part-3-software-component-analysis-30-minutes","title":"Part 3: Software Component Analysis (30 minutes)","text":"<ul> <li>ROS Package Exploration - Examine ARI's open-source components</li> <li>Dependency Analysis - Understanding component relationships</li> <li>Industry Standards - Component selection criteria in commercial systems</li> </ul>"},{"location":"sessions/session-09/#ari-robot-component-analysis","title":"ARI Robot Component Analysis","text":""},{"location":"sessions/session-09/#hardware-components-to-examine","title":"Hardware Components to Examine","text":"<p> Computing Systems: - Intel i7 and NVIDIA Jetson TX2 GPU combination for AI processing - Multiple processing units for different tasks (perception, control, navigation)</p> <p>Sensor Array: - Head Camera Sony 8MegaPixel (RGB), Head Intel Realsense D435i (RGB-D) - Array of four microphones located on the circular gap of the torso - IMU, force/torque sensors, joint encoders - Touch sensors and proximity detection</p> <p></p> <p>Actuator Systems: - Joint motors and servo controllers - Gripper mechanisms - Mobile base drive system - 40 Ah Li-ion battery system with docking station capability</p> <p>Communication &amp; I/O: - Expansion panel at the back providing access to additional connectors - Network interfaces, USB ports, power connections - Internal bus systems connecting components </p>"},{"location":"sessions/session-09/#software-component-reuse-examples","title":"Software Component Reuse Examples","text":"<p>ROS Integration: - Joint trajectory motions sent to the joint_trajectory_controller ROS package, an open source ROS package - Standard ROS navigation stack components - Perception pipeline using established computer vision libraries</p> <p>Open Source Components: - PAL Robotics champions open-source robotics from ROS to ROS 2 - ArUco marker detection library integration - Standard algorithms for SLAM, path planning, object recognition</p> <p>Component Selection Criteria Discussion</p> <p>Analyze the following:</p> <ol> <li>Why use Intel RealSense and a custom camera?</li> <li>How do standardized ROS packages reduce development time?</li> <li>What trade-offs exist between custom vs. off-the-shelf components?</li> <li>How does component modularity affect maintenance and upgrades?</li> </ol>"},{"location":"sessions/session-09/#hands-on-activities","title":"Hands-On Activities","text":""},{"location":"sessions/session-09/#activity-1-component-mapping-exercise","title":"Activity 1: Component Mapping Exercise","text":"<ul> <li>Physical Inspection: Identify and catalog visible components</li> <li>Function Analysis: Determine what each component does</li> <li>Reuse Classification: Standard component vs. custom implementation</li> <li>Integration Points: How components connect and communicate</li> </ul>"},{"location":"sessions/session-09/#activity-2-software-architecture-exploration","title":"Activity 2: Software Architecture Exploration","text":"<ul> <li>ROS Node Structure: Examine running processes on ARI</li> <li>Package Dependencies: Understand component relationships</li> <li>Configuration Files: See how parameters customize behavior</li> <li>Version Management: How updates and compatibility are handled</li> </ul>"},{"location":"sessions/session-09/#activity-3-design-decision-analysis","title":"Activity 3: Design Decision Analysis","text":"<p>Students discuss in groups:</p> <ul> <li>Why might PAL Robotics choose certain components over alternatives?</li> <li>How do hardware choices affect software architecture?</li> <li>What would happen if you wanted to upgrade a specific component?</li> <li>How does this relate to your current lab implementations?</li> </ul>"},{"location":"sessions/session-09/#connection-to-current-learning","title":"Connection to Current Learning","text":""},{"location":"sessions/session-09/#oop-concepts-in-hardware","title":"OOP Concepts in Hardware","text":"<ul> <li>Inheritance: Base motor controller with specialized implementations</li> <li>Composition: Robot \"has-a\" camera, \"has-a\" gripper, \"has-a\" mobile base</li> <li>Polymorphism: Same interface for different sensor types</li> <li>Abstraction: Hardware abstraction layers hiding complexity</li> </ul>"},{"location":"sessions/session-09/#configuration-management","title":"Configuration Management","text":"<ul> <li>Parameter Files: How ARI loads different behavior configurations</li> <li>Launch Files: Starting multiple components with coordinated parameters</li> <li>Runtime Reconfiguration: Changing behavior without restarting system</li> </ul>"},{"location":"sessions/session-09/#integration-patterns","title":"Integration Patterns","text":"<ul> <li>Interface Standardization: How ROS messages enable component swapping</li> <li>Dependency Management: Managing component versions and compatibility</li> <li>Testing Strategies: How to validate component integration</li> </ul>"},{"location":"sessions/session-09/#preview-component-reuse-next-term","title":"Preview: Component Reuse Next Term","text":"<p>This session introduces concepts that will be central to ICTPRG439:</p>"},{"location":"sessions/session-09/#component-evaluation-criteria","title":"Component Evaluation Criteria","text":"<ul> <li>Functionality: Does it meet our requirements?</li> <li>Compatibility: Will it integrate with our system?</li> <li>Licensing: Can we legally use it in our project?</li> <li>Support: Is there active development and community?</li> <li>Performance: Does it meet our timing/resource constraints?</li> </ul>"},{"location":"sessions/session-09/#integration-challenges","title":"Integration Challenges","text":"<ul> <li>Version Conflicts: Managing different component requirements</li> <li>Interface Mismatches: Adapting between different APIs</li> <li>Documentation Quality: Understanding how to use components effectively</li> <li>Testing Integration: Validating that components work together</li> </ul>"},{"location":"sessions/session-09/#lab-time","title":"Lab Time","text":"<ul> <li>Continue Lab 3-4 implementations </li> </ul>"},{"location":"sessions/session-09/#resources-for-further-exploration","title":"Resources for Further Exploration","text":"<ul> <li>PAL Robotics ARI Documentation: Hardware specifications and software architecture</li> <li>ROS.org: Standard robotics components and packages  </li> <li>Intel RealSense SDK: Example of hardware-software component integration</li> <li>GitHub PAL Robotics: Open-source components used in commercial robots</li> </ul>"},{"location":"sessions/session-10/","title":"Week 10 - ARI Software Ecosystem & ROS2 Fundamentals","text":""},{"location":"sessions/session-10/#session-10-ari-software-ecosystem-ros2-fundamentals","title":"Session 10: ARI Software Ecosystem &amp; ROS2 Fundamentals","text":"<p>Week: 10 Element: ICTPRG439 Element 2.3 Duration: 4 hours Phase: Software Architecture Analysis</p>"},{"location":"sessions/session-10/#session-introduction","title":"Session Introduction","text":"<p>This session transitions from hardware exploration to software ecosystem analysis of the ARI humanoid robot platform. Building on our understanding of ARI's physical architecture from Session 8, we now explore the software packages, dependencies, and development environment that power ARI's intelligent behaviors.</p> <p>We will analyze the PAL Robotics forks repository to understand the package ecosystem, work with Ubuntu 24.04 VM environment pre-configured with ROS2, VSCode, and Webots, and establish foundational knowledge of ROS2 fundamentals through hands-on tutorials.</p> <p>The session emphasizes understanding different package management approaches and why robust package ecosystems are essential for modern robotics development, Python programming, and software engineering practices.</p>"},{"location":"sessions/session-10/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this session, you will have:</p> <ul> <li>Analyzed PAL Robotics forks repository to identify key packages and dependencies</li> <li>Set up and navigated Ubuntu 24.04 VM environment with robotics tools</li> <li>Completed ROS2 CLI fundamentals using turtlesim tutorials</li> <li>Installed and configured Webots ROS2 package using colcon build system</li> <li>Understood differences between <code>apt install</code>, <code>pip install</code>, and <code>colcon build</code></li> <li>Recognized the importance of package ecosystems in robotics and software development</li> </ul>"},{"location":"sessions/session-10/#session-structure","title":"Session Structure","text":"<ol> <li>PAL Robotics Software Analysis - Repository exploration and package identification</li> <li>VM Environment Setup - Ubuntu 24.04 configuration and tool verification</li> <li>ROS2 Fundamentals - CLI tools, nodes, and communication concepts</li> <li>Webots-ROS2 Integration - Package installation and workspace building</li> <li>Package Management Deep Dive - Comparing installation methods and ecosystems</li> </ol>"},{"location":"sessions/session-10/#part-1-pal-robotics-software-ecosystem","title":"Part 1: PAL Robotics Software Ecosystem","text":""},{"location":"sessions/session-10/#11-repository-analysis","title":"1.1 Repository Analysis","text":"<p>We begin by exploring the PAL Robotics forks repository to understand the software stack:</p> <p>Repository URL: https://github.com/pal-robotics-forks</p> <p>Analysis Focus Areas</p> <ul> <li>Package Dependencies - What external packages does PAL Robotics rely on?</li> <li>Forked Repositories - Why do they maintain forks instead of using upstream?</li> <li>Package Categories - Navigation, perception, manipulation, simulation packages</li> <li>Version Management - How they manage compatibility across package versions</li> </ul>"},{"location":"sessions/session-10/#12-key-package-categories","title":"1.2 Key Package Categories","text":"<p>Navigation &amp; Localization: - SLAM implementations - Path planning algorithms - Localization frameworks</p> <p>Perception &amp; Vision: - Computer vision libraries - Point cloud processing - Object recognition systems</p> <p>Manipulation &amp; Control: - Arm control packages - Gripper interfaces - Motion planning libraries</p> <p>Simulation &amp; Testing: - Gazebo integration packages - Testing frameworks - Simulation utilities</p>"},{"location":"sessions/session-10/#part-2-vm-environment-setup","title":"Part 2: VM Environment Setup","text":""},{"location":"sessions/session-10/#21-basic-vm-configuration","title":"2.1 Basic VM Configuration","text":"<p>VM Specifications:</p> <ul> <li>OS: Ubuntu 24.04 LTS</li> <li>Pre-installed Tools: ROS2, VSCode, Webots</li> <li>Location: Network image (instructor will demonstrate access)</li> </ul> <p>Basic Setup Steps:</p> <ol> <li>Open VMware and locate network image</li> <li>Start Ubuntu 24.04 VM instance</li> <li>Verify ROS2 installation: <code>ros2 --version</code></li> <li>Verify Webots installation: Check Applications menu</li> <li>Launch VSCode for development environment</li> </ol> <p></p> <p>VM Usage Tips</p> <ul> <li>Snapshot before major changes to preserve working state</li> <li>Allocate sufficient RAM for smooth ROS2 and Webots operation</li> <li>Enable hardware acceleration if available for better performance</li> </ul>"},{"location":"sessions/session-10/#22-tool-verification","title":"2.2 Tool Verification","text":"<p>ROS2 Environment Check: </p><pre><code># These commands will be demonstrated in class\nros2 --version\nros2 pkg list\necho $ROS_DOMAIN_ID\n</code></pre>"},{"location":"sessions/session-10/#part-3-ros2-fundamentals","title":"Part 3: ROS2 Fundamentals","text":""},{"location":"sessions/session-10/#31-official-ros2-tutorial","title":"3.1 Official ROS2 Tutorial","text":"<p>We will follow the official ROS2 tutorial focusing on CLI tools and basic concepts:</p> <p>Tutorial Reference: Beginner: CLI tools Using turtlesim, ros2, and rqt</p>"},{"location":"sessions/session-10/#32-core-ros2-concepts","title":"3.2 Core ROS2 Concepts","text":"<p>Nodes: - Fundamental ROS2 computation units - Independent processes that communicate via topics/services - Discoverable and composable architecture</p> <p>Topics:</p> <ul> <li>Asynchronous message passing mechanism</li> <li>Publisher-subscriber communication pattern</li> <li>Typed message interfaces</li> </ul> <p>Services:</p> <ul> <li>Synchronous request-response communication</li> <li>Client-server interaction model</li> <li>Blocking communication for immediate responses</li> </ul> <p>Parameters:</p> <ul> <li>Configuration values for nodes</li> <li>Runtime reconfigurable settings</li> <li>Hierarchical parameter organization</li> </ul>"},{"location":"sessions/session-10/#33-turtlesim-exploration","title":"3.3 Turtlesim Exploration","text":"<p>The turtlesim tutorial will demonstrate:</p> <ul> <li>Node launching and management</li> <li>Topic publishing and subscribing</li> <li>Service calling and responses</li> <li>Parameter modification</li> <li>RQT tool usage for visualization</li> </ul>"},{"location":"sessions/session-10/#part-4-webots-ros2-integration","title":"Part 4: Webots-ROS2 Integration","text":""},{"location":"sessions/session-10/#41-webots-ros2-package-installation","title":"4.1 Webots ROS2 Package Installation","text":"<p>Reference Documentation: https://github.com/cyberbotics/webots_ros2/wiki/Getting-Started</p>"},{"location":"sessions/session-10/#42-installation-process","title":"4.2 Installation Process","text":"<p>Workspace Setup:</p> <ul> <li>Create ROS2 workspace directory structure</li> <li>Clone webots_ros2 repository</li> <li>Install package dependencies</li> <li>Build using colcon build system</li> </ul> <p>Key Steps Overview: 1. Workspace Creation - Establish src/ directory structure 2. Repository Cloning - Download webots_ros2 source code 3. Dependency Resolution - Install required packages 4. Colcon Build - Compile and install packages 5. Environment Sourcing - Update ROS2 environment</p>"},{"location":"sessions/session-10/#43-verification-and-testing","title":"4.3 Verification and Testing","text":"<p>Installation Verification: - Check package installation success - Verify Webots can launch ROS2 nodes - Test basic robot simulation with ROS2 integration</p>"},{"location":"sessions/session-10/#part-5-package-management-deep-dive","title":"Part 5: Package Management Deep Dive","text":""},{"location":"sessions/session-10/#51-installation-method-comparison","title":"5.1 Installation Method Comparison","text":"<p>APT Install (<code>apt install</code>)</p> <ul> <li>Purpose: System-wide package installation</li> <li>Scope: Ubuntu/Debian system packages</li> <li>Management: System package manager (dpkg)</li> <li>Dependencies: Automatic resolution via apt</li> <li>Use Case: Installing ROS2, system libraries, development tools</li> </ul> <p>PIP Install (<code>pip install</code>)</p> <ul> <li>Purpose: Python package installation</li> <li>Scope: Python ecosystem (PyPI)</li> <li>Management: Python package manager</li> <li>Dependencies: Python dependency resolution</li> <li>Use Case: Installing Python libraries, ML frameworks, utilities</li> </ul> <p>Colcon Build (<code>colcon build</code>)</p> <ul> <li>Purpose: ROS2 workspace compilation</li> <li>Scope: ROS2 packages from source</li> <li>Management: ROS2 build system</li> <li>Dependencies: ROS2 package dependencies</li> <li>Use Case: Building custom ROS2 packages, development workflow</li> </ul>"},{"location":"sessions/session-10/#52-package-ecosystem-importance","title":"5.2 Package Ecosystem Importance","text":"<p>For Python Development:</p> <ul> <li>Code Reusability - Avoid reinventing common functionality</li> <li>Dependency Management - Handle complex library interactions</li> <li>Version Control - Manage compatibility across packages</li> <li>Distribution - Share code across projects and teams</li> </ul> <p>For Robotics:</p> <ul> <li>Modularity - Separate perception, control, planning components</li> <li>Interoperability - Standard interfaces for component integration</li> <li>Community Contributions - Leverage open-source robotics packages</li> <li>Testing and Validation - Established, tested implementations</li> </ul> <p>For Software Development:</p> <ul> <li>Maintainability - Organized, modular codebase structure</li> <li>Collaboration - Shared understanding of package organization</li> <li>Scalability - Add functionality without monolithic complexity</li> <li>Quality Assurance - Tested, documented package implementations</li> </ul>"},{"location":"sessions/session-10/#53-package-management-best-practices","title":"5.3 Package Management Best Practices","text":"<p>Dependency Documentation:</p> <ul> <li>Maintain clear requirements.txt or package.xml files</li> <li>Document version constraints and compatibility</li> <li>Regular dependency updates and security patches</li> </ul> <p>Environment Isolation:</p> <ul> <li>Use virtual environments for Python projects</li> <li>Separate ROS2 workspaces for different projects</li> <li>Container-based development environments</li> </ul> <p>Version Control Integration:</p> <ul> <li>Track package manifests in version control</li> <li>Document installation procedures</li> <li>Automated dependency installation scripts</li> </ul>"},{"location":"sessions/session-10/#session-summary","title":"Session Summary","text":"<p>This session established the foundation for understanding ARI's software ecosystem by:</p> <ol> <li>Analyzing PAL Robotics package dependencies and software architecture decisions</li> <li>Setting up Ubuntu 24.04 VM environment with essential robotics development tools</li> <li>Learning ROS2 fundamentals through hands-on CLI tutorial experience</li> <li>Installing Webots-ROS2 integration using proper workspace and build procedures</li> <li>Understanding package management approaches and their respective use cases in development</li> </ol> <p>Question 1: What is the primary purpose of the PAL Robotics forks repository?</p> Click to reveal answer <p>Answer: </p> <p>The PAL Robotics forks repository contains modified versions of external packages that PAL Robotics maintains for compatibility, bug fixes, or custom features specific to their robot platforms like ARI. They maintain forks instead of using upstream packages to ensure version stability and add robot-specific functionality.</p> <p>Question 2: Explain the difference between apt install, pip install, and colcon build in terms of their scope and purpose.</p> Click to reveal answer <p>Answer: </p> <ul> <li>apt install: System-wide package installation for Ubuntu/Debian packages, managed by the system package manager</li> <li>pip install: Python-specific package installation from PyPI, managed by Python's package manager</li> <li>colcon build: ROS2 workspace compilation that builds ROS2 packages from source code, creating executable nodes and libraries</li> </ul> <p>Question 4: What are the four core ROS2 concepts introduced through the turtlesim tutorial</p> Click to reveal answer <p>Answer: </p> <ol> <li>Nodes - Independent computation units that perform specific tasks</li> <li>Topics - Asynchronous message passing channels for publisher-subscriber communication</li> <li>Services - Synchronous request-response communication for client-server interactions</li> <li>Parameters - Runtime configuration values that can be modified to change node behavior</li> </ol>"},{"location":"sessions/session-10/#preparation-for-next-session","title":"Preparation for Next Session","text":"<p>For our next session on advanced ARI integration:</p> <ul> <li>Complete turtlesim tutorial exercises if not finished in class</li> <li>Verify Webots-ROS2 installation is working properly</li> <li>Familiarize yourself with ROS2 workspace structure created during colcon build</li> <li>Review PAL Robotics packages identified during repository analysis</li> </ul> <p>Navigation: \u2190 Week 9 | Learning Plan | Week 11 \u2192mkdoc</p>"}]}