{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Robotics Programming Course","text":"<p>Welcome to the Robotics Programming Course covering ICTPRG430 (Apply introductory object-oriented language skills) and ICTPRG439 (Use pre-existing components).</p> Welcome to Country North Metropolitan TAFE recognises Australian Aboriginal and Torres Strait Islander People's unique cultural and spiritual relationships to the land, waters, and seas and their rich contribution to our society. We acknowledge the Mooro Boodjar pand Whadjuk Noongar People, the traditional custodians of the lands on which our campuses are located, and pay our respects to ancestors and Elders, past and present"},{"location":"#course-overview","title":"Course Overview","text":"<p>Duration: 18 sessions (4 hours each, weekly delivery) Focus: Object-oriented programming mastery and component reuse in robotics context Language: Python throughout Platform: Webots simulation with ROS integration for component demonstration Assessment: Portfolio-based with pass/fail requirements</p>"},{"location":"#quick-navigation","title":"Quick Navigation","text":""},{"location":"#course-information","title":"Course Information","text":"<ul> <li>Learning &amp; Assessment Plan - Complete 18-week course schedule</li> <li>Downloads &amp; Resources - Essential files and materials</li> <li>Assessment Information - Portfolio requirements</li> <li>Course Glossary - Key terms and definitions</li> </ul>"},{"location":"#weekly-sessions","title":"Weekly Sessions","text":"Weeks 1-3: Programming FundamentalsWeeks 4-7: OOP TheoryWeeks 8-12: Applied OOP RoboticsWeeks 13-15: Component ResearchWeeks 16-18: Integration &amp; Assessment <p>Building strong testing and debugging foundations</p> <ul> <li>Week 1: Unit Testing Foundations &amp; Binary Search</li> <li>Week 2: Advanced Testing &amp; Algorithmic Challenges  </li> <li>Week 3: Professional Testing &amp; Development Environment</li> </ul> <p>Mastering object-oriented programming concepts</p> <ul> <li>Week 4: Object Model &amp; Class Fundamentals</li> <li>Week 5: Advanced Class Features &amp; Magic Methods</li> <li>Week 6: Inheritance &amp; Polymorphism Mastery</li> <li>Week 7: File I/O &amp; Documentation Standards</li> </ul> <p>Implementing OOP principles in robotics projects</p> <ul> <li>Week 8: Felipe Lab 1 OOP Refactoring</li> <li>Week 9: Felipe Lab 2 OOP Implementation</li> <li>Week 10: Felipe Lab 3 OOP Navigation</li> <li>Week 11: Felipe Lab 4 OOP Control Systems</li> <li>Week 12: Felipe Lab 5 OOP Mission Integration</li> </ul> <p>Analyzing and selecting pre-existing components</p> <ul> <li>Week 13: ROS Component Analysis &amp; Research</li> <li>Week 14: Component Evaluation &amp; Selection</li> <li>Week 15: Integration Planning &amp; Environment Setup</li> </ul> <p>Component integration and final assessment</p> <ul> <li>Week 16: ROS Component Integration - Line Follower</li> <li>Week 17: System Assembly &amp; Documentation</li> <li>Week 18: Portfolio Review &amp; Competency Validation</li> </ul>"},{"location":"#key-resources","title":"Key Resources","text":"<p>Essential Downloads</p> <p>Visit the Downloads page for:</p> <ul> <li>Development environment setup files</li> <li>Project templates and starter code</li> <li>Assessment rubrics and submission templates</li> <li>Lab exercise materials</li> </ul> <p>Getting Started</p> <ol> <li>Review the Learning &amp; Assessment Plan</li> <li>Set up your development environment using materials from Downloads</li> <li>Check the Glossary for key terminology</li> <li>Begin with Week 1</li> </ol>"},{"location":"#assessment-portfolio","title":"Assessment Portfolio","text":"<p>Your competency will be demonstrated through two main portfolio components:</p> <ul> <li>Portfolio 1: OOP Fundamentals and Applied Robotics (Weeks 1-12)</li> <li>Portfolio 2: Component Integration (Weeks 13-17)</li> </ul> <p>Each portfolio includes both theoretical understanding and practical implementation tasks.</p>"},{"location":"#current-week-navigation","title":"Current Week Navigation","text":"<p>Quick Week Access</p> <p>Jump directly to any week:</p> <p>Fundamentals: Week 1 | Week 2 | Week 3</p> <p>OOP Theory: Week 4 | Week 5 | Week 6 | Week 7</p> <p>Applied Robotics: Week 8 | Week 9 | Week 10 | Week 11 | Week 12</p> <p>Components: Week 13 | Week 14 | Week 15</p> <p>Integration: Week 16 | Week 17 | Week 18</p> <p>Ready to begin? Start with the Learning &amp; Assessment Plan or jump directly to Week 1.     - Session 9: Felipe Lab 2 OOP Implementation     - Session 10: Felipe Lab 3 OOP Navigation     - Session 11: Felipe Lab 4 OOP Control Systems     - Session 12: Felipe Lab 5 OOP Mission Integration</p> Phase 4: Component ResearchPhase 5: IntegrationPhase 6: Assessment <p>Sessions 13-15 - Analyzing and selecting pre-existing components</p> <ul> <li>Session 13: ROS Component Analysis &amp; Research</li> <li>Session 14: Component Evaluation &amp; Selection</li> <li>Session 15: Integration Planning &amp; Environment Setup</li> </ul> <p>Sessions 16-17 - Implementing component integration</p> <ul> <li>Session 16: ROS Component Integration - Line Follower</li> <li>Session 17: System Assembly &amp; Documentation</li> </ul> <p>Session 18 - Final competency validation</p> <ul> <li>Session 18: Portfolio Review &amp; Competency Validation</li> </ul>"},{"location":"#key-resources_1","title":"Key Resources","text":"<p>Essential Downloads</p> <p>Visit the (under development) page for:</p> <ul> <li>Development environment setup files</li> <li>Project templates and starter code</li> <li>Lab exercise materials</li> </ul> <p>Getting Started</p> <ol> <li>Review the Learning &amp; Assessment Plan</li> <li>Set up your development environment using materials from Downloads</li> <li>Check the Glossary for key terminology</li> <li>Begin with Session 1</li> </ol>"},{"location":"#assessment-portfolio_1","title":"Assessment Portfolio","text":"<p>Your competency will be demonstrated through two main portfolio components:</p> <ul> <li>Portfolio 1: OOP Fundamentals and Applied Robotics (Sessions 1-12)</li> <li>Portfolio 2: Component Integration (Sessions 13-17)</li> </ul> <p>Each portfolio includes both theoretical understanding and practical implementation tasks.</p>"},{"location":"#support-and-resources","title":"Support and Resources","text":"<ul> <li>Glossary - Definitions of key terms and concepts</li> <li>API Reference - Technical documentation (under development)</li> <li>Troubleshooting - Common issues and solutions (under development)</li> </ul> <p>Ready to begin? Start with the Learning &amp; Assessment Plan to understand the complete course structure.</p>"},{"location":"downloads/","title":"Downloads","text":"<p>This page provides access to all essential files, templates, and resources for the Robotics Programming Course.</p>"},{"location":"downloads/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"downloads/#python-development-tools","title":"Python Development Tools","text":"<p>Python Installation</p> <p>Required Python version: 3.9 or higher</p> File Description Size Download <code>python_requirements.txt</code> Python package dependencies 2KB  Download <code>vscode_settings.json</code> VS Code configuration for Python 1KB  Download <code>pytest_config.ini</code> pytest configuration file 1KB  Download"},{"location":"downloads/#webots-simulation-environment","title":"Webots Simulation Environment","text":"File Description Size Download <code>webots_worlds.zip</code> Collection of Webots world files 5MB  Download <code>epuck_controller_template.py</code> Base e-puck controller template 3KB  Download <code>webots_setup_guide.pdf</code> Installation and configuration guide 2MB  Download"},{"location":"downloads/#assessment-materials","title":"Assessment Materials","text":""},{"location":"downloads/#portfolio-templates","title":"Portfolio Templates","text":"File Description Size Download <code>portfolio_1_template.docx</code> ICTPRG430 Portfolio Template 50KB  Download <code>portfolio_2_template.docx</code> ICTPRG439 Portfolio Template 45KB  Download <code>assessment_rubric.pdf</code> Detailed assessment criteria 150KB  Download"},{"location":"downloads/#code-templates","title":"Code Templates","text":"File Description Size Download <code>robot_class_starter.py</code> Basic Robot class structure 2KB  Download <code>unittest_template.py</code> Unit testing template 1KB  Download <code>oop_project_structure.zip</code> Complete project folder structure 10KB  Download"},{"location":"downloads/#phase-specific-resources","title":"Phase-Specific Resources","text":""},{"location":"downloads/#phase-1-programming-fundamentals","title":"Phase 1: Programming Fundamentals","text":"File Description Size Download <code>exercism_track_guide.pdf</code> Exercism platform usage guide 1MB  Download <code>binary_search_starter.py</code> Binary search implementation starter 1KB  Download <code>debugging_exercises.zip</code> Collection of debugging exercises 15KB  Download"},{"location":"downloads/#phase-2-oop-theory","title":"Phase 2: OOP Theory","text":"File Description Size Download <code>class_design_examples.zip</code> Example class implementations 25KB  Download <code>magic_methods_reference.py</code> Python magic methods examples 8KB  Download <code>inheritance_hierarchy.py</code> Robot inheritance examples 5KB  Download"},{"location":"downloads/#week-4-object-model-class-fundamentals","title":"Week 4: Object Model &amp; Class Fundamentals","text":"<p>Lab Attribution</p> <p>Lab exercises are based on Felipe Martins' excellent Robotics-Simulation-Labs repository.</p> File Description Size Download <code>robot_class_starter.py</code> Basic Robot class template 2KB  Download <code>class_implementation_examples.py</code> Complete class implementations 15KB  Download <code>lidar_procedural_clean.py</code> LIDAR procedural implementation 1KB  Download <code>lidar_functional_clean.py</code> LIDAR functional implementation 1KB  Download <code>lidar_oop_clean.py</code> LIDAR object-oriented implementation 2KB  Download"},{"location":"downloads/#phase-3-applied-oop-robotics","title":"Phase 3: Applied OOP Robotics","text":"File Description Size Download <code>felipe_labs_oop.zip</code> OOP versions of Felipe Martins labs 100KB  Download <code>sensor_processing_classes.py</code> Sensor handling class examples 12KB  Download <code>pid_controller_oop.py</code> Object-oriented PID controller 6KB  Download"},{"location":"downloads/#phase-4-component-research","title":"Phase 4: Component Research","text":"File Description Size Download <code>ros_packages_list.xlsx</code> Curated list of ROS packages 25KB  Download <code>component_evaluation_matrix.xlsx</code> Evaluation criteria spreadsheet 18KB  Download <code>licensing_guide.pdf</code> Open source license analysis guide 800KB  Download"},{"location":"downloads/#phase-5-integration","title":"Phase 5: Integration","text":"File Description Size Download <code>ros_webots_bridge.zip</code> ROS-Webots integration package 2MB  Download <code>integration_test_template.py</code> Integration testing framework 4KB  Download <code>system_documentation_template.docx</code> Technical documentation template 35KB  Download"},{"location":"downloads/#reference-materials","title":"Reference Materials","text":""},{"location":"downloads/#api-documentation","title":"API Documentation","text":"File Description Size Download <code>webots_python_api.pdf</code> Webots Python API reference 5MB  Download <code>ros_python_cheatsheet.pdf</code> ROS Python programming guide 2MB  Download"},{"location":"downloads/#code-style-and-standards","title":"Code Style and Standards","text":"File Description Size Download <code>python_style_guide.pdf</code> Course Python coding standards 500KB  Download <code>docstring_examples.py</code> Documentation string examples 3KB  Download <code>.pylintrc</code> Python linting configuration 2KB  Download"},{"location":"downloads/#installation-instructions","title":"Installation Instructions","text":"<p>Prerequisites</p> <p>Before downloading and using these files, ensure you have:</p> <ul> <li>Python 3.9+ installed</li> <li>Git for version control</li> <li>A code editor (VS Code recommended)</li> <li>Sufficient disk space (minimum 2GB for all materials)</li> </ul>"},{"location":"downloads/#quick-setup","title":"Quick Setup","text":"<ol> <li>Download Core Files: Start with <code>python_requirements.txt</code> and <code>vscode_settings.json</code></li> <li>Install Dependencies: Run <code>pip install -r python_requirements.txt</code></li> <li>Configure IDE: Import VS Code settings for optimal Python development</li> <li>Verify Setup: Run the verification script (available in session materials)</li> </ol>"},{"location":"downloads/#file-organization","title":"File Organization","text":"<p>Recommended folder structure for downloaded materials:</p> <pre><code>robotics_course/\n\u251c\u2500\u2500 assessment/\n\u2502   \u251c\u2500\u2500 portfolios/\n\u2502   \u2514\u2500\u2500 templates/\n\u251c\u2500\u2500 code/\n\u2502   \u251c\u2500\u2500 examples/\n\u2502   \u251c\u2500\u2500 templates/\n\u2502   \u2514\u2500\u2500 exercises/\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 guides/\n\u2502   \u2514\u2500\u2500 references/\n\u2514\u2500\u2500 webots/\n    \u251c\u2500\u2500 worlds/\n    \u2514\u2500\u2500 controllers/\n</code></pre>"},{"location":"downloads/#version-information","title":"Version Information","text":"<p>File Versions</p> <p>All files are maintained with version control. Check the filename or document header for version information. Latest updates as of August 2025.</p>"},{"location":"downloads/#need-help","title":"Need Help?","text":"<p>If you encounter issues downloading or using any files:</p> <ol> <li>Check the Troubleshooting guide</li> <li>Verify your internet connection and browser settings</li> <li>Contact your instructor for alternative download methods</li> </ol> <p>Files are updated regularly. Bookmark this page and check for updates before each session.</p>"},{"location":"course-overview/revised_lap/","title":"Learning and Assessment Plan - Robotics Programming Course","text":""},{"location":"course-overview/revised_lap/#ictprg430-apply-introductory-object-oriented-language-skills-ictprg439-use-pre-existing-components","title":"ICTPRG430 (Apply introductory object-oriented language skills) + ICTPRG439 (Use pre-existing components)","text":""},{"location":"course-overview/revised_lap/#course-overview","title":"Course Overview","text":"<p>Duration: 18 sessions (4 hours each, weekly delivery) Focus: Object-oriented programming mastery and component reuse in robotics context Language: Python throughout Platform: Webots simulation with ROS integration for component demonstration Assessment: Portfolio-based with pass/fail requirements</p>"},{"location":"course-overview/revised_lap/#learning-and-assessment-schedule","title":"Learning and Assessment Schedule","text":""},{"location":"course-overview/revised_lap/#phase-1-programming-fundamentals-sessions-1-3","title":"Phase 1: Programming Fundamentals (Sessions 1-3)","text":"Session Element Topic &amp; Focus Learning Resources* Structured out of class activities* Hours Week 1 (4hrs) ICTPRG430 Element 3.1 Unit Testing Foundations &amp; Binary SearchFocus: Test-driven development mindset, algorithmic thinking Exercism Platform, pytest documentation Complete Binary Search exercise with comprehensive test suite 2 Week 2 (4hrs) ICTPRG430 Element 3.1 Advanced Testing &amp; Algorithmic ChallengesFocus: Complex testing scenarios, debugging techniques Exercism Platform, Python debugging tools Complete additional algorithmic challenges with full test coverage 3 Week 3 (4hrs) ICTPRG430 Element 3.1 Professional Testing &amp; Development EnvironmentFocus: Industry testing practices, debugging tools mastery Python debugger documentation, IDE setup guides, testing frameworks Practice advanced debugging exercises, finalize development environment 2"},{"location":"course-overview/revised_lap/#phase-2-object-oriented-programming-theory-sessions-4-7","title":"Phase 2: Object-Oriented Programming Theory (Sessions 4-7)","text":"Session Element Topic &amp; Focus Learning Resources* Structured out of class activities* Hours Week 4 (4hrs) ICTPRG430 Element 2.1 Object Model &amp; Class FundamentalsFocus: Classes, objects, instantiation, instance variables/methods OOP programming fundamentals, class design principles Implement basic Robot class hierarchy with proper encapsulation 3 Week 5 (4hrs) ICTPRG430 Element 2.1 Advanced Class Features &amp; Magic MethodsFocus: Properties, class methods, magic methods, operators Python magic methods documentation, operator overloading guides Implement Robot class with full magic method suite and operators 3 Week 6 (4hrs) ICTPRG430 Element 2.1 Inheritance &amp; Polymorphism MasteryFocus: Class inheritance, super(), method resolution, polymorphic behaviors Inheritance design patterns, polymorphism examples Design complete robot inheritance hierarchy with polymorphic interfaces 4 Week 7 (4hrs) ICTPRG430 Element 2.2 File I/O &amp; Documentation StandardsFocus: File operations, JSON/XML parsing, professional documentation Python file handling documentation, docstring conventions Implement configuration system with comprehensive documentation 3 <p>Portfolio 1 Assessment Point</p> <p>AT Task 1 - OOP Fundamentals Portfolio (Due end of Week 7)</p>"},{"location":"course-overview/revised_lap/#phase-3-applied-oop-robotics-sessions-8-12","title":"Phase 3: Applied OOP Robotics (Sessions 8-12)","text":"Session Element Topic &amp; Focus Learning Resources* Structured out of class activities* Hours Week 8 (4hrs) ICTPRG430 Element 1.1 Felipe Lab 1 OOP RefactoringFocus: Convert procedural robot movement to class-based architecture Felipe Martins Lab 1, Webots Python API Refactor Lab 1 using OOP principles with unit test integration 3 Week 9 (4hrs) ICTPRG430 Element 2.1 Felipe Lab 2 OOP ImplementationFocus: Inheritance and sensor processing with line-following behavior Felipe Martins Lab 2, sensor processing algorithms Implement line-following robot with proper inheritance hierarchy 4 Week 10 (4hrs) ICTPRG430 Element 2.1 Felipe Lab 3 OOP NavigationFocus: Polymorphism and localization systems using OOP design Felipe Martins Lab 3, localization algorithms Create odometry-based navigation system with polymorphic interfaces 4 Week 11 (4hrs) ICTPRG430 Element 3.1 Felipe Lab 4 OOP Control SystemsFocus: Advanced algorithms and testing in object-oriented framework Felipe Martins Lab 4, PID control theory Implement PID controller system with comprehensive testing 3 Week 12 (4hrs) ICTPRG430 Element 4.1-4.2 Felipe Lab 5 OOP Mission IntegrationFocus: Complete system integration and user acceptance Felipe Martins Lab 5, behavior coordination Complete mission-based robot system with full documentation 4 <p>Portfolio 1 Assessment Point</p> <p>AT Task 2-5 - Applied OOP Robotics Portfolio (Due progressively through Weeks 8-12)</p>"},{"location":"course-overview/revised_lap/#phase-4-component-research-analysis-sessions-13-15","title":"Phase 4: Component Research &amp; Analysis (Sessions 13-15)","text":"Session Element Topic &amp; Focus Learning Resources* Structured out of class activities* Hours Week 13 (4hrs) ICTPRG439 Element 1.1-1.2 ROS Component Analysis &amp; ResearchFocus: Component identification, functionality analysis, source evaluation ROS package documentation, Mastering ROS Chapter 5 Research ROS packages for line-following robot enhancement 4 Week 14 (4hrs) ICTPRG439 Element 2.1-2.4 Component Evaluation &amp; SelectionFocus: Suitability assessment, licensing analysis, cost evaluation Open source licensing guides, cost analysis methodologies Complete formal component evaluation matrix for selected ROS packages 3 Week 15 (4hrs) ICTPRG439 Element 2.5-3.1 Integration Planning &amp; Environment SetupFocus: Technical impact analysis, ROS-Webots development environment Mastering ROS Chapter 5, ROS-Webots integration documentation Set up ROS-Webots integrated development environment 3"},{"location":"course-overview/revised_lap/#phase-5-component-integration-implementation-sessions-16-17","title":"Phase 5: Component Integration Implementation (Sessions 16-17)","text":"Session Element Topic &amp; Focus Learning Resources* Structured out of class activities* Hours Week 16 (4hrs) ICTPRG439 Element 3.2-3.4 ROS Component Integration - Line FollowerFocus: Test program development, incremental integration, dependency resolution Selected ROS component documentation, integration examples In-class development only - ROS integration with line-following robot 0 Week 17 (4hrs) ICTPRG439 Element 3.5-3.6 System Assembly &amp; DocumentationFocus: Final system testing, issue resolution, professional documentation Professional documentation templates, ROS best practices In-class development only - Complete system documentation and validation 0 <p>Portfolio 2 Assessment Point</p> <p>ICTPRG439 Component Integration Portfolio (Due end of Week 17)</p>"},{"location":"course-overview/revised_lap/#phase-6-assessment-completion-session-18","title":"Phase 6: Assessment &amp; Completion (Session 18)","text":"Session Element Topic &amp; Focus Learning Resources* Structured out of class activities* Hours Week 18 (4hrs) Both Units Portfolio Review &amp; Competency ValidationFocus: Final competency demonstration, portfolio completion, resit opportunities Course materials review, industry standards reference Review and complete any outstanding portfolio items 2"},{"location":"course-overview/revised_lap/#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Resources: Downloads &amp; Materials</li> <li>Assessment: Portfolio Requirements </li> <li>Reference: Course Glossary</li> </ul> <p>* Learning Resources and Structured Activities detailed in individual session pages</p>"},{"location":"files/downloads_page/","title":"Downloads","text":"<p>This page provides access to all essential files, templates, and resources for the Robotics Programming Course.</p>"},{"location":"files/downloads_page/#development-environment-setup","title":"Development Environment Setup","text":""},{"location":"files/downloads_page/#python-development-tools","title":"Python Development Tools","text":"<p>Python Installation</p> <p>Required Python version: 3.9 or higher</p> File Description Size Download <code>python_requirements.txt</code> Python package dependencies 2KB  Download <code>vscode_settings.json</code> VS Code configuration for Python 1KB  Download <code>pytest_config.ini</code> pytest configuration file 1KB  Download"},{"location":"files/downloads_page/#webots-simulation-environment","title":"Webots Simulation Environment","text":"File Description Size Download <code>webots_worlds.zip</code> Collection of Webots world files 5MB  Download <code>epuck_controller_template.py</code> Base e-puck controller template 3KB  Download <code>webots_setup_guide.pdf</code> Installation and configuration guide 2MB  Download"},{"location":"files/downloads_page/#assessment-materials","title":"Assessment Materials","text":""},{"location":"files/downloads_page/#portfolio-templates","title":"Portfolio Templates","text":"File Description Size Download <code>portfolio_1_template.docx</code> ICTPRG430 Portfolio Template 50KB  Download <code>portfolio_2_template.docx</code> ICTPRG439 Portfolio Template 45KB  Download <code>assessment_rubric.pdf</code> Detailed assessment criteria 150KB  Download"},{"location":"files/downloads_page/#code-templates","title":"Code Templates","text":"File Description Size Download <code>robot_class_starter.py</code> Basic Robot class structure 2KB  Download <code>unittest_template.py</code> Unit testing template 1KB  Download <code>oop_project_structure.zip</code> Complete project folder structure 10KB  Download"},{"location":"files/downloads_page/#phase-specific-resources","title":"Phase-Specific Resources","text":""},{"location":"files/downloads_page/#phase-1-programming-fundamentals","title":"Phase 1: Programming Fundamentals","text":"File Description Size Download <code>exercism_track_guide.pdf</code> Exercism platform usage guide 1MB  Download <code>binary_search_starter.py</code> Binary search implementation starter 1KB  Download <code>debugging_exercises.zip</code> Collection of debugging exercises 15KB  Download"},{"location":"files/downloads_page/#phase-2-oop-theory","title":"Phase 2: OOP Theory","text":"File Description Size Download <code>class_design_examples.zip</code> Example class implementations 25KB  Download <code>magic_methods_reference.py</code> Python magic methods examples 8KB  Download <code>inheritance_hierarchy.py</code> Robot inheritance examples 5KB  Download"},{"location":"files/downloads_page/#phase-3-applied-oop-robotics","title":"Phase 3: Applied OOP Robotics","text":"File Description Size Download <code>felipe_labs_oop.zip</code> OOP versions of Felipe Martins labs 100KB  Download <code>sensor_processing_classes.py</code> Sensor handling class examples 12KB  Download <code>pid_controller_oop.py</code> Object-oriented PID controller 6KB  Download"},{"location":"files/downloads_page/#phase-4-component-research","title":"Phase 4: Component Research","text":"File Description Size Download <code>ros_packages_list.xlsx</code> Curated list of ROS packages 25KB  Download <code>component_evaluation_matrix.xlsx</code> Evaluation criteria spreadsheet 18KB  Download <code>licensing_guide.pdf</code> Open source license analysis guide 800KB  Download"},{"location":"files/downloads_page/#phase-5-integration","title":"Phase 5: Integration","text":"File Description Size Download <code>ros_webots_bridge.zip</code> ROS-Webots integration package 2MB  Download <code>integration_test_template.py</code> Integration testing framework 4KB  Download <code>system_documentation_template.docx</code> Technical documentation template 35KB  Download"},{"location":"files/downloads_page/#reference-materials","title":"Reference Materials","text":""},{"location":"files/downloads_page/#api-documentation","title":"API Documentation","text":"File Description Size Download <code>webots_python_api.pdf</code> Webots Python API reference 5MB  Download <code>ros_python_cheatsheet.pdf</code> ROS Python programming guide 2MB  Download"},{"location":"files/downloads_page/#code-style-and-standards","title":"Code Style and Standards","text":"File Description Size Download <code>python_style_guide.pdf</code> Course Python coding standards 500KB  Download <code>docstring_examples.py</code> Documentation string examples 3KB  Download <code>.pylintrc</code> Python linting configuration 2KB  Download"},{"location":"files/downloads_page/#installation-instructions","title":"Installation Instructions","text":"<p>Prerequisites</p> <p>Before downloading and using these files, ensure you have:</p> <ul> <li>Python 3.9+ installed</li> <li>Git for version control</li> <li>A code editor (VS Code recommended)</li> <li>Sufficient disk space (minimum 2GB for all materials)</li> </ul>"},{"location":"files/downloads_page/#quick-setup","title":"Quick Setup","text":"<ol> <li>Download Core Files: Start with <code>python_requirements.txt</code> and <code>vscode_settings.json</code></li> <li>Install Dependencies: Run <code>pip install -r python_requirements.txt</code></li> <li>Configure IDE: Import VS Code settings for optimal Python development</li> <li>Verify Setup: Run the verification script (available in session materials)</li> </ol>"},{"location":"files/downloads_page/#file-organization","title":"File Organization","text":"<p>Recommended folder structure for downloaded materials:</p> <pre><code>robotics_course/\n\u251c\u2500\u2500 assessment/\n\u2502   \u251c\u2500\u2500 portfolios/\n\u2502   \u2514\u2500\u2500 templates/\n\u251c\u2500\u2500 code/\n\u2502   \u251c\u2500\u2500 examples/\n\u2502   \u251c\u2500\u2500 templates/\n\u2502   \u2514\u2500\u2500 exercises/\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 guides/\n\u2502   \u2514\u2500\u2500 references/\n\u2514\u2500\u2500 webots/\n    \u251c\u2500\u2500 worlds/\n    \u2514\u2500\u2500 controllers/\n</code></pre>"},{"location":"files/downloads_page/#version-information","title":"Version Information","text":"<p>File Versions</p> <p>All files are maintained with version control. Check the filename or document header for version information. Latest updates as of August 2025.</p>"},{"location":"files/downloads_page/#need-help","title":"Need Help?","text":"<p>If you encounter issues downloading or using any files:</p> <ol> <li>Check the Troubleshooting guide</li> <li>Verify your internet connection and browser settings</li> <li>Contact your instructor for alternative download methods</li> </ol> <p>Files are updated regularly. Bookmark this page and check for updates before each session.</p>"},{"location":"images/session-05/","title":"Session 5: Advanced Class Features &amp; Magic Methods","text":"<p>Week: 5 Element: ICTPRG430 Element 2.2 Duration: 4 hours Phase: Object-Oriented Programming </p>"},{"location":"images/session-05/#session-introduction","title":"Session Introduction","text":"<p>In this session, you'll explore advanced Python class features that make your robotics code more professional and maintainable. You'll learn how to make your robot objects display themselves clearly using magic methods (<code>__str__</code> and <code>__repr__</code>), understand the fundamentals of data encapsulation through getters and setters (both traditional and decorator approaches), and see how function wrapping works. The session culminates with Lab 2, where you'll implement a line-following robot using object-oriented principles in Webots simulator.</p>"},{"location":"images/session-05/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this session, you will be able to:</p> <ul> <li>Implement and distinguish between <code>__str__</code> and <code>__repr__</code> magic methods</li> <li>Understand when and why to use each string representation method</li> <li>Create getter and setter methods for controlled data access</li> <li>Apply the <code>@property</code> decorator for Pythonic attribute access</li> <li>Understand function wrapping concepts as preparation for decorators</li> <li>Design object-oriented solutions for line-following robot behaviors</li> <li>Implement sensor fusion and control logic in a robotics context</li> </ul>"},{"location":"images/session-05/#session-structure","title":"Session Structure","text":"<ol> <li>Theory Session - Magic methods and string representations</li> <li>Hands-on Exercise - Implementing <code>__str__</code> and <code>__repr__</code> for robot classes</li> <li>Data Encapsulation - Traditional getters/setters and property decorators</li> <li>Function Wrapping - Understanding decorator foundations</li> <li>Lab 2 - Line-following robot implementation in Webots</li> </ol>"},{"location":"images/session-05/#session-overview","title":"Session Overview","text":"<p>This session builds on the foundational OOP concepts from Session 4, introducing advanced class features that make your robotics code more robust and professional. We'll focus on how objects represent themselves and how to control access to object data.</p>"},{"location":"images/session-05/#pre-session-preparation","title":"Pre-Session Preparation","text":"<p>Setup Check</p> <p>Ensure your development environment is ready:</p> <pre><code>- Python 3.9+ with Webots integration working\n- VS Code with Python\n- Completed Session 4 robot class exercises\n</code></pre>"},{"location":"images/session-05/#1-magic-methods-making-objects-talk","title":"1. Magic Methods: Making Objects Talk","text":"<p>Magic methods (also called \"dunder methods\" because they have **d**ouble **under**scores) are special Python methods that define how objects behave in specific situations. Today we'll focus on the two most important ones for displaying object information: <code>__str__</code> and <code>__repr__</code>.</p>"},{"location":"images/session-05/#why-magic-methods-matter-in-robotics","title":"Why Magic Methods Matter in Robotics","text":"<p>When debugging robot behavior, you need clear, informative output about your objects. Without magic methods, Python gives you useless information:</p> <pre><code># Without magic methods - unhelpful output\nrobot = EPuckRobot(\"Alpha_7\", 98.5)\nprint(robot)\n# Output: &lt;__main__.EPuckRobot object at 0x7f8b8c0a1d30&gt;\n</code></pre> <p>With proper magic methods, you get meaningful information:</p> <pre><code># With magic methods - useful output\nrobot = EPuckRobot(\"Alpha_7\", 98.5)\nprint(robot)\n# Output: EPuckRobot(robot_id='Alpha_7', battery=98.5%, speed=0.0, moving=False)\n</code></pre>"},{"location":"images/session-05/#understanding-__str__-vs-__repr__","title":"Understanding <code>__str__</code> vs <code>__repr__</code>","text":"<p>Abstract</p> <p>\"Key Differences\"</p> <p><code>__str__</code> : For end users - human-readable, friendly format</p> <ul> <li>Called by <code>print()</code> and <code>str()</code></li> <li>Should be clear and informative for users</li> <li>Think: \"What would a robot operator want to see?\"</li> </ul> <p><code>__repr__</code>: For developers - precise, unambiguous format</p> <ul> <li>Called by <code>repr()</code> and when displaying in lists/debugger</li> <li>Should ideally be valid Python code to recreate the object</li> <li>Think: \"What would help a programmer debug this?\"</li> </ul>"},{"location":"images/session-05/#2-implementing-string-representations","title":"2. Implementing String Representations","text":"<p>Let's enhance our EPuckRobot class from Session 4 with proper string representations.</p>"},{"location":"images/session-05/#epuckrobot-enhanced-class-uml-structure","title":"EPuckRobot Enhanced Class UML Structure","text":"<pre><code>classDiagram\n    class EPuckRobot {\n        -str robot_id\n        -float battery_percentage\n        -float current_speed\n        -bool is_moving\n        +__init__(robot_id: str, initial_battery_percentage: float) EPuckRobot\n        +__str__() str\n        +__repr__() str\n        +move_forward(speed: float) void\n        +stop() void\n        +report_status() str\n    }\n\n    note for EPuckRobot \"Enhanced with string representation methods\\nfor better debugging and user interaction\"</code></pre> <p>Interactive Code Example</p> <p>Try this interactive example to experiment with the concepts:</p> <p></p>"},{"location":"images/session-05/#hands-on-exercise-enhanced-ir-sensor-with-string-representations","title":"Hands-on Exercise: Enhanced IR Sensor with String Representations","text":"<p>Building on Session 4's IR Sensor class, you'll now add professional string representations.</p>"},{"location":"images/session-05/#task-enhance-irsensor-with-magic-methods","title":"Task: Enhance IRSensor with Magic Methods","text":""},{"location":"images/session-05/#enhanced-irsensor-class-uml-structure","title":"Enhanced IRSensor Class UML Structure","text":"<pre><code>classDiagram\n    class IRSensor {\n        -str name\n        -int last_reading\n        +__init__(name: str) IRSensor\n        +__str__() str\n        +__repr__() str\n        +get_reading() int\n        +get_status() str\n    }\n\n    note for IRSensor \"Enhanced sensor with string representations\\nand reading history for better debugging\"</code></pre>"},{"location":"images/session-05/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<ol> <li> <p>Enhance your IRSensor class from Session 4 with these additions:</p> <ul> <li>Add a <code>last_reading</code> instance variable to store the most recent reading</li> <li>Implement <code>__str__()</code> for user-friendly display</li> <li>Implement <code>__repr__()</code> for debugging</li> <li>Add a <code>get_status()</code> method that returns detailed sensor information</li> <li> <p>Requirements for string methods:</p> </li> <li> <p><code>__str__()</code>: Should show sensor name and last reading in a friendly format</p> </li> <li><code>__repr__()</code>: Should show exact constructor call needed to recreate the sensor</li> <li>Handle the case when no reading has been taken yet</li> </ul> </li> </ol>"},{"location":"images/session-05/#complete-implementation-template","title":"Complete Implementation Template","text":"<pre><code>import random\n\nclass IRSensor:\n    \"\"\"Enhanced infrared distance sensor with string representations.\"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"\n        Initialize the IR sensor with a position name.\n\n        Args:\n            name (str): Position identifier for the sensor\n        \"\"\"\n        pass\n\n    def __str__(self):\n        \"\"\"\n        Return user-friendly string representation.\n\n        Returns:\n            str: Human-readable sensor status\n        \"\"\"\n        pass\n\n\n    def __repr__(self):\n        \"\"\"\n        Return developer-friendly string representation.\n\n        Returns:\n            str: Precise representation for debugging\n        \"\"\"\n        pass\n\n    def get_reading(self):\n        \"\"\"\n        Simulate getting a distance measurement from the IR sensor.\n\n        Returns:\n            int: Distance measurement in centimeters (1-100)\n        \"\"\"\n        pass\n\n    def get_status(self):\n        \"\"\"\n        Get detailed status information about the sensor.\n\n        Returns:\n            str: Detailed sensor status\n        \"\"\"\n        pass\n\"\n\nif __name__ == \"__main__\":\n    # Create sensor instances\n    sensors = [\n        IRSensor(\"Front Left\"),\n        IRSensor(\"Front Center\"),\n        IRSensor(\"Front Right\"),\n        IRSensor(\"Back Left\"),\n        IRSensor(\"Back Right\")\n    ]\n\n    print(\"\\n=== Initial Sensor Status ===\")\n    for sensor in sensors:\n        print(sensor)  # Uses __str__\n\n    print(\"\\n=== After Taking Readings ===\")\n    for sensor in sensors:\n        sensor.get_reading()\n\n    print(\"\\n=== Updated Sensor Display ===\")\n    for sensor in sensors:\n        print(sensor)  # Shows readings now\n\n    print(\"\\n=== Debugging View ===\")\n    print(\"Sensor list:\", sensors)  # Uses __repr__ for each sensor\n\n    print(\"\\n=== Detailed Status ===\")\n    for sensor in sensors:\n        print(sensor.get_status())\n</code></pre> <p>Expected Output (values will change for yours):</p> <pre><code>IR Sensor 'Front Left' initialized\nIR Sensor 'Front Center' initialized\nIR Sensor 'Front Right' initialized\nIR Sensor 'Back Left' initialized\nIR Sensor 'Back Right' initialized\n\n=== Initial Sensor Status ===\nFront Left Sensor: No readings taken\nFront Center Sensor: No readings taken\nFront Right Sensor: No readings taken\nBack Left Sensor: No readings taken\nBack Right Sensor: No readings taken\n\n=== After Taking Readings ===\nFront Left sensor reading: 42 cm\nFront Center sensor reading: 78 cm\nFront Right sensor reading: 15 cm\nBack Left sensor reading: 91 cm\nBack Right sensor reading: 33 cm\n\n=== Updated Sensor Display ===\nFront Left Sensor: 42 cm\nFront Center Sensor: 78 cm\nFront Right Sensor: 15 cm\nBack Left Sensor: 91 cm\nBack Right Sensor: 33 cm\n\n=== Debugging View ===\nSensor list: [IRSensor(name='Front Left'), IRSensor(name='Front Center'), IRSensor(name='Front Right'), IRSensor(name='Back Left'), IRSensor(name='Back Right')]\n\n=== Detailed Status ===\nSensor 'Front Left': Active (last reading: 42 cm)\nSensor 'Front Center': Active (last reading: 78 cm)\nSensor 'Front Right': Active (last reading: 15 cm)\nSensor 'Back Left': Active (last reading: 91 cm)\nSensor 'Back Right': Active (last reading: 33 cm)\n</code></pre> <p>!!! tip \"Best Practice Tip\" Notice how <code>__str__</code> provides information useful to robot operators, while <code>__repr__</code> shows exactly how to recreate the object. This distinction helps both users and developers.</p>"},{"location":"images/session-05/#3-data-encapsulation-controlling-access-to-object-data","title":"3. Data Encapsulation: Controlling Access to Object Data","text":"<p>Data encapsulation is about controlling how external code accesses and modifies object data. In robotics, this prevents dangerous operations like setting invalid motor speeds or battery levels.</p>"},{"location":"images/session-05/#the-problem-with-direct-attribute-access","title":"The Problem with Direct Attribute Access","text":"<pre><code># Direct access can lead to problems\nrobot = EPuckRobot(\"Alpha_7\", 98.5)\nrobot.battery_percentage = 150.0  # Invalid! Batteries can't exceed 100%\nrobot.current_speed = -0.5        # Invalid! Negative speed doesn't make sense\n</code></pre>"},{"location":"images/session-05/#traditional-getter-and-setter-methods","title":"Traditional Getter and Setter Methods","text":"<p>Before we learn the elegant decorator approach, let's understand the traditional method:</p>"},{"location":"images/session-05/#battery-management-class-uml-structure","title":"Battery Management Class UML Structure","text":"<pre><code>classDiagram\n    class BatteryManager {\n        -float _battery_level\n        +__init__(initial_level: float) BatteryManager\n        +get_battery_level() float\n        +set_battery_level(level: float) void\n        +is_battery_low() bool\n        +__str__() str\n        +__repr__() str\n    }\n\n    note for BatteryManager \"Encapsulates battery data with\\nvalidation and controlled access\"</code></pre> <pre><code>class BatteryManager:\n    \"\"\"Manages robot battery with controlled access.\"\"\"\n\n    def __init__(self, initial_level: float):\n        \"\"\"Initialize battery manager with validation.\"\"\"\n        self._battery_level = 0.0  # Private attribute (by convention)\n        self.set_battery_level(initial_level)  # Use setter for validation\n\n    def get_battery_level(self):\n        \"\"\"\n        Get current battery level.\n\n        Returns:\n            float: Battery level as percentage (0.0-100.0)\n        \"\"\"\n        return self._battery_level\n\n    def set_battery_level(self, level: float):\n        \"\"\"\n        Set battery level with validation.\n\n        Args:\n            level (float): Battery level percentage\n\n        Raises:\n            ValueError: If level is outside valid range\n        \"\"\"\n        if not isinstance(level, (int, float)):\n            raise TypeError(\"Battery level must be a number\")\n\n        if level &lt; 0.0:\n            raise ValueError(\"Battery level cannot be negative\")\n\n        if level &gt; 100.0:\n            raise ValueError(\"Battery level cannot exceed 100%\")\n\n        self._battery_level = float(level)\n        print(f\"Battery level set to {self._battery_level}%\")\n\n    def is_battery_low(self):\n        \"\"\"\n        Check if battery is low.\n\n        Returns:\n            bool: True if battery is below 20%\n        \"\"\"\n        return self._battery_level &lt; 20.0\n\n    def __str__(self):\n        \"\"\"User-friendly battery status.\"\"\"\n        status = \"LOW\" if self.is_battery_low() else \"OK\"\n        return f\"Battery: {self._battery_level}% ({status})\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return f\"BatteryManager(initial_level={self._battery_level})\"\n\n# Usage example\nif __name__ == \"__main__\":\n    # Create battery manager\n    battery = BatteryManager(85.0)\n    print(battery)\n\n    # Safe access through getters/setters\n    print(f\"Current level: {battery.get_battery_level()}%\")\n\n    # Validation prevents invalid values\n    try:\n        battery.set_battery_level(150.0)  # Will raise ValueError\n    except ValueError as e:\n        print(f\"Error: {e}\")\n\n    # Check battery status\n    battery.set_battery_level(15.0)\n    print(battery)\n    print(f\"Battery low: {battery.is_battery_low()}\")\n</code></pre>"},{"location":"images/session-05/#4-function-wrapping-understanding-decorator-foundations","title":"4. Function Wrapping: Understanding Decorator Foundations","text":"<p>Before learning the <code>@property</code> decorator, let's understand how function wrapping works. This concept is fundamental to understanding decorators.</p>"},{"location":"images/session-05/#basic-function-wrapping-example","title":"Basic Function Wrapping Example","text":"<pre><code>def validate_positive(func):\n    \"\"\"Wrapper that validates function arguments are positive.\"\"\"\n    def wrapper(value):\n        print(f\"Validating that {value} is positive...\")\n        if value &lt; 0:\n            raise ValueError(\"Value must be positive\")\n        result = func(value)\n        print(f\"Validation passed, result: {result}\")\n        return result\n    return wrapper\n\ndef calculate_square_root(number):\n    \"\"\"Calculate square root of a number.\"\"\"\n    return number ** 0.5\n\n# Wrap the function manually\nsafe_square_root = validate_positive(calculate_square_root)\n\n# Test the wrapped function\ntry:\n    result = safe_square_root(16.0)  # Works fine\n    print(f\"\u221a16 = {result}\")\n\n    result = safe_square_root(-4.0)  # Raises error\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"images/session-05/#how-this-relates-to-properties","title":"How This Relates to Properties","text":"<p>The <code>@property</code> decorator works similarly - it wraps your method to make it behave like an attribute. Understanding this concept helps you grasp how decorators work \"under the hood.\"</p>"},{"location":"images/session-05/#5-property-decorators-the-pythonic-way","title":"5. Property Decorators: The Pythonic Way","text":"<p>Now that you understand function wrapping, let's see how the <code>@property</code> decorator provides a cleaner approach to getters and setters.</p>"},{"location":"images/session-05/#enhanced-motor-controller-class-uml-structure","title":"Enhanced Motor Controller Class UML Structure","text":"<pre><code>classDiagram\n    class MotorController {\n        -float _speed\n        -float _max_speed\n        -bool _is_running\n        +__init__(max_speed: float) MotorController\n        +speed: float\n        +max_speed: float\n        +is_running: bool\n        +start() void\n        +stop() void\n        +__str__() str\n        +__repr__() str\n    }\n\n    note for MotorController \"Uses property decorators for clean,\\nvalidated attribute access\"</code></pre> <pre><code>class MotorController:\n    \"\"\"Motor controller with property-based encapsulation.\"\"\"\n\n    def __init__(self, max_speed: float = 1.0):\n        \"\"\"\n        Initialize motor controller.\n\n        Args:\n            max_speed (float): Maximum allowed speed (0.0-1.0)\n        \"\"\"\n        self._speed = 0.0\n        self._max_speed = max_speed\n        self._is_running = False\n        print(f\"Motor controller initialized (max speed: {max_speed})\")\n\n    @property\n    def speed(self):\n        \"\"\"\n        Get current motor speed.\n\n        Returns:\n            float: Current speed (0.0-1.0)\n        \"\"\"\n        return self._speed\n\n    @speed.setter\n    def speed(self, value):\n        \"\"\"\n        Set motor speed with validation.\n\n        Args:\n            value (float): Desired speed (0.0-max_speed)\n\n        Raises:\n            ValueError: If speed is outside valid range\n            TypeError: If speed is not a number\n        \"\"\"\n        if not isinstance(value, (int, float)):\n            raise TypeError(\"Speed must be a number\")\n\n        if value &lt; 0.0:\n            raise ValueError(\"Speed cannot be negative\")\n\n        if value &gt; self._max_speed:\n            raise ValueError(f\"Speed cannot exceed {self._max_speed}\")\n\n        self._speed = float(value)\n        self._is_running = (self._speed &gt; 0.0)\n        print(f\"Motor speed set to {self._speed}\")\n\n    @property\n    def max_speed(self):\n        \"\"\"Get maximum allowed speed.\"\"\"\n        return self._max_speed\n\n    @property\n    def is_running(self):\n        \"\"\"Check if motor is currently running.\"\"\"\n        return self._is_running\n\n    def start(self):\n        \"\"\"Start motor at current speed setting.\"\"\"\n        if self._speed &gt; 0.0:\n            self._is_running = True\n            print(f\"Motor started at speed {self._speed}\")\n        else:\n            print(\"Cannot start motor: speed is 0.0\")\n\n    def stop(self):\n        \"\"\"Stop motor (sets speed to 0).\"\"\"\n        self._speed = 0.0\n        self._is_running = False\n        print(\"Motor stopped\")\n\n    def __str__(self):\n        \"\"\"User-friendly motor status.\"\"\"\n        status = \"RUNNING\" if self._is_running else \"STOPPED\"\n        return f\"Motor: {status} at {self._speed}/{self._max_speed} speed\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return f\"MotorController(max_speed={self._max_speed})\"\n\n# Usage demonstrating property access\nif __name__ == \"__main__\":\n    # Create motor controller\n    motor = MotorController(0.8)  # Max speed of 0.8\n    print(motor)\n\n    # Property access looks like normal attribute access\n    print(f\"Current speed: {motor.speed}\")\n    print(f\"Max speed: {motor.max_speed}\")\n    print(f\"Is running: {motor.is_running}\")\n\n    # Set speed using property (calls the setter)\n    motor.speed = 0.5\n    print(motor)\n\n    # Try invalid values\n    try:\n        motor.speed = 1.2  # Exceeds max_speed\n    except ValueError as e:\n        print(f\"Error: {e}\")\n\n    try:\n        motor.speed = \"fast\"  # Wrong type\n    except TypeError as e:\n        print(f\"Error: {e}\")\n\n    # Properties are read-only where no setter is defined\n    try:\n        motor.max_speed = 1.0  # This will raise AttributeError\n    except AttributeError as e:\n        print(f\"Error: can't set max_speed - {e}\")\n</code></pre>"},{"location":"images/session-05/#comparing-approaches","title":"Comparing Approaches","text":"Aspect Traditional Getters/Setters Property Decorators Syntax <code>robot.get_speed()</code> / <code>robot.set_speed(0.5)</code> <code>robot.speed</code> / <code>robot.speed = 0.5</code> Readability More verbose Clean, attribute-like access Validation \u2705 Full control \u2705 Full control Pythonic Less Pythonic \u2705 Highly Pythonic Learning Curve Easier to understand initially Requires understanding decorators <p>!!! tip \"When to Use Each Approach\" - Traditional getters/setters: When you need complex validation logic or multiple parameters - Property decorators: For simple attribute access with validation (recommended for most cases)</p>"},{"location":"images/session-05/#check-your-knowledge","title":"Check Your Knowledge","text":"<p>Test your understanding of the advanced OOP concepts covered in this session:</p> <p>Question 1: <code>__str__</code> vs <code>__repr__</code> Purpose</p> <p>Question: You have a <code>RobotSensor</code> object. When would Python call <code>__str__()</code> vs <code>__repr__()</code>? Give specific examples.</p> Click to reveal answer <p>Answer: : </p> <p><code>__str__()</code> is called when: - You use <code>print(sensor)</code> - You use <code>str(sensor)</code>  - String formatting like <code>f\"Sensor data: {sensor}\"</code></p> <p><code>__repr__()</code> is called when: - You use <code>repr(sensor)</code> - The object appears in a list: <code>print([sensor1, sensor2])</code> - In the debugger or interactive shell when you just type the variable name - When <code>__str__()</code> is not defined, Python falls back to <code>__repr__()</code></p> <p>Question 2: Property Decorator Syntax</p> <p>Question: Look at this code. What's wrong with it?</p> <pre><code>class Robot:\n    def __init__(self):\n        self._speed = 0.0\n\n    @property\n    def speed(self, value):\n        self._speed = value\n</code></pre> Click to reveal answer <p>Answer: </p> <p>The <code>@property</code> decorator is used incorrectly. The method decorated with <code>@property</code> should be the getter (no parameters except <code>self</code>). To set values, you need a separate setter:</p> <pre><code>class Robot:\n    def __init__(self):\n        self._speed = 0.0\n\n    @property\n    def speed(self):  # Getter - no value parameter\n        return self._speed\n\n    @speed.setter\n    def speed(self, value):  # Setter - has value parameter\n        self._speed = value\n</code></pre> <p>````</p> Question 3: When to Use Properties <p>Question: Your robot has a <code>battery_level</code> that should never go below 0 or above 100. Should you use a property or just a regular attribute? Why?</p> Click to reveal answer <p>Answer: </p> <p>Use a property because you need validation. Here's why:</p> <ul> <li>Validation needed: Battery levels have strict limits (0-100%)</li> <li>Safety critical: Invalid battery levels could cause unsafe robot behavior</li> <li>Clean syntax: <code>robot.battery_level = 85</code> is cleaner than <code>robot.set_battery_level(85)</code></li> </ul> <p>Example implementation: <pre><code>@property\ndef battery_level(self):\n    return self._battery_level\n\n@battery_level.setter\ndef battery_level(self, value):\n    if not 0 &lt;= value &lt;= 100:\n        raise ValueError(\"Battery level must be 0-100%\")\n    self._battery_level = value\n</code></pre></p> Question 4: Understanding <code>self</code> in Magic Methods <p>Question: In <code>def __str__(self):</code>, what does <code>self</code> refer to, and why don't you need to pass it when calling <code>print(robot)</code>?</p> Click to reveal answer <p>Answer: </p> <ul> <li><code>self</code> refers to: The specific robot object that <code>__str__()</code> is being called on</li> <li>Why you don't pass it: Python automatically passes <code>self</code> when you call methods on objects</li> </ul> <p>When you write <code>print(robot)</code>: 1. Python internally calls <code>robot.__str__()</code> 2. Python automatically passes the <code>robot</code> object as the <code>self</code> parameter 3. Your <code>__str__</code> method can then access <code>self.robot_id</code>, <code>self.battery_percentage</code>, etc.</p> <p>This is the same reason you don't write <code>robot.move_forward(robot, 0.5)</code> - Python handles the <code>self</code> parameter automatically.</p> Question 5: Property vs Method Decision <p>Question: For each of these robot operations, should it be a property or a method? Explain your reasoning.</p> <ul> <li><code>robot.current_speed</code> (just getting the speed)</li> <li><code>robot.turn_left()</code> (making the robot turn)  </li> <li><code>robot.battery_percentage</code> (getting/setting battery level)</li> <li><code>robot.emergency_stop()</code> (immediate stop command)</li> </ul> Click to reveal answer <p>Answer: </p> <ul> <li><code>robot.current_speed</code> \u2192 Property: Getting data, no action performed, feels like an attribute</li> <li><code>robot.turn_left()</code> \u2192 Method: Performs an action, changes robot state, side effects</li> <li><code>robot.battery_percentage</code> \u2192 Property: Data that might need validation, attribute-like access</li> <li><code>robot.emergency_stop()</code> \u2192 Method: Critical action, clear that something important happens</li> </ul> <p>Rule of thumb:  - Properties: For data access (getting/setting values) that feels like attribute access - Methods: For actions, operations, or anything that \"does something\" to the object</p>"},{"location":"images/session-05/#lab-2-line-follower-robot-implementation","title":"Lab 2: Line-follower Robot Implementation","text":"<p>In this lab, you will implement a line-following robot using object-oriented programming principles in the Webots simulator. This lab builds on the OOP concepts learned in Sessions 4 and 5, applying them to a real robotics problem.</p> <p>Lab Credits</p> <p>This lab is adapted from the excellent work by Felipe Martins:</p> <p>Original Repository: Robotics-Simulation-Labs Author: Felipe Nascimento Martins License: Available on GitHub</p> <p>We acknowledge and appreciate the open-source contribution to robotics education.</p>"},{"location":"images/session-05/#about-line-following","title":"About Line Following","text":"<p>Line following is a fundamental robotics task where a robot uses sensors to detect and follow a path marked on the ground. This requires:</p> <ul> <li>Sensor data processing: Reading and interpreting sensor values</li> <li>Decision making: Determining robot actions based on sensor data</li> <li>Motor control: Translating decisions into wheel movements</li> <li>Real-time operation: Continuously processing sensor data and adjusting behavior</li> </ul>"},{"location":"images/session-05/#lab-setup","title":"Lab Setup","text":"<p>Before starting the implementation, ensure you have:</p> <ol> <li>Webots simulator installed and working (from Session 4)</li> <li>Python 3.9+ configured with Webots</li> <li>Basic understanding of OOP concepts from Sessions 4 and 5</li> </ol>"},{"location":"images/session-05/#first-do-the-lab","title":"First - do the Lab !","text":"<p>Lab 2 - Line-Following https://felipenmartins.github.io/Robotics-Simulation-Labs/Lab2/ </p>"},{"location":"images/session-05/#lab-2-line-follower-with-state-machine","title":"Lab 2 \u2013 Line-follower with State Machine","text":""},{"location":"images/session-05/#objectives","title":"Objectives","text":"<p>The goal of this lab is to learn more about controllers in Webots via the implementation of state machine to make the robot follow a line. </p>"},{"location":"images/session-05/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>You must have Webots R2022a (or newer) properly configured to work with Python. </li> <li>You must know how to create a robot controller in Python and how to run a simulation. </li> </ul> <p>If you are still missing any of those, please go back to Lab 1 and complete the corresponding tasks.</p>"},{"location":"images/session-05/#the-e-puck-robot","title":"The e-puck robot","text":"<p>Webots contains a realistic model of e-puck, a small differential-drive mobile robot. The movement of this type of robot is controlled by independently adjusting the speeds of the left and right wheels. </p> <p>The e-puck robot has multiple sensors. To detect obstacles, the e-puck contains 8 infrared distance sensors around its body. Optionally, 3 infrared sensors can be mounted under its base, pointing to the floor, allowing the implementation of a line-following behavior. </p> <p>An explanation about the e-puck robot and how to use it in Webots is available in Webots Tutorial 4.</p>"},{"location":"images/session-05/#tasks","title":"Tasks","text":"<p>1- Follow Webots Tutorial 4 to better understand the e-puck model and learn how to control it in Python.</p> <p>2- After finishing tutorial 4, open the line-following sample world: Click on <code>File &gt; Open Sample Worlds</code> and go to <code>robots &gt; gctronic &gt; e-puck</code> and select <code>e-puck_botstudio_with_floor_sensors.wbt</code>. You should see a world similar to the one shown in Figure 1. In the next steps you must use the e-puck robot that is loaded with this sample world because it has the floor sensors to detect the line. </p> <p></p>"},{"location":"images/session-05/#figure-1-webots-screenshot-with-the-world-e-puck_botstudio_with_floor_sensorswbt","title":"Figure 1. Webots screenshot with the world \u201ce-puck_botstudio_with_floor_sensors.wbt\u201d.","text":"<p>3- You will need to make changes to the file, so you have to save the sample world with a different name on a folder of your choice. </p> <p>4- Write a simple program to investigate the values returned by the floor sensors when the robot is over the white floor and over the black line. You can use the print function to show the sensor values in the Webots console. More information about how to read the ground sensors is given below.</p> <p>5- Test the motor speeds to determine how fast the robot should run and turn in order to follow the line.</p> <p>6- Create a new controller in Python and implement a line-following behavior using what you learned from the steps above. You can use the state machine shown in Figure 2 as reference. </p> <p>7- Finally, add one extra state to stop the robot when no line is detected.</p> <p></p>"},{"location":"images/session-05/#figure-2-a-state-machine-diagram-that-implements-a-line-follower-behavior","title":"Figure 2. A state machine diagram that implements a line-follower behavior.","text":""},{"location":"images/session-05/#ground-sensors","title":"Ground sensors","text":"<p>In Tutorial 4 you made use of the distance sensors around the robot. To detect the line on the floor you need to use the ground sensors, instead. The simulator also treats the ground sensors as distance sensors because they are of the same type (infrared sensors). In Python you can access the ground sensors as shown below.</p> <p>To initialize the ground sensors: <pre><code>gs = []\ngsNames = ['gs0', 'gs1', 'gs2']\nfor i in range(3):\n    gs.append(robot.getDevice(gsNames[i]))\n    gs[i].enable(timestep)\n</code></pre></p> <p>To read the ground sensors inside the main loop: <pre><code>gsValues = []\nfor i in range(3):\n    gsValues.append(gs[i].getValue())\n</code></pre></p> <p>To read sensor values inside the main loop: <pre><code>line_right = gsValues[0]\nline_center = gsValues[1]\nline_left = gsValues[2]\n</code></pre></p> <p>If you need inspiration, check the template code available here!</p>"},{"location":"images/session-05/#solution","title":"Solution","text":"<p>Try to implement the state machine yourself before checking the solution! A possible solution (without the stop state) is available here.</p> <p>The video below shows the solution code in action:</p> <p>.</p>"},{"location":"images/session-05/#challenge-obstacle-avoidance","title":"Challenge: Obstacle Avoidance","text":"<p>Change the state machine to make e-puck avoid obstacles placed on its way. You can choose the type of obstacle to add: different formats might require different strategies of obstacle avoidance. Obstacles with round or rectangular shape usually are the less demanding, while obstacles with U-shape require more complex strategies.</p> <p>An illustration of obstacle avoidance with state machine is given in Figure 3. Note that the obstacle avoidance strategy that was implemented required four extra states, some executing the same action as others. The animation in Figure 3 shows the active state (in red) for each condition during the simulation.</p> <p></p>"},{"location":"images/session-05/#figure-3-illustration-of-obstacle-avoidance-strategy-added-to-the-existing-line-follower-state-machine","title":"Figure 3. Illustration of obstacle avoidance strategy added to the existing line-follower state machine.","text":"<p>Student Wilfred van Reenen made the video below to illustrate the excellent performance of his obstacle avoidance state machine. If you want to go above and beyond, try to get your robot to avoid all those obstacles!</p> <p>.</p>"},{"location":"images/session-05/#conclusion","title":"Conclusion","text":"<p>After following this lab you should know more about the e-puck robot model, how to program a controller for it in Python, and how to program a robot behavior based on state machine. </p>"},{"location":"images/session-05/#next-lab","title":"Next Lab","text":"<p>Go to Lab 3 - Odometry-based Localization</p> <p>Back to main page.</p>"},{"location":"images/session-05/#line-following-robot-architecture","title":"Line-Following Robot Architecture","text":"<p>Our robot will use an object-oriented architecture with these main components:</p>"},{"location":"images/session-05/#testing-your-implementation","title":"Testing Your Implementation","text":"<ol> <li>Load the line following world in Webots</li> <li>Replace the default controller with your <code>line_follower_robot.py</code></li> <li>Run the simulation and observe the robot behavior</li> <li>Monitor the console output to see sensor readings and motor commands</li> </ol>"},{"location":"images/session-05/#expected-behavior","title":"Expected Behavior","text":"<p>Your robot should:</p> <ul> <li>Follow the line smoothly using sensor feedback</li> <li>Stop when obstacles are detected</li> <li>Display clear debugging information using the magic methods</li> <li>Handle edge cases like losing the line temporarily</li> </ul>"},{"location":"images/session-05/#debugging-tips","title":"Debugging Tips","text":"<p>Common Issues and Solutions</p> <pre><code>**Robot doesn't move**: Check that motors are properly initialized and `timestep` is correct\n\n**Erratic behavior**: Adjust the `base_speed` and `turn_speed` parameters\n\n**Line not detected**: Verify the sensor threshold values for your specific world\n\n**Console spam**: The debug output is limited to ~1 second intervals to keep it readable\n</code></pre>"},{"location":"images/session-05/#extension-challenges","title":"Extension Challenges","text":"<p>Once you have the basic implementation working, try these enhancements:</p> <ol> <li>Add speed control: Make the robot slow down in tight turns</li> <li>Implement PID control: Use proportional, integral, and derivative control for smoother following</li> <li>Add line-lost recovery: Handle situations where the robot completely loses the line</li> <li>Implement different following modes: Allow switching between fast/slow/precise modes</li> </ol>"},{"location":"images/session-05/#session-summary-advanced-oop-features-in-robotics","title":"Session Summary: Advanced OOP Features in Robotics","text":"<p>In this session, you've learned how to make your robotics code more professional and maintainable through advanced OOP features:</p>"},{"location":"images/session-05/#key-concepts-mastered","title":"Key Concepts Mastered","text":"<pre><code>mindmap\n  root((Advanced OOP Features))\n    Magic Methods\n      __str__ for users\n      __repr__ for developers\n      Better debugging\n    Data Encapsulation\n      Traditional getters/setters\n      Property decorators\n      Data validation\n    Function Wrapping\n      Decorator foundations\n      Understanding @property\n      Code organization\n    Practical Application\n      Line following robot\n      Sensor fusion\n      Object-oriented architecture</code></pre>"},{"location":"images/session-05/#design-patterns-used","title":"Design Patterns Used","text":"<p>Throughout this session, we've implemented several important design patterns:</p> <ul> <li>Encapsulation: Hiding internal data and providing controlled access</li> <li>Composition: Building complex objects from simpler components</li> <li>Single Responsibility: Each class has one clear purpose</li> <li>Property Pattern: Clean attribute-like access with validation</li> </ul> <p>!!! success \"Professional Development\" The techniques learned in this session are used in production robotics software. You're now writing code that follows industry best practices!</p>"},{"location":"images/session-05/#out-of-class-research-activities","title":"Out-of-Class Research Activities","text":"<p>To reinforce your understanding and prepare for advanced topics:</p>"},{"location":"images/session-05/#research-topics","title":"Research Topics","text":"<ol> <li> <p>Python Magic Methods Deep Dive</p> <ul> <li>Research other useful magic methods (<code>__eq__</code>, <code>__lt__</code>, <code>__len__</code>)</li> <li>Find examples of magic methods in robotics frameworks</li> <li>Study how magic methods enable operator overloading</li> <li> <p>Property Decorators Advanced Usage</p> </li> <li> <p>Investigate read-only properties and computed properties</p> </li> <li>Research property caching for expensive calculations</li> <li>Look into property validation patterns</li> <li> <p>Robotics Control Systems</p> </li> <li> <p>Study PID controllers and their implementation in OOP</p> </li> <li>Research state machines for robot behavior</li> <li>Investigate sensor fusion algorithms and OOP design</li> <li> <p>Code Quality and Testing</p> </li> <li> <p>Research unit testing for robotics code</p> </li> <li>Study debugging techniques for real-time systems</li> <li>Investigate logging best practices for robotics applications</li> </ul> </li> </ol> <p>!!! tip \"Recommended Resources\" - Python official documentation on data model - Real Python articles on properties and magic methods - Open-source robotics projects showing OOP patterns - ROS (Robot Operating System) architectural documentation</p>"},{"location":"images/session-05/#next-session-preview","title":"Next Session Preview","text":"<p>Week 6: Inheritance &amp; Polymorphism</p> <ul> <li>Creating class hierarchies for different robot types</li> <li>Method overriding and super() usage</li> <li>Abstract base classes for robotics interfaces</li> <li>Polymorphic behavior in sensor and actuator systems</li> <li>Advanced UML diagrams and design patterns</li> </ul>"},{"location":"images/session-05/#resources","title":"Resources","text":""},{"location":"images/session-05/#downloads","title":"Downloads","text":"<ul> <li> Enhanced robot classes with magic methods</li> <li> Complete line follower implementation</li> <li> Property decorator examples</li> <li> Function wrapping tutorial</li> <li> All Week 5 resources</li> </ul>"},{"location":"images/session-05/#lab-files","title":"Lab Files","text":"<ul> <li> Line follower Webots world</li> <li> Robot controller template</li> </ul>"},{"location":"images/session-05/#further-reading","title":"Further Reading","text":"<ul> <li>Python Data Model Documentation</li> <li>Property Decorator Patterns</li> <li>Robotics Software Engineering Best Practices</li> <li>Object-Oriented Design Patterns in Robotics</li> </ul> <p>Navigation: \u2190 Week 4 | Learning Plan | Week 6 \u2192</p>"},{"location":"reference/glossary_page/","title":"Glossary","text":"<p>A comprehensive reference for key terms and concepts used throughout the Robotics Programming Course.</p>"},{"location":"reference/glossary_page/#a","title":"A","text":"Abstract Base Class (ABC) A class that cannot be instantiated directly and is designed to be inherited by other classes. Contains one or more abstract methods that must be implemented by concrete subclasses. Algorithm A step-by-step procedure for solving a problem or completing a task, often implemented as a function or method in programming. API (Application Programming Interface) A set of protocols, routines, and tools for building software applications. Defines how software components should interact. Argument A value passed to a function or method when it is called. Arguments provide input data for the function to process."},{"location":"reference/glossary_page/#b","title":"B","text":"Binary Search An efficient algorithm for finding an item in a sorted list by repeatedly dividing the search interval in half. Bug An error or flaw in a computer program that causes it to produce incorrect or unexpected results."},{"location":"reference/glossary_page/#c","title":"C","text":"Class A blueprint or template for creating objects in object-oriented programming. Defines attributes and methods that the objects will have. Class Method A method that belongs to the class rather than any particular instance. Defined using the <code>@classmethod</code> decorator in Python. Component A modular, reusable piece of software that encapsulates functionality and can be integrated into larger systems. Constructor A special method called when an object is instantiated. In Python, this is the <code>__init__()</code> method that initializes the object's state. Control System A system that manages and regulates the behavior of other systems using control loops and feedback mechanisms."},{"location":"reference/glossary_page/#d","title":"D","text":"Debugging The process of finding and fixing bugs or errors in computer programs. Dependency A relationship where one piece of software relies on another to function properly. Docstring A string literal that appears as the first statement in a Python module, function, class, or method definition, used for documentation. Duck Typing A programming concept where the type or class of an object is less important than the methods it implements."},{"location":"reference/glossary_page/#e","title":"E","text":"Encapsulation An OOP principle that bundles data and methods that operate on that data within a single unit (class), hiding internal implementation details. E-puck Robot A small differential wheeled mobile robot developed for education and research, commonly used in robotics courses. Exception An error that occurs during program execution, which can be handled using try-catch blocks to prevent program crashes. Exercism An online platform providing coding practice exercises with mentorship, used for skill development in various programming languages."},{"location":"reference/glossary_page/#f","title":"F","text":"Felipe Martins Labs A series of progressive robotics exercises focusing on robot navigation, sensor processing, and autonomous behavior implementation. Function A reusable block of code that performs a specific task, takes inputs (parameters), and may return a value."},{"location":"reference/glossary_page/#g","title":"G","text":"Git A distributed version control system used for tracking changes in source code during software development. GUI (Graphical User Interface) A visual interface that allows users to interact with software through graphical elements like buttons, menus, and windows."},{"location":"reference/glossary_page/#i","title":"I","text":"IDE (Integrated Development Environment) A software application providing comprehensive facilities for software development, typically including a code editor, debugger, and build automation tools. Inheritance An OOP principle allowing a class to inherit attributes and methods from another class, promoting code reuse and establishing hierarchical relationships. Instance A concrete occurrence of a class; an object created from a class blueprint with its own unique state. Instance Method A method that operates on an instance of a class and has access to the instance's attributes through the <code>self</code> parameter. Instance Variable A variable that belongs to a specific instance of a class, holding data unique to that object. Integration Testing Testing performed to verify that different modules or components work correctly when combined."},{"location":"reference/glossary_page/#l","title":"L","text":"Library A collection of pre-written code and functions that can be imported and used in programs to provide specific functionality. Line Following A robotic behavior where a robot follows a predetermined path marked by a line on the ground using sensors."},{"location":"reference/glossary_page/#m","title":"M","text":"Magic Method (Dunder Method) Special methods in Python that start and end with double underscores (e.g., <code>__init__</code>, <code>__str__</code>), providing customizable behavior for built-in operations. Method A function defined within a class that can access and manipulate the object's attributes. Method Resolution Order (MRO) The order in which Python searches for methods in a class hierarchy, important for inheritance and method overriding. MkDocs A static site generator designed for creating project documentation from Markdown files. Modularity The design principle of breaking down complex systems into smaller, independent, and interchangeable components."},{"location":"reference/glossary_page/#o","title":"O","text":"Object An instance of a class that contains data (attributes) and code (methods) that operate on that data. Object-Oriented Programming (OOP) A programming paradigm based on the concept of objects, emphasizing encapsulation, inheritance, and polymorphism. Odometry A method of estimating position and orientation of a robot based on data from motion sensors. Operator Overloading The ability to define custom behavior for built-in operators (like +, -, ==) when used with user-defined classes."},{"location":"reference/glossary_page/#p","title":"P","text":"Package A collection of related modules organized in a directory structure, providing a way to organize and distribute code. Parameter A variable listed in a function definition that accepts values passed as arguments when the function is called. PID Controller A control loop mechanism that uses Proportional, Integral, and Derivative terms to minimize error in system control. Polymorphism An OOP principle allowing objects of different classes to be treated as instances of the same type through a common interface. Portfolio Assessment An evaluation method where students compile a collection of work demonstrating their learning and competency development. Property A Python feature that allows methods to be accessed like attributes, often used with getter and setter methods. pytest A testing framework for Python that makes it easy to write simple and scalable test cases. Python A high-level, interpreted programming language known for its simplicity and readability, widely used in robotics and education."},{"location":"reference/glossary_page/#r","title":"R","text":"Refactoring The process of restructuring existing code without changing its external behavior to improve readability, maintainability, or performance. Repository A storage location for software packages or source code, often managed by version control systems like Git. Robotics The interdisciplinary field combining mechanical engineering, electrical engineering, and computer science to design and operate robots. ROS (Robot Operating System) An open-source framework providing tools, libraries, and conventions for developing robot software."},{"location":"reference/glossary_page/#s","title":"S","text":"Sensor A device that detects and measures physical properties from the environment and converts them into signals for processing. Simulation The use of computer models to replicate real-world processes or systems for testing, training, or analysis purposes. Static Method A method that belongs to a class but doesn't access instance or class-specific data. Defined using the <code>@staticmethod</code> decorator in Python. Subclass A class that inherits from another class (superclass), extending or modifying its functionality. Superclass (Parent Class) A class from which other classes inherit attributes and methods."},{"location":"reference/glossary_page/#t","title":"T","text":"Test-Driven Development (TDD) A software development approach where tests are written before the actual code implementation. Test Suite A collection of test cases designed to verify that a software application behaves as expected. Type Hint Python syntax that allows developers to indicate the expected data types of function parameters and return values."},{"location":"reference/glossary_page/#u","title":"U","text":"Unit Testing Testing individual components or modules of software in isolation to ensure they work correctly. UML (Unified Modeling Language) A standardized modeling language used to visualize system design and architecture."},{"location":"reference/glossary_page/#v","title":"V","text":"Variable A named storage location in computer memory that holds data that can be modified during program execution. Version Control A system that records changes to files over time, allowing you to recall specific versions and collaborate with others. Virtual Environment An isolated Python environment that allows you to install packages without affecting the global Python installation."},{"location":"reference/glossary_page/#w","title":"W","text":"Webots A professional mobile robot simulation software package that provides a complete development environment for modeling, programming, and simulating mobile robots. Wheel Encoder A sensor that measures the rotation of robot wheels, used for odometry and motion control."},{"location":"reference/glossary_page/#additional-resources","title":"Additional Resources","text":"<p>Expanding Your Knowledge</p> <p>For more detailed explanations of programming concepts, consider these resources:</p> <ul> <li>Python Official Documentation: python.org</li> <li>Real Python Tutorials: In-depth Python programming guides</li> <li>ROS Documentation: ros.org</li> <li>Webots User Guide: Comprehensive simulation environment documentation</li> </ul> <p>Course-Specific Terms</p> <p>This glossary focuses on terms relevant to ICTPRG430 and ICTPRG439. Additional robotics and programming terminology may be encountered in advanced coursework.</p> <p>Last updated: August 2025 | Suggestions for additional terms? Contact your instructor.</p>"},{"location":"sessions/session-04/","title":"Session 4: Object Model &amp; Class Fundamentals","text":"<p>Week: 4 Element: ICTPRG430 Element 2.1 Duration: 4 hours Phase: Object-Oriented Programming Theory</p>"},{"location":"sessions/session-04/#session-introduction","title":"Session Introduction","text":"<p>In this session you will explore the foundational concepts of Object-Oriented Programming (OOP) through practical robotics applications. You'll begin with understanding why OOP is essential for robotics development, then dive into hands-on implementation of classes and objects. The session includes a comprehensive theory component, followed by practical exercises where you'll create IR sensor classes, witness a live demonstration of LIDAR implementation across different programming paradigms (procedural, functional, and object-oriented), explore advanced filtering techniques, and conclude with setting up Webots for future simulation work.</p>"},{"location":"sessions/session-04/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this session, you will be able to:</p> <ul> <li>Understand fundamental OOP concepts: classes, objects, and object instantiation</li> <li>Implement states (using instance variables) and behaviors (using instance methods) for robot systems  </li> <li>Explain constructor design and instance variables</li> <li>Apply encapsulation principles in robotics contexts</li> <li>Create and use multiple sensor objects in a robotics context</li> <li>Compare procedural, functional, and object-oriented programming approaches</li> <li>Set up Webots robotics simulator for future labs</li> </ul>"},{"location":"sessions/session-04/#session-structure","title":"Session Structure","text":"<ol> <li>Theory Session - Object-Oriented Programming fundamentals</li> <li>Hands-on Exercise - Create IR Sensor classes</li> <li>Live Demonstration - LIDAR implementation in three programming paradigms</li> <li>Extension Activity - Advanced LIDAR data filtering techniques</li> <li>Lab Setup - Webots simulator installation and configuration</li> </ol>"},{"location":"sessions/session-04/#session-overview","title":"Session Overview","text":"<p>This session introduces the fundamental concepts of Object-Oriented Programming (OOP) through the lens of robotics applications. You'll learn why OOP is particularly valuable for robotics development and how to implement basic class structures.</p>"},{"location":"sessions/session-04/#pre-session-preparation","title":"Pre-Session Preparation","text":"<p>Required Reading</p> <p>Review the following materials before class:</p> <ul> <li>OOP programming fundamentals documentation</li> <li>Class design principles guide</li> <li>Download: Basic Robot Class Starter</li> </ul> <p>Setup Check</p> <p>Ensure your Python development environment is configured:</p> <ul> <li>Python 3.9+ installed and working</li> <li>VS Code with Python extension</li> <li>pytest framework installed</li> </ul>"},{"location":"sessions/session-04/#1-why-object-oriented-programming-for-robotics","title":"1. Why Object-Oriented Programming for Robotics?","text":"<p>Object-Oriented Programming was developed to manage the increasing complexity of large software systems. Robotics deals with highly intricate systems involving numerous sensors, actuators, and algorithms, making OOP an invaluable paradigm for developing robust and maintainable robot software.</p>"},{"location":"sessions/session-04/#key-advantages-for-robotics","title":"Key Advantages for Robotics","text":"EncapsulationModularityReusabilityFlexibility <p>Real-world Example: E-puck robot motors</p> <p>You don't need to know the internal wiring or low-level data formats to control motors. OOP's encapsulation hides complexity behind clear interfaces like <code>set_speed()</code> methods.</p> <pre><code># Clean interface - implementation details hidden\nmotor = RobotMotor(\"left_wheel\")\nmotor.set_speed(0.5)  # Simple, clear method call\n</code></pre> <p>Real-world Example: Robot subsystems</p> <p>Instead of monolithic code, your robot software becomes a collection of interacting components - motors, sensors, navigation modules.</p> <pre><code># Modular design\nnavigation = NavigationSystem()\nsensors = ProximitySensors()\nmotors = MotorController()\n</code></pre> <p>Real-world Example: Cross-platform compatibility</p> <p>Once you define a <code>Motor</code> class, it can be reused for every motor on your robot or even across different robot platforms.</p> <pre><code># Reusable across different robots\nleft_motor = Motor(\"left_wheel\")\nright_motor = Motor(\"right_wheel\")\narm_motor = Motor(\"gripper\")\n</code></pre> <p>Real-world Example: Sensor polymorphism</p> <p>Different sensor types can respond to the same interface, making your code adaptable to hardware changes.</p> <pre><code># All sensors respond to read_value()\nproximity_sensor.read_value()\nlight_sensor.read_value()\ntemperature_sensor.read_value()\n</code></pre>"},{"location":"sessions/session-04/#2-classes-and-objects-the-foundation","title":"2. Classes and Objects: The Foundation","text":""},{"location":"sessions/session-04/#understanding-the-relationship","title":"Understanding the Relationship","text":"<p>Key Concepts</p> <p>Class: A blueprint, template, or mold for creating objects</p> <ul> <li>Like architectural plans for a building</li> <li>Defines structure and capabilities</li> <li>Uses PascalCase naming (e.g., <code>RobotLED</code>, <code>EPuckMotor</code>)</li> </ul> <p>Object (Instance): Individual \"things\" created from a class</p> <ul> <li>Like actual buildings constructed from plans</li> <li>Has unique state and identity  </li> <li>Can have multiple objects from one class</li> </ul>"},{"location":"sessions/session-04/#practical-example-robot-led-system","title":"Practical Example: Robot LED System","text":""},{"location":"sessions/session-04/#robotled-class-uml-structure","title":"RobotLED Class UML Structure","text":"<pre><code>classDiagram\n    class RobotLED {\n        -str led_id\n        -bool is_on\n        +__init__(led_id: str) RobotLED\n        +turn_on() void\n        +turn_off() void\n    }\n\n    note for RobotLED \"Encapsulates LED state and provides\\ncontrol methods for individual LEDs\"</code></pre> <p>Let's compare procedural vs object-oriented approaches:</p> Procedural ApproachObject-Oriented Approach <pre><code># Global variable - problematic for multiple LEDs\ne_puck_led_is_on = False\n\ndef turn_led_on():\n    global e_puck_led_is_on\n    e_puck_led_is_on = True\n    print(f\"LED is now ON: {e_puck_led_is_on}\")\n\ndef turn_led_off():\n    global e_puck_led_is_on\n    e_puck_led_is_on = False\n    print(f\"LED is now OFF: {e_puck_led_is_on}\")\n</code></pre> <p>Problems: - Global variables create management issues - Difficult to handle multiple LEDs - Data and functions are disconnected - Limited reusability</p> <pre><code>class RobotLED:\n    \"\"\"Blueprint for robot LED objects.\"\"\"\n\n    def __init__(self, led_id: str):\n        \"\"\"Initialize LED with unique identifier.\"\"\"\n        self.led_id = led_id\n        self.is_on = False\n        print(f\"LED '{self.led_id}' initialized (OFF)\")\n\n    def turn_on(self):\n        \"\"\"Turn the LED on.\"\"\"\n        self.is_on = True\n        print(f\"LED '{self.led_id}' is now ON\")\n\n    def turn_off(self):\n        \"\"\"Turn the LED off.\"\"\"\n        self.is_on = False\n        print(f\"LED '{self.led_id}' is now OFF\")\n\n# Usage - multiple independent LEDs\nfront_led = RobotLED(\"front\")\nback_led = RobotLED(\"back\")\n\nfront_led.turn_on()   # Only affects front LED\nback_led.turn_off()   # Independent control\n</code></pre>"},{"location":"sessions/session-04/#3-object-instantiation-process","title":"3. Object Instantiation Process","text":"<p>Instantiation creates new objects from a class blueprint. Understanding this process is crucial for effective OOP.</p>"},{"location":"sessions/session-04/#the-two-step-process","title":"The Two-Step Process","text":"<pre><code># When you write this:\nrobot = EPuckRobot(\"Alpha_7\", 98.5)\n\n# Python internally does:\n# 1. __new__() - Allocates memory for the object\n# 2. __init__() - Initializes the object's state\n</code></pre>"},{"location":"sessions/session-04/#behind-the-scenes","title":"Behind the Scenes","text":"<ol> <li>Memory Allocation (<code>__new__</code>): Python allocates memory space for the new object</li> <li>Initialization (<code>__init__</code>): Your constructor method sets up the object's initial state</li> </ol>"},{"location":"sessions/session-04/#4-constructor-design-and-instance-variables","title":"4. Constructor Design and Instance Variables","text":"<p>The <code>__init__</code> method is your constructor - it defines how objects are created and initialized.</p>"},{"location":"sessions/session-04/#constructor-best-practices","title":"Constructor Best Practices","text":""},{"location":"sessions/session-04/#epuckrobot-class-uml-structure","title":"EPuckRobot Class UML Structure","text":"<pre><code>classDiagram\n    class EPuckRobot {\n        -str robot_id\n        -float battery_percentage\n        -float current_speed\n        -bool is_moving\n        +__init__(robot_id: str, initial_battery_percentage: float) EPuckRobot\n        +move_forward(speed: float) void\n        +stop() void\n        +report_status() str\n    }\n\n    note for EPuckRobot \"Main robot class managing movement,\\nbattery status, and robot identification\"</code></pre> <pre><code>class EPuckRobot:\n    \"\"\"A blueprint for EPuck robot objects.\"\"\"\n\n    def __init__(self, robot_id: str, initial_battery_percentage: float):\n        \"\"\"\n        Initialize a new EPuckRobot object.\n\n        Args:\n            robot_id (str): Unique identifier for the robot\n            initial_battery_percentage (float): Battery level (0.0-100.0)\n        \"\"\"\n        # Instance variables define object state\n        self.robot_id = robot_id\n        self.battery_percentage = initial_battery_percentage\n        self.current_speed = 0.0\n        self.is_moving = False\n\n        print(f\"EPuckRobot '{self.robot_id}' initialized with {self.battery_percentage}% battery\")\n</code></pre>"},{"location":"sessions/session-04/#instance-variables-state","title":"Instance Variables (State)","text":"<p>Instance variables store data unique to each object:</p> <pre><code># Each robot has its own independent state\nrobot_alpha = EPuckRobot(\"Alpha_7\", 98.5)\nrobot_beta = EPuckRobot(\"Beta_12\", 75.0)\n\n# Modifying one doesn't affect the other\nrobot_alpha.current_speed = 0.5\nrobot_alpha.is_moving = True\n\nprint(f\"Alpha speed: {robot_alpha.current_speed}\")  # 0.5\nprint(f\"Beta speed: {robot_beta.current_speed}\")    # 0.0 (unchanged)\n</code></pre>"},{"location":"sessions/session-04/#5-instance-methods-behavior","title":"5. Instance Methods (Behavior)","text":"<p>Instance methods define what objects can do - their behaviors.</p>"},{"location":"sessions/session-04/#method-definition-rules","title":"Method Definition Rules","text":"<pre><code>class EPuckRobot:\n    def __init__(self, robot_id: str, initial_battery_percentage: float):\n        self.robot_id = robot_id\n        self.battery_percentage = initial_battery_percentage\n        self.current_speed = 0.0\n        self.is_moving = False\n\n    def move_forward(self, speed: float):\n        \"\"\"Start moving the robot forward at specified speed.\"\"\"\n        if 0.0 &lt;= speed &lt;= 1.0:\n            self.current_speed = speed\n            self.is_moving = True\n            print(f\"Robot {self.robot_id} moving forward at speed {speed}\")\n        else:\n            print(\"Speed must be between 0.0 and 1.0\")\n\n    def stop(self):\n        \"\"\"Stop the robot movement.\"\"\"\n        self.current_speed = 0.0\n        self.is_moving = False\n        print(f\"Robot {self.robot_id} stopped\")\n\n    def report_status(self):\n        \"\"\"Report current robot status.\"\"\"\n        status = f\"Robot {self.robot_id}:\\n\"\n        status += f\"  Battery: {self.battery_percentage}%\\n\"\n        status += f\"  Speed: {self.current_speed}\\n\"\n        status += f\"  Moving: {self.is_moving}\"\n        return status\n</code></pre>"},{"location":"sessions/session-04/#hands-on-exercise-mock-ir-sensor-class","title":"Hands-on Exercise: Mock IR Sensor Class","text":"<p>In this practical activity, you will write a Python class that simulates infrared (IR) distance sensors commonly found on robots like the e-puck.</p>"},{"location":"sessions/session-04/#task-create-and-use-a-mock-ir-sensor-class","title":"Task: Create and Use a Mock IR Sensor Class","text":""},{"location":"sessions/session-04/#irsensor-class-uml-structure","title":"IRSensor Class UML Structure","text":"<pre><code>classDiagram\n    class IRSensor {\n        -str name\n        +__init__(name: str) IRSensor\n        +get_reading() int\n    }\n\n    note for IRSensor \"Simulates infrared distance sensor\\nreturning readings in centimeters (1-100)\"</code></pre> <p>You will create five separate sensor objects for different positions on the robot:</p> <ul> <li><code>front_left</code></li> <li><code>front_center</code> </li> <li><code>front_right</code></li> <li><code>back_left</code></li> <li><code>back_right</code></li> </ul>"},{"location":"sessions/session-04/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<ol> <li>Create a class named <code>IRSensor</code></li> <li>The <code>__init__</code> method should take one parameter <code>name</code> (string) to store the sensor's position</li> <li>Create a method <code>get_reading()</code> that returns a simulated reading (integer between 1 and 100 cm)</li> <li>Include a proper docstring for <code>get_reading()</code> with Parameters and Returns</li> <li>In your main code, create 5 separate instances of <code>IRSensor</code>, one for each position listed above</li> <li>Call <code>get_reading()</code> on each instance and print the results</li> </ol>"},{"location":"sessions/session-04/#example-implementation-template","title":"Example Implementation Template","text":"<pre><code>import random\n\nclass IRSensor:\n    \"\"\"Simulates an infrared distance sensor.\"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"Initialize the IR sensor with a position name.\"\"\"\n        self.name = name\n        print(f\"IR Sensor '{self.name}' initialized\")\n\n    def get_reading(self):\n        \"\"\"\n        Simulate getting a distance measurement from the IR sensor.\n\n        Parameters:\n            None\n\n        Returns:\n            int: Distance measurement in centimeters (1\u2013100).\n        \"\"\"\n        reading = random.randint(1, 100)\n        print(f\"{self.name} sensor reading: {reading} cm\")\n        return reading\n\nif __name__ == \"__main__\":\n    # Create sensor instances\n    front_left = IRSensor(\"Front Left\")\n    front_center = IRSensor(\"Front Center\")\n    front_right = IRSensor(\"Front Right\")\n    back_left = IRSensor(\"Back Left\")\n    back_right = IRSensor(\"Back Right\")\n\n    # Get readings from each sensor\n    print(\"\\n--- Sensor Readings ---\")\n    front_left.get_reading()\n    front_center.get_reading()\n    front_right.get_reading()\n    back_left.get_reading()\n    back_right.get_reading()\n</code></pre> <p>Extension Challenge</p> <p>In a later lesson, we will discuss composition and how to group these sensor objects into a single class that manages multiple sensors.</p>"},{"location":"sessions/session-04/#live-demonstration-lidar-implementation-across-programming-paradigms","title":"Live Demonstration: LIDAR Implementation Across Programming Paradigms","text":"<p>The instructor will now demonstrate how to implement a mock LIDAR sensor using three different programming approaches, showing the evolution from simple procedural code to sophisticated object-oriented design.</p>"},{"location":"sessions/session-04/#1-procedural-approach","title":"1. Procedural Approach","text":"<p>The simplest implementation using basic Python constructs:</p> <pre><code># lidar_procedural.py\nimport random\n\n# Procedural: all logic inline\nmeasurements = []\nfor _ in range(36):\n    measurement = random.randint(1, 1200)  # cm range\n    measurements.append(measurement)\n\nprint(\"LIDAR Scan (Procedural):\")\nprint(measurements)\n</code></pre> <p>Characteristics: - All code in linear sequence - No reusability - Hard to extend or modify - Good for simple, one-time tasks</p>"},{"location":"sessions/session-04/#2-functional-approach","title":"2. Functional Approach","text":"<p>Using functions to organize and reuse code:</p> <pre><code># lidar_functional.py\nimport random\n\ndef get_measurement():\n    \"\"\"Simulates one LIDAR measurement.\"\"\"\n    return random.randint(1, 1200)\n\ndef scan_lidar(num_measurements=36):\n    \"\"\"Performs a LIDAR scan and returns a list of measurements.\"\"\"\n    return [get_measurement() for _ in range(num_measurements)]\n\nif __name__ == \"__main__\":\n    readings = scan_lidar()\n    print(\"LIDAR Scan (Functional):\")\n    print(readings)\n</code></pre> <p>Characteristics: - Functions provide reusability - Better organization than procedural - Easy to test individual functions - Good for stateless operations</p>"},{"location":"sessions/session-04/#3-object-oriented-approach","title":"3. Object-Oriented Approach","text":""},{"location":"sessions/session-04/#lidar-class-uml-structure","title":"Lidar Class UML Structure","text":"<pre><code>classDiagram\n    class Lidar {\n        -int num_measurements\n        +__init__(num_measurements: int) Lidar\n        +get_measurement() int\n        +scan() list~int~\n        +get_status() str\n    }\n\n    note for Lidar \"Advanced sensor simulation with\\nconfigurable measurement points (default: 36)\"</code></pre> <p>Using classes to create reusable, stateful components:</p> <pre><code># lidar_oop.py\nimport random\n\nclass Lidar:\n    \"\"\"Simulates a LIDAR sensor with configurable parameters.\"\"\"\n\n    def __init__(self, num_measurements=36):\n        \"\"\"Initialize LIDAR with specified number of measurements.\"\"\"\n        self.num_measurements = num_measurements\n        print(f\"LIDAR initialized with {self.num_measurements} measurement points\")\n\n    def get_measurement(self):\n        \"\"\"Simulates a single LIDAR measurement.\"\"\"\n        return random.randint(1, 1200)  # Distance in cm\n\n    def scan(self):\n        \"\"\"Performs a full scan and returns a list of measurements.\"\"\"\n        readings = []\n        for _ in range(self.num_measurements):\n            readings.append(self.get_measurement())\n        return readings\n\n    def get_status(self):\n        \"\"\"Returns the current status of the LIDAR sensor.\"\"\"\n        return f\"LIDAR Status: {self.num_measurements} measurement points configured\"\n\nif __name__ == \"__main__\":\n    # Create LIDAR instance\n    lidar = Lidar()\n    print(lidar.get_status())\n\n    # Perform scan\n    readings = lidar.scan()\n    print(\"LIDAR Scan (OOP):\")\n    print(f\"Collected {len(readings)} measurements\")\n    print(f\"Sample readings: {readings[:5]}...\")  # Show first 5 readings\n</code></pre> <p>Characteristics: - Encapsulation of data and behavior - Reusable sensor objects - Easy to extend with new features - Maintainable and scalable - Perfect for robotics applications</p>"},{"location":"sessions/session-04/#comparison-summary","title":"Comparison Summary","text":"Aspect Procedural Functional Object-Oriented Reusability Low Medium High Maintainability Low Medium High Scalability Poor Good Excellent State Management Global vars Parameters Instance vars Best For Simple scripts Stateless operations Complex systems <p>Live Coding Session</p> <p>The instructor will demonstrate building each version from scratch, showing: - How to refactor from procedural to functional - How to convert functional code to object-oriented - Benefits and trade-offs of each approach - When to use each paradigm in robotics</p>"},{"location":"sessions/session-04/#extension-activity-advanced-lidar-data-filtering","title":"Extension Activity: Advanced LIDAR Data Filtering","text":"<p>Your LIDAR class currently returns a full 360\u00b0 scan with 36 measurements. Sometimes you may only want part of the scan \u2014 for example, the front arc. Here are three different design approaches to achieve this:</p>"},{"location":"sessions/session-04/#approach-1-add-a-scan_filtered-method","title":"Approach 1: Add a <code>scan_filtered()</code> Method","text":"<pre><code>def scan_filtered(self, start=0, end=36):\n    \"\"\"Return scan results between given indices.\"\"\"\n    full_scan = self.scan()\n    return full_scan[start:end]\n</code></pre> <p>Pros: - \u2705 Keeps filtering logic inside the class (good encapsulation) - \u2705 Easy to call: <code>lidar.scan_filtered(4, 20)</code> - \u2705 Can be extended later for angle-based filtering</p> <p>Cons: - \u274c Adds an extra method that mostly wraps existing logic</p>"},{"location":"sessions/session-04/#approach-2-add-optional-parameters-to-scan","title":"Approach 2: Add Optional Parameters to <code>scan()</code>","text":"<pre><code>def scan(self, start=0, end=36):\n    \"\"\"Perform scan with optional filtering.\"\"\"\n    full_readings = [self.get_measurement() for _ in range(self.num_measurements)]\n    return full_readings[start:end]\n</code></pre> <p>Pros: - \u2705 No new method \u2014 extends the original one - \u2705 Introduces default parameters</p> <p>Cons: - \u274c Mixes two responsibilities: generating data and filtering data</p>"},{"location":"sessions/session-04/#approach-3-process-after-the-scan","title":"Approach 3: Process After the Scan","text":"<pre><code># In your main code\nreadings = lidar.scan()\nfront_arc = readings[4:20]  # Extract front arc\n</code></pre> <p>Pros: - \u2705 Keeps <code>scan()</code> simple and single-purpose - \u2705 Flexible filtering in client code</p> <p>Cons: - \u274c Filtering logic is done outside the class - \u274c More code in the main application</p>"},{"location":"sessions/session-04/#design-recommendation","title":"Design Recommendation","text":"<p>A good design follows the Single Responsibility Principle: one method should do one thing well. The recommended approach is:</p> <ol> <li>Keep <code>scan()</code> for the full 360\u00b0 scan</li> <li>Filter with list slicing when needed</li> <li>If filtering becomes common, add a dedicated <code>scan_filtered()</code> method inside the class</li> </ol> <p>Extension Challenge</p> <p>Implement one of these filtering approaches in your LIDAR class and test it with different ranges: - Front arc: indices 14-22 (forward-facing sensors) - Left side: indices 27-35  - Right side: indices 1-9</p>"},{"location":"sessions/session-04/#out-of-class-research-activities","title":"Out-of-Class Research Activities","text":"<p>To reinforce your understanding of the concepts covered in this session, research the following topics:</p>"},{"location":"sessions/session-04/#research-topics","title":"Research Topics","text":"<ol> <li>Object-Oriented Programming Principles</li> <li>Investigate the four main principles of OOP: Encapsulation, Inheritance, Polymorphism, and Abstraction</li> <li>Find real-world examples of how each principle is applied in robotics software</li> <li> <p>Compare OOP with other programming paradigms (procedural, functional)</p> </li> <li> <p>Class Design Best Practices</p> </li> <li>Research the Single Responsibility Principle and how it applies to class design</li> <li>Look into naming conventions for classes and methods in Python</li> <li> <p>Study examples of well-designed classes in robotics frameworks</p> </li> <li> <p>Python Class Features</p> </li> <li>Explore Python's special methods (<code>__init__</code>, <code>__str__</code>, <code>__repr__</code>)</li> <li>Research property decorators and getters/setters</li> <li> <p>Investigate class methods vs instance methods vs static methods</p> </li> <li> <p>Robotics Software Architecture</p> </li> <li>Study how major robotics frameworks (ROS, ROS2) use object-oriented design</li> <li>Research component-based architectures in robotics</li> <li>Look into design patterns commonly used in robotics software</li> </ol> <p>Research Resources</p> <ul> <li>Python official documentation on classes</li> <li>ROS tutorials and documentation</li> <li>Robotics software engineering books and articles</li> <li>Open-source robotics projects on GitHub</li> </ul>"},{"location":"sessions/session-04/#lab-1-webots-robot-simulator-setup","title":"Lab 1: Webots Robot Simulator Setup","text":"<p>To complete this session, students will set up the Webots robotics simulator that will be used in future lab exercises.</p> <p>Lab Credits</p> <p>This lab is based on the excellent work by Felipe Martins:</p> <p>Original Repository: Robotics-Simulation-Labs Author: Felipe Nascimento Martins License: Available on GitHub</p> <p>We acknowledge and appreciate the open-source contribution to robotics education.</p>"},{"location":"sessions/session-04/#objectives","title":"Objectives","text":"<p>The goal of this lab is to guide you to install, configure and familiarize yourself with Webots simulator. At the end of this lab you should be able to run Python code to control your simulated robot.</p>"},{"location":"sessions/session-04/#about-webots","title":"About Webots","text":"<p>Webots is an open-source robotics simulator that can simulate several types of robots and sensors. It provides a complete development environment to model, program and simulate robots and the world they are in, including physics simulation. It is widely used in industry, education and research.</p> <p></p>"},{"location":"sessions/session-04/#installation-tasks","title":"Installation Tasks","text":"<p>To complete this lab you have to follow the steps described below:</p>"},{"location":"sessions/session-04/#1-download-and-install-webots","title":"1. Download and Install Webots","text":"<ul> <li>Download from https://cyberbotics.com/</li> <li>You need Webots R2022a or newer for the Robotics Simulation Labs</li> <li>Available for Windows, macOS and Linux</li> <li>The download and installation process can take a while</li> </ul>"},{"location":"sessions/session-04/#2-complete-webots-tutorial-1","title":"2. Complete Webots Tutorial 1","text":"<ul> <li>Follow Webots Tutorial 1 </li> <li>Complete through Hands-on #7</li> <li>After that, you'll configure Python (next step)</li> </ul>"},{"location":"sessions/session-04/#3-install-python-3-if-needed","title":"3. Install Python 3 (if needed)","text":"<ul> <li>You need the 64-bit version of Python 3</li> <li>Download from python.org</li> <li>Windows users: Select \"Add to PATH\" during installation</li> <li>Version compatibility: Not all Python versions work with all Webots versions</li> <li>Webots R2022b works with Python 3.7, 3.8, 3.9 and 3.10</li> <li>Webots R2022a does not support Python 3.10</li> </ul>"},{"location":"sessions/session-04/#4-reboot-your-system","title":"4. Reboot Your System","text":"<ul> <li>Important: Reboot after installing Python</li> </ul>"},{"location":"sessions/session-04/#5-test-python-installation","title":"5. Test Python Installation","text":"<ul> <li>Open Command Prompt/Terminal</li> <li>Type <code>python</code>, <code>python3</code>, or <code>python3.x</code> (depending on your version)</li> <li>You should see something like:</li> </ul> <pre><code>Python 3.10.5 (tags/v3.10.5:f377153, Jun  6 2022, 16:14:13) [MSC v.1929 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt;\n</code></pre> <ul> <li>Type <code>exit()</code> to return to terminal</li> </ul>"},{"location":"sessions/session-04/#6-install-required-libraries","title":"6. Install Required Libraries","text":"<ul> <li>Follow instructions here</li> <li>Install at least NumPy</li> <li>Optional: OpenCV (also installs NumPy)</li> </ul>"},{"location":"sessions/session-04/#7-configure-webots-for-python","title":"7. Configure Webots for Python","text":"<ul> <li>In Webots: <code>Tools &gt; Preferences &gt; Python command</code></li> <li>Set to <code>python</code> or <code>python3</code> (whatever worked in step 5)</li> <li>macOS/Windows without PATH: Use full path to Python installation</li> </ul>"},{"location":"sessions/session-04/#8-complete-tutorial","title":"8. Complete Tutorial","text":"<ul> <li>Continue from \"Create New Controller\"</li> <li>Complete through Hands-on #10</li> <li>Important: Select <code>Python</code> when viewing code examples</li> </ul>"},{"location":"sessions/session-04/#troubleshooting-tips","title":"Troubleshooting Tips","text":"<p>Common Issues</p> <p>64-bit Python Required: 32-bit versions don't work with Webots</p> <p>macOS: May need full Python path in Webots preferences</p> <p>Linux: Avoid symbolic links in project folders; consider APT version</p> <p>Windows PATH: If Python isn't found, add it to system PATH and reboot</p> <p>Hardware Warning: Intel GPU warning is normal and won't affect our labs</p>"},{"location":"sessions/session-04/#windows-installation-issues","title":"Windows Installation Issues","text":"<p>If you see a security warning when installing Webots on Windows, click \"More info\" then \"Run anyway\":</p> <p></p>"},{"location":"sessions/session-04/#python-path-configuration","title":"Python PATH Configuration","text":"<p>If you need to add Python to your Windows PATH manually, the configuration should look like this:</p> <p></p>"},{"location":"sessions/session-04/#performance-optimization","title":"Performance Optimization","text":"<p>If Webots runs slowly on your hardware:</p> <ul> <li>Click <code>WorldInfo &gt; FPS</code> and reduce to 20</li> <li>Increase <code>basicTimeStep</code> to 32</li> <li>Go to <code>Tools &gt; Preferences &gt; OpenGL</code></li> <li>Reduce <code>Ambient Occlusion</code> and <code>Texture Quality</code></li> </ul>"},{"location":"sessions/session-04/#conclusion","title":"Conclusion","text":"<p>After completing these steps, you should have: - Webots installed and configured for Python - Understanding of basic Webots concepts - Ability to write simple Python programs to control simulated robots</p> <p>Lab Complete</p> <p>You're now ready for future robotics simulation exercises using Webots!</p>"},{"location":"sessions/session-04/#session-summary-class-relationships-overview","title":"Session Summary: Class Relationships Overview","text":"<p>Here's a comprehensive overview of all the classes we've implemented in this session:</p> <pre><code>classDiagram\n    class RobotLED {\n        +str led_id\n        +bool is_on\n        +__init__(led_id: str)\n        +turn_on()\n        +turn_off()\n    }\n\n    class EPuckRobot {\n        +str robot_id\n        +float battery_percentage\n        +float current_speed\n        +bool is_moving\n        +__init__(robot_id: str, initial_battery_percentage: float)\n        +move_forward(speed: float)\n        +stop()\n        +report_status() str\n    }\n\n    class IRSensor {\n        +str name\n        +__init__(name: str)\n        +get_reading() int\n    }\n\n    class Lidar {\n        +int num_measurements\n        +__init__(num_measurements: int)\n        +get_measurement() int\n        +scan() list\n        +get_status() str\n    }\n\n    note for RobotLED \"Manages individual LED state\\nand behavior\"\n    note for EPuckRobot \"Main robot controller with\\nmovement and status tracking\"\n    note for IRSensor \"Simulates infrared distance\\nsensor readings\"\n    note for Lidar \"Simulates LIDAR sensor with\\nconfigurable measurements\"</code></pre>"},{"location":"sessions/session-04/#programming-paradigm-evolution","title":"Programming Paradigm Evolution","text":"<p>The evolution from procedural to object-oriented programming can be visualized as:</p> <pre><code>flowchart TD\n    A[Procedural Approach] --&gt; B[\"Global variables&lt;br/&gt;Separate functions&lt;br/&gt;Limited reusability\"]\n\n    C[Functional Approach] --&gt; D[\"Pure functions&lt;br/&gt;Parameter passing&lt;br/&gt;Better organization\"]\n\n    E[Object-Oriented Approach] --&gt; F[\"Encapsulated data&lt;br/&gt;Methods with data&lt;br/&gt;Reusable objects&lt;br/&gt;Scalable design\"]\n\n    B --&gt; G[\"\u274c Hard to maintain&lt;br/&gt;\u274c Global state issues&lt;br/&gt;\u274c No reusability\"]\n    D --&gt; H[\"\u2705 Better organization&lt;br/&gt;\u26a0\ufe0f Stateless only&lt;br/&gt;\u26a0\ufe0f Limited scalability\"]\n    F --&gt; I[\"\u2705 Highly maintainable&lt;br/&gt;\u2705 Reusable components&lt;br/&gt;\u2705 Scalable architecture&lt;br/&gt;\u2705 Perfect for robotics\"]\n\n    style A fill:#ffcccc\n    style C fill:#ffffcc\n    style E fill:#ccffcc\n    style G fill:#ffcccc\n    style H fill:#ffffcc\n    style I fill:#ccffcc</code></pre> <p>UML Diagram Benefits</p> <p>These UML diagrams help visualize: - Class structure: Attributes and methods at a glance - Relationships: How classes might interact in larger systems - Design patterns: Common robotics software patterns - Scalability: How to extend classes for more complex robots</p>"},{"location":"sessions/session-04/#key-takeaways","title":"Key Takeaways","text":"<p>Session Summary</p> <ul> <li>OOP Benefits: Encapsulation, modularity, reusability, and flexibility</li> <li>Classes vs Objects: Blueprints vs instances</li> <li>Instantiation: Memory allocation + initialization process</li> <li>Instance Variables: Store unique object state</li> <li>Instance Methods: Define object behaviors</li> <li>Constructor Design: Proper <code>__init__</code> method implementation</li> </ul>"},{"location":"sessions/session-04/#check-your-knowledge","title":"Check Your Knowledge","text":"<p>Test your understanding of the Object-Oriented Programming concepts covered in this session:</p> <p>Question 1: Class vs Object</p> <p>Question: What's the difference between a class and an object? Use the robot LED example to explain.</p> Click to reveal answer <p>Answer: </p> <ul> <li>Class: A blueprint or template (like <code>RobotLED</code> class) that defines what all LED objects will have</li> <li>Object: An actual LED created from that blueprint (like <code>front_led</code> or <code>back_led</code>)</li> </ul> <p>Think of it like a cookie cutter (class) and the actual cookies (objects). You use one cookie cutter to make many different cookies, just like you use one <code>RobotLED</code> class to create many different LED objects.</p> <p>Question 2: What does <code>self</code> mean?</p> <p>Question: In the method <code>def turn_on(self):</code>, what does the word <code>self</code> represent?</p> Click to reveal answer <p>Answer: </p> <p><code>self</code> refers to the specific object that the method is being called on. </p> <p>When you write <code>front_led.turn_on()</code>, inside the <code>turn_on()</code> method, <code>self</code> refers to the <code>front_led</code> object. This is how the method knows which LED to turn on - it's the one that called the method!</p> <p>Question 3: Instance Variables vs Class Variables</p> <p>Question: Look at these two pieces of code. What's the difference?</p> <pre><code>Code A: self.led_id = \"front\"\nCode B: led_count = 0\n</code></pre> Click to reveal answer <p>Answer: </p> <ul> <li> <p>Code A (<code>self.led_id</code>): This is an instance variable. Each LED object has its own <code>led_id</code>. The front LED has <code>led_id = \"front\"</code> and the back LED has <code>led_id = \"back\"</code>.</p> </li> <li> <p>Code B (<code>led_count</code>): This is a class variable. There's only one <code>led_count</code> shared by all LED objects. If you wanted to count how many total LEDs exist, you'd use a class variable.</p> </li> </ul> <p>Key difference: Instance variables are unique to each object, class variables are shared by all objects.</p> <p>Question 4: Why use OOP for robots?</p> <p>Question: Name two main benefits of using object-oriented programming for robotics instead of just writing simple functions.</p> Click to reveal answer <p>Answer: </p> <ol> <li> <p>Organization: Each robot component (LED, sensor, motor) can be its own class, making the code much more organized and easier to understand.</p> </li> <li> <p>Reusability: Once you write a <code>RobotLED</code> class, you can use it for any robot project. You don't have to rewrite LED control code every time.</p> </li> </ol> <p>Bonus: Independence - Each object manages its own data, so turning on one LED won't accidentally affect another LED.</p> <p>Question 5: Object Instantiation</p> <p>Question: When you write <code>my_led = RobotLED(\"status\")</code>, what two things happen inside Python?</p> Click to reveal answer <p>Answer: </p> <ol> <li>Memory allocation: Python creates space in memory for the new LED object</li> <li>Initialization: Python calls the <code>__init__</code> method to set up the object's initial values (like setting <code>led_id</code> to \"status\" and <code>is_on</code> to <code>False</code>)</li> </ol> <p>After these two steps, you have a fully working LED object stored in the variable <code>my_led</code>.</p>"},{"location":"sessions/session-04/#next-session-preview","title":"Next Session Preview","text":"<p>Week 5: Advanced Class Features &amp; Magic Methods</p> <ul> <li>Python magic methods (<code>__str__</code>, <code>__repr__</code>, <code>__eq__</code>)</li> <li>Property decorators and getters/setters</li> <li>Class methods and static methods</li> <li>Operator overloading for custom classes</li> </ul>"},{"location":"sessions/session-04/#resources","title":"Resources","text":""},{"location":"sessions/session-04/#downloads","title":"Downloads","text":"<ul> <li> Robot class starter code</li> <li> Complete class implementations</li> <li> LIDAR procedural version</li> <li> LIDAR functional version</li> <li> LIDAR object-oriented version</li> <li> All Week 4 resources</li> </ul>"},{"location":"sessions/session-04/#further-reading","title":"Further Reading","text":"<ul> <li>Python Classes Documentation</li> <li>OOP Design Patterns</li> <li>Robotics Software Architecture</li> </ul> <p>Navigation: \u2190 Week 3 | Learning Plan | Week 5 \u2192</p>"},{"location":"sessions/session-05/","title":"Session 5: Advanced Class Features &amp; Magic Methods","text":"<p>Week: 5 Element: ICTPRG430 Element 2.2 Duration: 4 hours Phase: Object-Oriented Programming </p>"},{"location":"sessions/session-05/#session-introduction","title":"Session Introduction","text":"<p>In this session, you'll explore advanced Python class features that make your robotics code more professional and maintainable. You'll learn how to make your robot objects display themselves clearly using magic methods (<code>__str__</code> and <code>__repr__</code>), understand the fundamentals of data encapsulation through getters and setters (both traditional and decorator approaches), and see how function wrapping works. The session culminates with Lab 2, where you'll implement a line-following robot using object-oriented principles in Webots simulator.</p>"},{"location":"sessions/session-05/#learning-objectives","title":"Learning Objectives","text":"<p>By the end of this session, you will be able to:</p> <ul> <li>Implement and distinguish between <code>__str__</code> and <code>__repr__</code> magic methods</li> <li>Understand when and why to use each string representation method</li> <li>Create getter and setter methods for controlled data access</li> <li>Apply the <code>@property</code> decorator for Pythonic attribute access</li> <li>Understand function wrapping concepts as preparation for decorators</li> <li>Design object-oriented solutions for line-following robot behaviors</li> <li>Implement sensor fusion and control logic in a robotics context</li> </ul>"},{"location":"sessions/session-05/#session-structure","title":"Session Structure","text":"<ol> <li>Theory Session - Magic methods and string representations</li> <li>Hands-on Exercise - Implementing <code>__str__</code> and <code>__repr__</code> for robot classes</li> <li>Data Encapsulation - Traditional getters/setters and property decorators</li> <li>Function Wrapping - Understanding decorator foundations</li> <li>Lab 2 - Line-following robot implementation in Webots</li> </ol>"},{"location":"sessions/session-05/#session-overview","title":"Session Overview","text":"<p>This session builds on the foundational OOP concepts from Session 4, introducing advanced class features that make your robotics code more robust and professional. We'll focus on how objects represent themselves and how to control access to object data.</p>"},{"location":"sessions/session-05/#pre-session-preparation","title":"Pre-Session Preparation","text":"<p>Setup Check</p> <p>Ensure your development environment is ready:</p> <ul> <li>Python 3.9+ with Webots integration working</li> <li>VS Code with Python</li> <li>Completed Session 4 robot class exercises</li> </ul>"},{"location":"sessions/session-05/#1-magic-methods-making-objects-talk","title":"1. Magic Methods: Making Objects Talk","text":"<p>Magic methods (also called \"dunder methods\" because they have **d**ouble **under**scores) are special Python methods that define how objects behave in specific situations. Today we'll focus on the two most important ones for displaying object information: <code>__str__</code> and <code>__repr__</code>.</p>"},{"location":"sessions/session-05/#why-magic-methods-matter-in-robotics","title":"Why Magic Methods Matter in Robotics","text":"<p>When debugging robot behavior, you need clear, informative output about your objects. Without magic methods, Python gives you useless information:</p> <pre><code># Without magic methods - unhelpful output\nrobot = EPuckRobot(\"Alpha_7\", 98.5)\nprint(robot)\n# Output: &lt;__main__.EPuckRobot object at 0x7f8b8c0a1d30&gt;\n</code></pre> <p>With proper magic methods, you get meaningful information:</p> <pre><code># With magic methods - useful output\nrobot = EPuckRobot(\"Alpha_7\", 98.5)\nprint(robot)\n# Output: EPuckRobot(robot_id='Alpha_7', battery=98.5%, speed=0.0, moving=False)\n</code></pre>"},{"location":"sessions/session-05/#understanding-__str__-vs-__repr__","title":"Understanding <code>__str__</code> vs <code>__repr__</code>","text":"<p>Abstract</p> <p>\"Key Differences\"</p> <p><code>__str__</code> : For end users - human-readable, friendly format</p> <ul> <li>Called by <code>print()</code> and <code>str()</code></li> <li>Should be clear and informative for users</li> <li>Think: \"What would a robot operator want to see?\"</li> </ul> <p><code>__repr__</code>: For developers - precise, unambiguous format</p> <ul> <li>Called by <code>repr()</code> and when displaying in lists/debugger</li> <li>Should ideally be valid Python code to recreate the object</li> <li>Think: \"What would help a programmer debug this?\"</li> </ul>"},{"location":"sessions/session-05/#2-implementing-string-representations","title":"2. Implementing String Representations","text":"<p>Let's enhance our EPuckRobot class from Session 4 with proper string representations.</p>"},{"location":"sessions/session-05/#epuckrobot-enhanced-class-uml-structure","title":"EPuckRobot Enhanced Class UML Structure","text":"<pre><code>classDiagram\n    class EPuckRobot {\n        -str robot_id\n        -float battery_percentage\n        -float current_speed\n        -bool is_moving\n        +__init__(robot_id: str, initial_battery_percentage: float) EPuckRobot\n        +__str__() str\n        +__repr__() str\n        +move_forward(speed: float) void\n        +stop() void\n        +report_status() str\n    }\n\n    note for EPuckRobot \"Enhanced with string representation methods\\nfor better debugging and user interaction\"</code></pre> <p>Interactive Code Example</p> <p>Try this interactive example to experiment with the concepts:</p> <p></p>"},{"location":"sessions/session-05/#hands-on-exercise-enhanced-ir-sensor-with-string-representations","title":"Hands-on Exercise: Enhanced IR Sensor with String Representations","text":"<p>Building on Session 4's IR Sensor class, you'll now add professional string representations.</p>"},{"location":"sessions/session-05/#task-enhance-irsensor-with-magic-methods","title":"Task: Enhance IRSensor with Magic Methods","text":""},{"location":"sessions/session-05/#enhanced-irsensor-class-uml-structure","title":"Enhanced IRSensor Class UML Structure","text":"<pre><code>classDiagram\n    class IRSensor {\n        -str name\n        -int last_reading\n        +__init__(name: str) IRSensor\n        +__str__() str\n        +__repr__() str\n        +get_reading() int\n        +get_status() str\n    }\n\n    note for IRSensor \"Enhanced sensor with string representations\\nand reading history for better debugging\"</code></pre>"},{"location":"sessions/session-05/#step-by-step-instructions","title":"Step-by-Step Instructions","text":"<ol> <li> <p>Enhance your IRSensor class from Session 4 with these additions:</p> <ul> <li>Add a <code>last_reading</code> instance variable to store the most recent reading</li> <li>Implement <code>__str__()</code> for user-friendly display</li> <li>Implement <code>__repr__()</code> for debugging</li> <li>Add a <code>get_status()</code> method that returns detailed sensor information</li> <li> <p>Requirements for string methods:</p> </li> <li> <p><code>__str__()</code>: Should show sensor name and last reading in a friendly format</p> </li> <li><code>__repr__()</code>: Should show exact constructor call needed to recreate the sensor</li> <li>Handle the case when no reading has been taken yet</li> </ul> </li> </ol>"},{"location":"sessions/session-05/#complete-implementation-template","title":"Complete Implementation Template","text":"<pre><code>import random\n\nclass IRSensor:\n    \"\"\"Enhanced infrared distance sensor with string representations.\"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"\n        Initialize the IR sensor with a position name.\n\n        Args:\n            name (str): Position identifier for the sensor\n        \"\"\"\n        pass\n\n    def __str__(self):\n        \"\"\"\n        Return user-friendly string representation.\n\n        Returns:\n            str: Human-readable sensor status\n        \"\"\"\n        pass\n\n\n    def __repr__(self):\n        \"\"\"\n        Return developer-friendly string representation.\n\n        Returns:\n            str: Precise representation for debugging\n        \"\"\"\n        pass\n\n    def get_reading(self):\n        \"\"\"\n        Simulate getting a distance measurement from the IR sensor.\n\n        Returns:\n            int: Distance measurement in centimeters (1-100)\n        \"\"\"\n        pass\n\n    def get_status(self):\n        \"\"\"\n        Get detailed status information about the sensor.\n\n        Returns:\n            str: Detailed sensor status\n        \"\"\"\n        pass\n\"\n\nif __name__ == \"__main__\":\n    # Create sensor instances\n    sensors = [\n        IRSensor(\"Front Left\"),\n        IRSensor(\"Front Center\"),\n        IRSensor(\"Front Right\"),\n        IRSensor(\"Back Left\"),\n        IRSensor(\"Back Right\")\n    ]\n\n    print(\"\\n=== Initial Sensor Status ===\")\n    for sensor in sensors:\n        print(sensor)  # Uses __str__\n\n    print(\"\\n=== After Taking Readings ===\")\n    for sensor in sensors:\n        sensor.get_reading()\n\n    print(\"\\n=== Updated Sensor Display ===\")\n    for sensor in sensors:\n        print(sensor)  # Shows readings now\n\n    print(\"\\n=== Debugging View ===\")\n    print(\"Sensor list:\", sensors)  # Uses __repr__ for each sensor\n\n    print(\"\\n=== Detailed Status ===\")\n    for sensor in sensors:\n        print(sensor.get_status())\n</code></pre> <p>Expected Output (values will change for yours):</p> <pre><code>IR Sensor 'Front Left' initialized\nIR Sensor 'Front Center' initialized\nIR Sensor 'Front Right' initialized\nIR Sensor 'Back Left' initialized\nIR Sensor 'Back Right' initialized\n\n=== Initial Sensor Status ===\nFront Left Sensor: No readings taken\nFront Center Sensor: No readings taken\nFront Right Sensor: No readings taken\nBack Left Sensor: No readings taken\nBack Right Sensor: No readings taken\n\n=== After Taking Readings ===\nFront Left sensor reading: 42 cm\nFront Center sensor reading: 78 cm\nFront Right sensor reading: 15 cm\nBack Left sensor reading: 91 cm\nBack Right sensor reading: 33 cm\n\n=== Updated Sensor Display ===\nFront Left Sensor: 42 cm\nFront Center Sensor: 78 cm\nFront Right Sensor: 15 cm\nBack Left Sensor: 91 cm\nBack Right Sensor: 33 cm\n\n=== Debugging View ===\nSensor list: [IRSensor(name='Front Left'), IRSensor(name='Front Center'), IRSensor(name='Front Right'), IRSensor(name='Back Left'), IRSensor(name='Back Right')]\n\n=== Detailed Status ===\nSensor 'Front Left': Active (last reading: 42 cm)\nSensor 'Front Center': Active (last reading: 78 cm)\nSensor 'Front Right': Active (last reading: 15 cm)\nSensor 'Back Left': Active (last reading: 91 cm)\nSensor 'Back Right': Active (last reading: 33 cm)\n</code></pre> <p>!!! tip \"Best Practice Tip\" Notice how <code>__str__</code> provides information useful to robot operators, while <code>__repr__</code> shows exactly how to recreate the object. This distinction helps both users and developers.</p>"},{"location":"sessions/session-05/#3-data-encapsulation-controlling-access-to-object-data","title":"3. Data Encapsulation: Controlling Access to Object Data","text":"<p>Data encapsulation is about controlling how external code accesses and modifies object data. In robotics, this prevents dangerous operations like setting invalid motor speeds or battery levels.</p>"},{"location":"sessions/session-05/#the-problem-with-direct-attribute-access","title":"The Problem with Direct Attribute Access","text":"<pre><code># Direct access can lead to problems\nrobot = EPuckRobot(\"Alpha_7\", 98.5)\nrobot.battery_percentage = 150.0  # Invalid! Batteries can't exceed 100%\nrobot.current_speed = -0.5        # Invalid! Negative speed doesn't make sense\n</code></pre>"},{"location":"sessions/session-05/#traditional-getter-and-setter-methods","title":"Traditional Getter and Setter Methods","text":"<p>Before we learn the elegant decorator approach, let's understand the traditional method:</p>"},{"location":"sessions/session-05/#battery-management-class-uml-structure","title":"Battery Management Class UML Structure","text":"<pre><code>classDiagram\n    class BatteryManager {\n        -float _battery_level\n        +__init__(initial_level: float) BatteryManager\n        +get_battery_level() float\n        +set_battery_level(level: float) void\n        +is_battery_low() bool\n        +__str__() str\n        +__repr__() str\n    }\n\n    note for BatteryManager \"Encapsulates battery data with\\nvalidation and controlled access\"</code></pre> <pre><code>class BatteryManager:\n    \"\"\"Manages robot battery with controlled access.\"\"\"\n\n    def __init__(self, initial_level: float):\n        \"\"\"Initialize battery manager with validation.\"\"\"\n        self._battery_level = 0.0  # Private attribute (by convention)\n        self.set_battery_level(initial_level)  # Use setter for validation\n\n    def get_battery_level(self):\n        \"\"\"\n        Get current battery level.\n\n        Returns:\n            float: Battery level as percentage (0.0-100.0)\n        \"\"\"\n        return self._battery_level\n\n    def set_battery_level(self, level: float):\n        \"\"\"\n        Set battery level with validation.\n\n        Args:\n            level (float): Battery level percentage\n\n        Raises:\n            ValueError: If level is outside valid range\n        \"\"\"\n        if not isinstance(level, (int, float)):\n            raise TypeError(\"Battery level must be a number\")\n\n        if level &lt; 0.0:\n            raise ValueError(\"Battery level cannot be negative\")\n\n        if level &gt; 100.0:\n            raise ValueError(\"Battery level cannot exceed 100%\")\n\n        self._battery_level = float(level)\n        print(f\"Battery level set to {self._battery_level}%\")\n\n    def is_battery_low(self):\n        \"\"\"\n        Check if battery is low.\n\n        Returns:\n            bool: True if battery is below 20%\n        \"\"\"\n        return self._battery_level &lt; 20.0\n\n    def __str__(self):\n        \"\"\"User-friendly battery status.\"\"\"\n        status = \"LOW\" if self.is_battery_low() else \"OK\"\n        return f\"Battery: {self._battery_level}% ({status})\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return f\"BatteryManager(initial_level={self._battery_level})\"\n\n# Usage example\nif __name__ == \"__main__\":\n    # Create battery manager\n    battery = BatteryManager(85.0)\n    print(battery)\n\n    # Safe access through getters/setters\n    print(f\"Current level: {battery.get_battery_level()}%\")\n\n    # Validation prevents invalid values\n    try:\n        battery.set_battery_level(150.0)  # Will raise ValueError\n    except ValueError as e:\n        print(f\"Error: {e}\")\n\n    # Check battery status\n    battery.set_battery_level(15.0)\n    print(battery)\n    print(f\"Battery low: {battery.is_battery_low()}\")\n</code></pre>"},{"location":"sessions/session-05/#4-function-wrapping-understanding-decorator-foundations","title":"4. Function Wrapping: Understanding Decorator Foundations","text":"<p>Before learning the <code>@property</code> decorator, let's understand how function wrapping works. This concept is fundamental to understanding decorators.</p>"},{"location":"sessions/session-05/#basic-function-wrapping-example","title":"Basic Function Wrapping Example","text":"<pre><code>def validate_positive(func):\n    \"\"\"Wrapper that validates function arguments are positive.\"\"\"\n    def wrapper(value):\n        print(f\"Validating that {value} is positive...\")\n        if value &lt; 0:\n            raise ValueError(\"Value must be positive\")\n        result = func(value)\n        print(f\"Validation passed, result: {result}\")\n        return result\n    return wrapper\n\ndef calculate_square_root(number):\n    \"\"\"Calculate square root of a number.\"\"\"\n    return number ** 0.5\n\n# Wrap the function manually\nsafe_square_root = validate_positive(calculate_square_root)\n\n# Test the wrapped function\ntry:\n    result = safe_square_root(16.0)  # Works fine\n    print(f\"\u221a16 = {result}\")\n\n    result = safe_square_root(-4.0)  # Raises error\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"sessions/session-05/#how-this-relates-to-properties","title":"How This Relates to Properties","text":"<p>The <code>@property</code> decorator works similarly - it wraps your method to make it behave like an attribute. Understanding this concept helps you grasp how decorators work \"under the hood.\"</p>"},{"location":"sessions/session-05/#5-property-decorators-the-pythonic-way","title":"5. Property Decorators: The Pythonic Way","text":"<p>Now that you understand function wrapping, let's see how the <code>@property</code> decorator provides a cleaner approach to getters and setters.</p>"},{"location":"sessions/session-05/#enhanced-motor-controller-class-uml-structure","title":"Enhanced Motor Controller Class UML Structure","text":"<pre><code>classDiagram\n    class MotorController {\n        -float _speed\n        -float _max_speed\n        -bool _is_running\n        +__init__(max_speed: float) MotorController\n        +speed: float\n        +max_speed: float\n        +is_running: bool\n        +start() void\n        +stop() void\n        +__str__() str\n        +__repr__() str\n    }\n\n    note for MotorController \"Uses property decorators for clean,\\nvalidated attribute access\"</code></pre> <pre><code>class MotorController:\n    \"\"\"Motor controller with property-based encapsulation.\"\"\"\n\n    def __init__(self, max_speed: float = 1.0):\n        \"\"\"\n        Initialize motor controller.\n\n        Args:\n            max_speed (float): Maximum allowed speed (0.0-1.0)\n        \"\"\"\n        self._speed = 0.0\n        self._max_speed = max_speed\n        self._is_running = False\n        print(f\"Motor controller initialized (max speed: {max_speed})\")\n\n    @property\n    def speed(self):\n        \"\"\"\n        Get current motor speed.\n\n        Returns:\n            float: Current speed (0.0-1.0)\n        \"\"\"\n        return self._speed\n\n    @speed.setter\n    def speed(self, value):\n        \"\"\"\n        Set motor speed with validation.\n\n        Args:\n            value (float): Desired speed (0.0-max_speed)\n\n        Raises:\n            ValueError: If speed is outside valid range\n            TypeError: If speed is not a number\n        \"\"\"\n        if not isinstance(value, (int, float)):\n            raise TypeError(\"Speed must be a number\")\n\n        if value &lt; 0.0:\n            raise ValueError(\"Speed cannot be negative\")\n\n        if value &gt; self._max_speed:\n            raise ValueError(f\"Speed cannot exceed {self._max_speed}\")\n\n        self._speed = float(value)\n        self._is_running = (self._speed &gt; 0.0)\n        print(f\"Motor speed set to {self._speed}\")\n\n    @property\n    def max_speed(self):\n        \"\"\"Get maximum allowed speed.\"\"\"\n        return self._max_speed\n\n    @property\n    def is_running(self):\n        \"\"\"Check if motor is currently running.\"\"\"\n        return self._is_running\n\n    def start(self):\n        \"\"\"Start motor at current speed setting.\"\"\"\n        if self._speed &gt; 0.0:\n            self._is_running = True\n            print(f\"Motor started at speed {self._speed}\")\n        else:\n            print(\"Cannot start motor: speed is 0.0\")\n\n    def stop(self):\n        \"\"\"Stop motor (sets speed to 0).\"\"\"\n        self._speed = 0.0\n        self._is_running = False\n        print(\"Motor stopped\")\n\n    def __str__(self):\n        \"\"\"User-friendly motor status.\"\"\"\n        status = \"RUNNING\" if self._is_running else \"STOPPED\"\n        return f\"Motor: {status} at {self._speed}/{self._max_speed} speed\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return f\"MotorController(max_speed={self._max_speed})\"\n\n# Usage demonstrating property access\nif __name__ == \"__main__\":\n    # Create motor controller\n    motor = MotorController(0.8)  # Max speed of 0.8\n    print(motor)\n\n    # Property access looks like normal attribute access\n    print(f\"Current speed: {motor.speed}\")\n    print(f\"Max speed: {motor.max_speed}\")\n    print(f\"Is running: {motor.is_running}\")\n\n    # Set speed using property (calls the setter)\n    motor.speed = 0.5\n    print(motor)\n\n    # Try invalid values\n    try:\n        motor.speed = 1.2  # Exceeds max_speed\n    except ValueError as e:\n        print(f\"Error: {e}\")\n\n    try:\n        motor.speed = \"fast\"  # Wrong type\n    except TypeError as e:\n        print(f\"Error: {e}\")\n\n    # Properties are read-only where no setter is defined\n    try:\n        motor.max_speed = 1.0  # This will raise AttributeError\n    except AttributeError as e:\n        print(f\"Error: can't set max_speed - {e}\")\n</code></pre>"},{"location":"sessions/session-05/#comparing-approaches","title":"Comparing Approaches","text":"Aspect Traditional Getters/Setters Property Decorators Syntax <code>robot.get_speed()</code> / <code>robot.set_speed(0.5)</code> <code>robot.speed</code> / <code>robot.speed = 0.5</code> Readability More verbose Clean, attribute-like access Validation \u2705 Full control \u2705 Full control Pythonic Less Pythonic \u2705 Highly Pythonic Learning Curve Easier to understand initially Requires understanding decorators <p>!!! tip \"When to Use Each Approach\" - Traditional getters/setters: When you need complex validation logic or multiple parameters - Property decorators: For simple attribute access with validation (recommended for most cases)</p>"},{"location":"sessions/session-05/#check-your-knowledge","title":"Check Your Knowledge","text":"<p>Test your understanding of the advanced OOP concepts covered in this session:</p> <p>Question 1: <code>__str__</code> vs <code>__repr__</code> Purpose</p> <p>Question: You have a <code>RobotSensor</code> object. When would Python call <code>__str__()</code> vs <code>__repr__()</code>? Give specific examples.</p> Click to reveal answer <p>Answer: : </p> <p><code>__str__()</code> is called when: - You use <code>print(sensor)</code> - You use <code>str(sensor)</code>  - String formatting like <code>f\"Sensor data: {sensor}\"</code></p> <p><code>__repr__()</code> is called when: - You use <code>repr(sensor)</code> - The object appears in a list: <code>print([sensor1, sensor2])</code> - In the debugger or interactive shell when you just type the variable name - When <code>__str__()</code> is not defined, Python falls back to <code>__repr__()</code></p> <p>Question 2: Property Decorator Syntax</p> <p>Question: Look at this code. What's wrong with it?</p> <pre><code>class Robot:\n    def __init__(self):\n        self._speed = 0.0\n\n    @property\n    def speed(self, value):\n        self._speed = value\n</code></pre> Click to reveal answer <p>Answer: </p> <p>The <code>@property</code> decorator is used incorrectly. The method decorated with <code>@property</code> should be the getter (no parameters except <code>self</code>). To set values, you need a separate setter:</p> <pre><code>class Robot:\n    def __init__(self):\n        self._speed = 0.0\n\n    @property\n    def speed(self):  # Getter - no value parameter\n        return self._speed\n\n    @speed.setter\n    def speed(self, value):  # Setter - has value parameter\n        self._speed = value\n</code></pre> <p>````</p> Question 3: When to Use Properties <p>Question: Your robot has a <code>battery_level</code> that should never go below 0 or above 100. Should you use a property or just a regular attribute? Why?</p> Click to reveal answer <p>Answer: </p> <p>Use a property because you need validation. Here's why:</p> <ul> <li>Validation needed: Battery levels have strict limits (0-100%)</li> <li>Safety critical: Invalid battery levels could cause unsafe robot behavior</li> <li>Clean syntax: <code>robot.battery_level = 85</code> is cleaner than <code>robot.set_battery_level(85)</code></li> </ul> <p>Example implementation: <pre><code>@property\ndef battery_level(self):\n    return self._battery_level\n\n@battery_level.setter\ndef battery_level(self, value):\n    if not 0 &lt;= value &lt;= 100:\n        raise ValueError(\"Battery level must be 0-100%\")\n    self._battery_level = value\n</code></pre></p> Question 4: Understanding <code>self</code> in Magic Methods <p>Question: In <code>def __str__(self):</code>, what does <code>self</code> refer to, and why don't you need to pass it when calling <code>print(robot)</code>?</p> Click to reveal answer <p>Answer: </p> <ul> <li><code>self</code> refers to: The specific robot object that <code>__str__()</code> is being called on</li> <li>Why you don't pass it: Python automatically passes <code>self</code> when you call methods on objects</li> </ul> <p>When you write <code>print(robot)</code>: 1. Python internally calls <code>robot.__str__()</code> 2. Python automatically passes the <code>robot</code> object as the <code>self</code> parameter 3. Your <code>__str__</code> method can then access <code>self.robot_id</code>, <code>self.battery_percentage</code>, etc.</p> <p>This is the same reason you don't write <code>robot.move_forward(robot, 0.5)</code> - Python handles the <code>self</code> parameter automatically.</p> Question 5: Property vs Method Decision <p>Question: For each of these robot operations, should it be a property or a method? Explain your reasoning.</p> <ul> <li><code>robot.current_speed</code> (just getting the speed)</li> <li><code>robot.turn_left()</code> (making the robot turn)  </li> <li><code>robot.battery_percentage</code> (getting/setting battery level)</li> <li><code>robot.emergency_stop()</code> (immediate stop command)</li> </ul> Click to reveal answer <p>Answer: </p> <ul> <li><code>robot.current_speed</code> \u2192 Property: Getting data, no action performed, feels like an attribute</li> <li><code>robot.turn_left()</code> \u2192 Method: Performs an action, changes robot state, side effects</li> <li><code>robot.battery_percentage</code> \u2192 Property: Data that might need validation, attribute-like access</li> <li><code>robot.emergency_stop()</code> \u2192 Method: Critical action, clear that something important happens</li> </ul> <p>Rule of thumb:  - Properties: For data access (getting/setting values) that feels like attribute access - Methods: For actions, operations, or anything that \"does something\" to the object</p>"},{"location":"sessions/session-05/#lab-2-line-follower-robot-implementation","title":"Lab 2: Line-follower Robot Implementation","text":"<p>In this lab, you will implement a line-following robot using object-oriented programming principles in the Webots simulator. This lab builds on the OOP concepts learned in Sessions 4 and 5, applying them to a real robotics problem.</p> <p>Lab Credits</p> <p>This lab is adapted from the excellent work by Felipe Martins:</p> <p>Original Repository: Robotics-Simulation-Labs Author: Felipe Nascimento Martins License: Available on GitHub</p> <p>We acknowledge and appreciate the open-source contribution to robotics education.</p>"},{"location":"sessions/session-05/#about-line-following","title":"About Line Following","text":"<p>Line following is a fundamental robotics task where a robot uses sensors to detect and follow a path marked on the ground. This requires:</p> <ul> <li>Sensor data processing: Reading and interpreting sensor values</li> <li>Decision making: Determining robot actions based on sensor data</li> <li>Motor control: Translating decisions into wheel movements</li> <li>Real-time operation: Continuously processing sensor data and adjusting behavior</li> </ul>"},{"location":"sessions/session-05/#lab-setup","title":"Lab Setup","text":"<p>Before starting the implementation, ensure you have:</p> <ol> <li>Webots simulator installed and working (from Session 4)</li> <li>Python 3.9+ configured with Webots</li> <li>Basic understanding of OOP concepts from Sessions 4 and 5</li> </ol>"},{"location":"sessions/session-05/#lab-2-line-follower-with-state-machine","title":"Lab 2 \u2013 Line-follower with State Machine","text":""},{"location":"sessions/session-05/#objectives","title":"Objectives","text":"<p>The goal of this lab is to learn more about controllers in Webots via the implementation of state machine to make the robot follow a line. </p>"},{"location":"sessions/session-05/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>You must have Webots R2022a (or newer) properly configured to work with Python. </li> <li>You must know how to create a robot controller in Python and how to run a simulation. </li> </ul> <p>If you are still missing any of those, please go back to Lab 1 and complete the corresponding tasks.</p>"},{"location":"sessions/session-05/#the-e-puck-robot","title":"The e-puck robot","text":"<p>Webots contains a realistic model of e-puck, a small differential-drive mobile robot. The movement of this type of robot is controlled by independently adjusting the speeds of the left and right wheels. </p> <p>The e-puck robot has multiple sensors. To detect obstacles, the e-puck contains 8 infrared distance sensors around its body. Optionally, 3 infrared sensors can be mounted under its base, pointing to the floor, allowing the implementation of a line-following behavior. </p> <p>An explanation about the e-puck robot and how to use it in Webots is available in Webots Tutorial 4.</p>"},{"location":"sessions/session-05/#tasks","title":"Tasks","text":"<p>1- Follow Webots Tutorial 4 to better understand the e-puck model and learn how to control it in Python.</p> <p>2- After finishing tutorial 4, open the line-following sample world: Click on <code>File &gt; Open Sample Worlds</code> and go to <code>robots &gt; gctronic &gt; e-puck</code> and select <code>e-puck_botstudio_with_floor_sensors.wbt</code>. You should see a world similar to the one shown in Figure 1. In the next steps you must use the e-puck robot that is loaded with this sample world because it has the floor sensors to detect the line. </p> <p></p>"},{"location":"sessions/session-05/#figure-1-webots-screenshot-with-the-world-e-puck_botstudio_with_floor_sensorswbt","title":"Figure 1. Webots screenshot with the world \u201ce-puck_botstudio_with_floor_sensors.wbt\u201d.","text":"<p>3- You will need to make changes to the file, so you have to save the sample world with a different name on a folder of your choice. </p> <p>4- Write a simple program to investigate the values returned by the floor sensors when the robot is over the white floor and over the black line. You can use the print function to show the sensor values in the Webots console. More information about how to read the ground sensors is given below.</p> <p>5- Test the motor speeds to determine how fast the robot should run and turn in order to follow the line.</p> <p>6- Create a new controller in Python and implement a line-following behavior using what you learned from the steps above. You can use the state machine shown in Figure 2 as reference. </p> <p>7- Finally, add one extra state to stop the robot when no line is detected.</p> <p></p>"},{"location":"sessions/session-05/#figure-2-a-state-machine-diagram-that-implements-a-line-follower-behavior","title":"Figure 2. A state machine diagram that implements a line-follower behavior.","text":""},{"location":"sessions/session-05/#ground-sensors","title":"Ground sensors","text":"<p>In Tutorial 4 you made use of the distance sensors around the robot. To detect the line on the floor you need to use the ground sensors, instead. The simulator also treats the ground sensors as distance sensors because they are of the same type (infrared sensors). In Python you can access the ground sensors as shown below.</p> <p>To initialize the ground sensors: <pre><code>gs = []\ngsNames = ['gs0', 'gs1', 'gs2']\nfor i in range(3):\n    gs.append(robot.getDevice(gsNames[i]))\n    gs[i].enable(timestep)\n</code></pre></p> <p>To read the ground sensors inside the main loop: <pre><code>gsValues = []\nfor i in range(3):\n    gsValues.append(gs[i].getValue())\n</code></pre></p> <p>To read sensor values inside the main loop: <pre><code>line_right = gsValues[0]\nline_center = gsValues[1]\nline_left = gsValues[2]\n</code></pre></p> <p>If you need inspiration, check the template code available here!</p>"},{"location":"sessions/session-05/#solution","title":"Solution","text":"<p>Try to implement the state machine yourself before checking the solution! A possible solution (without the stop state) is available here.</p> <p>The video below shows the solution code in action:</p> <p>.</p>"},{"location":"sessions/session-05/#challenge-obstacle-avoidance","title":"Challenge: Obstacle Avoidance","text":"<p>Change the state machine to make e-puck avoid obstacles placed on its way. You can choose the type of obstacle to add: different formats might require different strategies of obstacle avoidance. Obstacles with round or rectangular shape usually are the less demanding, while obstacles with U-shape require more complex strategies.</p> <p>An illustration of obstacle avoidance with state machine is given in Figure 3. Note that the obstacle avoidance strategy that was implemented required four extra states, some executing the same action as others. The animation in Figure 3 shows the active state (in red) for each condition during the simulation.</p> <p></p>"},{"location":"sessions/session-05/#figure-3-illustration-of-obstacle-avoidance-strategy-added-to-the-existing-line-follower-state-machine","title":"Figure 3. Illustration of obstacle avoidance strategy added to the existing line-follower state machine.","text":"<p>Student Wilfred van Reenen made the video below to illustrate the excellent performance of his obstacle avoidance state machine. If you want to go above and beyond, try to get your robot to avoid all those obstacles!</p> <p>.</p> <p>OOP Refactoring task</p>"},{"location":"sessions/session-05/#lab-2-object-oriented-programming-refactoring","title":"Lab 2: Object-Oriented Programming Refactoring","text":""},{"location":"sessions/session-05/#task-overview","title":"Task Overview","text":"<p>Refactor the provided procedural line-following robot code into an object-oriented design.</p>"},{"location":"sessions/session-05/#main-task","title":"Main Task","text":"<ol> <li>Complete the <code>LineFollowingRobot</code> class</li> <li>Fill in all <code>TODO</code> methods in the provided framework</li> <li>Move global variables into the class as instance variables</li> <li>Break the main loop into logical methods</li> <li>Test that your robot still follows lines correctly</li> </ol>"},{"location":"sessions/session-05/#learning-objectives_1","title":"Learning Objectives","text":"<ul> <li>Practice encapsulation (data and methods together)</li> <li>Learn to organize code into classes and methods</li> <li>Understand how OOP improves code structure and readability</li> </ul>"},{"location":"sessions/session-05/#line-following-robot-architecture","title":"Line-Following Robot Architecture","text":"<p>Our robot will use an object-oriented architecture with these main components:</p>"},{"location":"sessions/session-05/#line-following-architecture-uml-diagram","title":"Line-Following Architecture UML Diagram","text":"<pre><code>    classDiagram\n    class LineFollowingRobot {\n        -MAX_SPEED: float\n        -COUNTER_MAX: int\n        -current_state: str\n        -counter: int\n        -robot: WebotsRobot\n        -timestep: int\n        -ground_sensors: list\n        -leftMotor: Motor\n        -rightMotor: Motor\n        +__init__()\n        +read_sensors(): tuple\n        +move_forward()\n        +turn_right()\n        +turn_left()\n        +update_state(line_left: bool, line_right: bool)\n        +run()\n    }</code></pre>"},{"location":"sessions/session-05/#submission-template","title":"Submission template","text":"<pre><code># Lab 2: Object-Oriented Programming - Line Following Robot\n\n\nfrom controller import Robot as WebotsRobot, DistanceSensor, Motor\n\n\nclass LineFollowingRobot:\n    \"\"\"A simple robot that follows lines\"\"\"\n\n    def __init__(self):\n        \"\"\"Set up the robot and its sensors/motors\"\"\"\n        self.MAX_SPEED = 6.28\n        self.COUNTER_MAX = 5\n\n        # State variables\n        self.current_state = 'forward'\n        self.counter = 0\n\n        # TODO: Create robot instance\n\n        # TODO: Get timestep from robot\n\n        # TODO: Initialize ground sensors\n\n        # TODO: Initialize motors\n\n\n    def read_sensors(self):\n        \"\"\"Read ground sensors and return line detection\"\"\"\n        # TODO: Read ground sensor values\n\n        # TODO: Check if line is detected on left and right\n\n        # TODO: Return (line_left, line_right)\n\n\n    def move_forward(self):\n        \"\"\"Move robot forward\"\"\"\n        # TODO: Set motor speeds for forward movement\n\n\n    def turn_right(self):\n        \"\"\"Turn robot right\"\"\"\n        # TODO: Set motor speeds for right turn\n\n\n    def turn_left(self):\n        \"\"\"Turn robot left\"\"\"  \n        # TODO: Set motor speeds for left turn\n\n\n    def update_state(self, line_left, line_right):\n        \"\"\"Update robot state based on line detection\"\"\"\n        # TODO: Implement state machine logic\n\n\n    def run(self):\n        \"\"\"Main robot loop\"\"\"\n        # TODO: Implement main loop\n\n\n\n    # Run the robot\n    if __name__ == \"__main__\":\n        robot = LineFollowingRobot()\n        robot.run()\n</code></pre>"},{"location":"sessions/session-05/#deliverables","title":"Deliverables","text":"<ul> <li>Completed <code>LineFollowingRobot</code> class</li> <li>Working robot simulation</li> <li>Brief reflection: How does the OOP version compare to the original procedural code?</li> </ul>"},{"location":"sessions/session-05/#conclusion","title":"Conclusion","text":"<p>After following this lab you should know more about the e-puck robot model, how to program a controller for it in Python, and how to program a robot behavior based on state machine. </p>"},{"location":"sessions/session-05/#debugging-tips","title":"Debugging Tips","text":"<p>Common Issues and Solutions</p> <p>Robot doesn't move: Check that motors are properly initialized and <code>timestep</code> is correct</p> <p>Erratic behavior: Adjust the <code>base_speed</code> and <code>turn_speed</code> parameters</p> <p>Line not detected: Verify the sensor threshold values for your specific world</p> <p>Console spam: The debug output is limited to ~1 second intervals to keep it readable</p>"},{"location":"sessions/session-05/#extension-challenges","title":"Extension Challenges","text":"<p>Once you have the basic implementation working, try these enhancements:</p> <ol> <li>Add speed control: Make the robot slow down in tight turns</li> <li>Implement PID control: Use proportional, integral, and derivative control for smoother following</li> <li>Add line-lost recovery: Handle situations where the robot completely loses the line</li> <li>Implement different following modes: Allow switching between fast/slow/precise modes</li> </ol>"},{"location":"sessions/session-05/#session-summary-advanced-oop-features-in-robotics","title":"Session Summary: Advanced OOP Features in Robotics","text":"<p>In this session, you've learned how to make your robotics code more professional and maintainable through advanced OOP features:</p>"},{"location":"sessions/session-05/#key-concepts-mastered","title":"Key Concepts Mastered","text":"<pre><code>mindmap\n  root((Advanced OOP Features))\n    Magic Methods\n      __str__ for users\n      __repr__ for developers\n      Better debugging\n    Data Encapsulation\n      Traditional getters/setters\n      Property decorators\n      Data validation\n    Function Wrapping\n      Decorator foundations\n      Understanding @property\n      Code organization\n    Practical Application\n      Line following robot\n      Sensor fusion\n      Object-oriented architecture</code></pre>"},{"location":"sessions/session-05/#design-patterns-used","title":"Design Patterns Used","text":"<p>Throughout this session, we've implemented several important design patterns:</p> <ul> <li>Encapsulation: Hiding internal data and providing controlled access</li> <li>Composition: Building complex objects from simpler components</li> <li>Single Responsibility: Each class has one clear purpose</li> <li>Property Pattern: Clean attribute-like access with validation</li> </ul> <p>!!! success \"Professional Development\" The techniques learned in this session are used in production robotics software. You're now writing code that follows industry best practices!</p>"},{"location":"sessions/session-05/#out-of-class-research-activities","title":"Out-of-Class Research Activities","text":"<p>To reinforce your understanding and prepare for advanced topics:</p>"},{"location":"sessions/session-05/#research-topics","title":"Research Topics","text":"<ol> <li> <p>Python Magic Methods Deep Dive</p> <ul> <li>Research other useful magic methods (<code>__eq__</code>, <code>__lt__</code>, <code>__len__</code>)</li> <li>Find examples of magic methods in robotics frameworks</li> <li>Study how magic methods enable operator overloading</li> <li> <p>Property Decorators Advanced Usage</p> </li> <li> <p>Investigate read-only properties and computed properties</p> </li> <li>Research property caching for expensive calculations</li> <li>Look into property validation patterns</li> <li> <p>Robotics Control Systems</p> </li> <li> <p>Study PID controllers and their implementation in OOP</p> </li> <li>Research state machines for robot behavior</li> <li>Investigate sensor fusion algorithms and OOP design</li> <li> <p>Code Quality and Testing</p> </li> <li> <p>Research unit testing for robotics code</p> </li> <li>Study debugging techniques for real-time systems</li> <li>Investigate logging best practices for robotics applications</li> </ul> </li> </ol> <p>Recommended Resources</p> <ul> <li>Python official documentation on data model - Real Python articles on properties and magic methods  </li> <li>Open-source robotics projects showing OOP patterns - ROS (Robot Operating System) architectural documentation</li> </ul>"},{"location":"sessions/session-05/#next-session-preview","title":"Next Session Preview","text":"<p>Week 6: Inheritance &amp; Polymorphism</p> <ul> <li>Creating class hierarchies for different robot types</li> <li>Method overriding and super() usage</li> <li>Abstract base classes for robotics interfaces</li> <li>Polymorphic behavior in sensor and actuator systems</li> <li>Advanced UML diagrams and design patterns</li> </ul>"},{"location":"sessions/session-05/#further-reading","title":"Further Reading","text":"<ul> <li>Python Data Model Documentation</li> <li>Property Decorator Patterns</li> <li>Robotics Software Engineering Best Practices</li> <li>Object-Oriented Design Patterns in Robotics</li> </ul> <p>Navigation: \u2190 Week 4 | Learning Plan | Week 6 \u2192</p>"},{"location":"sessions/session-05_oop/","title":"Session 05 oop","text":""},{"location":"sessions/session-05_oop/#system-architecture-uml-diagram","title":"System Architecture UML Diagram","text":"<pre><code>classDiagram\n    class LineFollowerRobot {\n        -DistanceSensors distance_sensors\n        -GroundSensors ground_sensors  \n        -WheelMotors motors\n        +__init__()\n        +run()\n        +__str__()\n        +__repr__()\n    }\n\n    class DistanceSensors {\n        -list sensor_objects\n        +__init__(robot)\n        +get_readings()\n        +detect_obstacle()\n        +__str__()\n    }\n\n    class GroundSensors {\n        -list sensor_objects\n        +__init__(robot) \n        +get_readings()\n        +detect_line()\n        +calculate_line_position()\n        +__str__()\n    }\n\n    class WheelMotors {\n        -Motor left_motor\n        -Motor right_motor\n        -float _max_speed\n        +__init__(robot)\n        +set_speeds(left, right)\n        +stop()\n        +speed: float\n        +__str__()\n    }\n\n    LineFollowerRobot --&gt; DistanceSensors : uses\n    LineFollowerRobot --&gt; GroundSensors : uses  \n    LineFollowerRobot --&gt; WheelMotors : uses\n\n    note for LineFollowerRobot \"Main controller coordinating\\nall robot subsystems\"\n    note for DistanceSensors \"Manages IR distance sensors\\nfor obstacle detection\"\n    note for GroundSensors \"Manages ground-facing sensors\\nfor line detection\"\n    note for WheelMotors \"Controls left and right wheel\\nmotors with speed validation\"</code></pre>"},{"location":"sessions/session-05_oop/#step-1-ground-sensors-class-implementation","title":"Step 1: Ground Sensors Class Implementation","text":"<p>The ground sensors detect the line by measuring light reflection from the ground. Dark lines reflect less light than the surrounding surface.</p> <pre><code>class GroundSensors:\n    \"\"\"Manages ground-facing sensors for line detection.\"\"\"\n\n    def __init__(self, robot):\n        \"\"\"\n        Initialize ground sensors.\n\n        Args:\n            robot: Webots robot object\n        \"\"\"\n        # Get ground sensor objects from Webots\n        self.sensors = []\n        sensor_names = ['gs0', 'gs1', 'gs2']  # Ground sensor names in Webots\n\n        for name in sensor_names:\n            sensor = robot.getDevice(name)\n            sensor.enable(robot.timestep)\n            self.sensors.append(sensor)\n\n        self.num_sensors = len(self.sensors)\n        print(f\"Ground sensors initialized: {self.num_sensors} sensors\")\n\n    @property\n    def readings(self):\n        \"\"\"\n        Get current sensor readings.\n\n        Returns:\n            list: List of sensor values (higher = lighter surface)\n        \"\"\"\n        return [sensor.getValue() for sensor in self.sensors]\n\n    def detect_line(self, threshold=500):\n        \"\"\"\n        Detect if any sensor sees the line.\n\n        Args:\n            threshold (float): Value below which we consider line detected\n\n        Returns:\n            bool: True if line is detected by any sensor\n        \"\"\"\n        readings = self.readings\n        return any(reading &lt; threshold for reading in readings)\n\n    def calculate_line_position(self, threshold=500):\n        \"\"\"\n        Calculate line position relative to robot center.\n\n        Args:\n            threshold (float): Line detection threshold\n\n        Returns:\n            float: Position from -1.0 (far left) to 1.0 (far right), 0.0 = center\n        \"\"\"\n        readings = self.readings\n\n        # Convert readings to binary (0 = line, 1 = no line)\n        binary_readings = [1 if reading &lt; threshold else 0 for reading in readings]\n\n        # Calculate weighted average position\n        if sum(binary_readings) == 0:\n            return 0.0  # No line detected, assume center\n\n        total_weight = 0\n        weighted_sum = 0\n\n        for i, reading in enumerate(binary_readings):\n            if reading == 1:  # Line detected\n                position = (i - (self.num_sensors - 1) / 2) / ((self.num_sensors - 1) / 2)\n                weighted_sum += position * reading\n                total_weight += reading\n\n        return weighted_sum / total_weight if total_weight &gt; 0 else 0.0\n\n    def __str__(self):\n        \"\"\"User-friendly sensor status.\"\"\"\n        readings = self.readings\n        return f\"Ground Sensors: {[f'{r:.0f}' for r in readings]} (line detected: {self.detect_line()})\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return f\"GroundSensors(num_sensors={self.num_sensors})\"\n</code></pre>"},{"location":"sessions/session-05_oop/#step-2-distance-sensors-class-implementation","title":"Step 2: Distance Sensors Class Implementation","text":"<p>The distance sensors detect obstacles in front of the robot.</p> <pre><code>class DistanceSensors:\n    \"\"\"Manages IR distance sensors for obstacle detection.\"\"\"\n\n    def __init__(self, robot):\n        \"\"\"\n        Initialize distance sensors.\n\n        Args:\n            robot: Webots robot object\n        \"\"\"\n        # Get distance sensor objects from Webots  \n        self.sensors = []\n        sensor_names = ['ps0', 'ps1', 'ps2', 'ps5', 'ps6', 'ps7']  # Front-facing sensors\n\n        for name in sensor_names:\n            sensor = robot.getDevice(name)\n            sensor.enable(robot.timestep)\n            self.sensors.append(sensor)\n\n        print(f\"Distance sensors initialized: {len(self.sensors)} sensors\")\n\n    @property  \n    def readings(self):\n        \"\"\"\n        Get current sensor readings.\n\n        Returns:\n            list: List of sensor values (higher = closer object)\n        \"\"\"\n        return [sensor.getValue() for sensor in self.sensors]\n\n    def detect_obstacle(self, threshold=100):\n        \"\"\"\n        Detect if obstacle is too close.\n\n        Args:\n            threshold (float): Distance threshold for obstacle detection\n\n        Returns:\n            bool: True if obstacle detected\n        \"\"\"\n        front_sensors = self.readings[1:5]  # Use middle sensors\n        return any(reading &gt; threshold for reading in front_sensors)\n\n    def __str__(self):\n        \"\"\"User-friendly sensor status.\"\"\"\n        readings = self.readings\n        obstacle = \"YES\" if self.detect_obstacle() else \"NO\"\n        return f\"Distance Sensors: obstacle={obstacle}, readings={[f'{r:.0f}' for r in readings[:3]]}\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return f\"DistanceSensors(num_sensors={len(self.sensors)})\"\n</code></pre>"},{"location":"sessions/session-05_oop/#step-3-motor-controller-class-implementation","title":"Step 3: Motor Controller Class Implementation","text":"<p>The motor controller manages wheel speeds and implements the control algorithm.</p> <pre><code>class WheelMotors:\n    \"\"\"Controls robot wheel motors with validation.\"\"\"\n\n    def __init__(self, robot, max_speed=6.28):\n        \"\"\"\n        Initialize wheel motors.\n\n        Args:\n            robot: Webots robot object\n            max_speed (float): Maximum wheel speed in rad/s\n        \"\"\"\n        # Get motor objects from Webots\n        self.left_motor = robot.getDevice('left wheel motor')\n        self.right_motor = robot.getDevice('right wheel motor')\n\n        # Set motors to velocity control mode\n        self.left_motor.setPosition(float('inf'))\n        self.right_motor.setPosition(float('inf'))\n\n        self._max_speed = max_speed\n        self._current_left_speed = 0.0\n        self._current_right_speed = 0.0\n\n        print(f\"Motors initialized with max speed: {max_speed} rad/s\")\n\n    @property\n    def max_speed(self):\n        \"\"\"Get maximum motor speed.\"\"\"\n        return self._max_speed\n\n    @property  \n    def speeds(self):\n        \"\"\"Get current motor speeds as tuple (left, right).\"\"\"\n        return (self._current_left_speed, self._current_right_speed)\n\n    def set_speeds(self, left_speed, right_speed):\n        \"\"\"\n        Set motor speeds with validation.\n\n        Args:\n            left_speed (float): Left wheel speed (-max_speed to +max_speed)\n            right_speed (float): Right wheel speed (-max_speed to +max_speed)\n        \"\"\"\n        # Validate and clamp speeds\n        left_speed = max(-self._max_speed, min(self._max_speed, left_speed))\n        right_speed = max(-self._max_speed, min(self._max_speed, right_speed))\n\n        # Apply speeds to motors\n        self.left_motor.setVelocity(left_speed)\n        self.right_motor.setVelocity(right_speed)\n\n        # Store current speeds\n        self._current_left_speed = left_speed\n        self._current_right_speed = right_speed\n\n    def stop(self):\n        \"\"\"Stop both motors.\"\"\"\n        self.set_speeds(0.0, 0.0)\n        print(\"Motors stopped\")\n\n    def __str__(self):\n        \"\"\"User-friendly motor status.\"\"\"\n        left, right = self.speeds\n        return f\"Motors: L={left:.2f}, R={right:.2f} (max: {self._max_speed:.2f} rad/s)\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return f\"WheelMotors(max_speed={self._max_speed})\"\n</code></pre>"},{"location":"sessions/session-05_oop/#step-4-main-line-follower-robot-class","title":"Step 4: Main Line Follower Robot Class","text":"<p>Now we'll create the main robot class that coordinates all subsystems.</p> <pre><code>from controller import Robot\n\nclass LineFollowerRobot:\n    \"\"\"Main line-following robot controller.\"\"\"\n\n    def __init__(self):\n        \"\"\"Initialize the line follower robot.\"\"\"\n        # Initialize Webots robot\n        self.robot = Robot()\n        self.timestep = int(self.robot.getBasicTimeStep())\n\n        # Initialize subsystems  \n        self.ground_sensors = GroundSensors(self.robot)\n        self.distance_sensors = DistanceSensors(self.robot)\n        self.motors = WheelMotors(self.robot)\n\n        # Control parameters\n        self.base_speed = 3.0      # Base forward speed\n        self.turn_speed = 2.0      # Speed adjustment for turning\n\n        print(\"Line follower robot initialized successfully!\")\n\n    def calculate_motor_speeds(self, line_position):\n        \"\"\"\n        Calculate motor speeds based on line position.\n\n        Args:\n            line_position (float): Line position from -1.0 to 1.0\n\n        Returns:\n            tuple: (left_speed, right_speed)\n        \"\"\"\n        # PID-like control: stronger turning for larger errors\n        error = line_position\n        turn_adjustment = error * self.turn_speed\n\n        # Calculate individual wheel speeds\n        left_speed = self.base_speed - turn_adjustment\n        right_speed = self.base_speed + turn_adjustment\n\n        return (left_speed, right_speed)\n\n    def run(self):\n        \"\"\"Main control loop.\"\"\"\n        print(\"Starting line following behavior...\")\n        print(\"Use Ctrl+C to stop the robot\")\n\n        try:\n            while self.robot.step(self.timestep) != -1:\n                # Check for obstacles first\n                if self.distance_sensors.detect_obstacle():\n                    print(\"Obstacle detected! Stopping robot.\")\n                    self.motors.stop()\n                    continue\n\n                # Get line position\n                line_position = self.ground_sensors.calculate_line_position()\n\n                # Calculate and apply motor speeds\n                left_speed, right_speed = self.calculate_motor_speeds(line_position)\n                self.motors.set_speeds(left_speed, right_speed)\n\n                # Debug output every 50 steps (reduce console spam)\n                if self.robot.getTime() % 1.0 &lt; self.timestep / 1000.0:  # Every ~1 second\n                    print(f\"Line pos: {line_position:+.2f}, Motors: L={left_speed:.2f} R={right_speed:.2f}\")\n                    print(f\"  {self.ground_sensors}\")\n                    print(f\"  {self.distance_sensors}\")\n                    print()\n\n        except KeyboardInterrupt:\n            print(\"\\nRobot stopped by user\")\n            self.motors.stop()\n\n    def __str__(self):\n        \"\"\"User-friendly robot status.\"\"\"\n        return f\"LineFollowerRobot: base_speed={self.base_speed}, turn_speed={self.turn_speed}\"\n\n    def __repr__(self):\n        \"\"\"Developer representation.\"\"\"\n        return \"LineFollowerRobot()\"\n\n# Main execution\nif __name__ == \"__main__\":\n    # Create and run the robot\n    robot = LineFollowerRobot()\n    print(robot)\n    print(repr(robot))\n    robot.run()\n</code></pre>"},{"location":"sessions/session-05_oop/#step-5-complete-implementation","title":"Step 5: Complete Implementation","text":"<p>Here's how to put it all together in a single file (<code>line_follower_robot.py</code>):</p> <pre><code>\"\"\"\nLine Following Robot Implementation\nUses object-oriented programming principles for modular robotics code.\n\"\"\"\n\nfrom controller import Robot\n\n# [Include all the class implementations above in order:]\n# 1. GroundSensors class\n# 2. DistanceSensors class  \n# 3. WheelMotors class\n# 4. LineFollowerRobot class\n# 5. Main execution code\n\n# Run the robot\nif __name__ == \"__main__\":\n    robot = LineFollowerRobot()\n    robot.run()\n</code></pre>"}]}